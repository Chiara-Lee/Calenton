[{"content":"在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。\n1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。\n数学中的语句按照分支被分为各自分支中的基本语句和复合语句。\n具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\\cdot7+2\\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 \u003c 来表征小于的线性序关系，那么 1+2\u003c2+3 、 5\\cdot2\u003c5\\cdot3 就都是基础语句。\n复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如\n\\begin{array}{l} ((5 \\cdot 2\u003c3 \\cdot 2) \\rightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\leftrightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\vee(\\neg(0=1))) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\wedge(\\neg(0=1))) \\end{array} 就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：\n\\neg(非),\\rightarrow(蕴含),\\leftrightarrow(对等),\\vee(或),\\wedge(且) 其中，\n1.符号\u0026quot; \\neg \u0026quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”\n2.符号\u0026quot; \\rightarrow \u0026quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”\n3.符号\u0026quot; \\leftrightarrow \u0026quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思\n4.符号\u0026quot; \\vee \u0026quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”\n5.符号\u0026quot; \\wedge \u0026quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”\n基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：\n\\begin{array}{l} 5\\cdot7+2\\cdot3=41\\\\ 5\\cdot3=11 \\end{array} 在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \\{0,1\\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。\n复合语句真假判定归结过程 复合语句的真假判定依赖于复合语句的布尔值计算规则。\n同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。\n我们约定用 1 来表示真，用 0 来表示假。并且 1\\ne 0 。复合语句的真假赋值必须遵从以下五条计算等式规则：\n1.否定词计算规则：‘并非’\n如果 A 是一个已经被赋值了的较低层次的逻辑命题，那么对于 A 的否定式 (\\neg A) 的赋值必须满足下述背反等式的要求：\n对 (\\neg A) 赋值为 1 的充要条件是对 A 的赋值为 0 ,对 (\\neg A) 赋值为 0 的充要条件是对 A 的赋值为 1 2.蕴含词计算规则：‘如果，那么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式 (A\\rightarrow B) 的真值赋值必须满足下述蕴含等式要求：对 (A\\rightarrow B) 的赋值为 0 的充分必要条件是 “(对 A 赋值为 1 ，对 B 赋值为 0 )”。 在蕴含赋值计算表中，我们将蕴含式 (A \\to B) 放于最右侧是因为， (A \\to B) 命题的层级比 A 和 B 都高，对于 (A \\to B) 的真值的赋值依赖于对 A 和 B 的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。\n3.析取词计算规则：‘要么，要么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的析取式 (A \\lor B) 的赋值必须满足下述析取等式要求：对 (A \\lor B) 的赋值为 1 的充分必要条件是 “（或对 A 的赋值为 1 ，或对 B 的赋值为 1 ）”，对 (A \\lor B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，并且对 B 的赋值也为 0 ）”。\n4.合取词计算规则：‘不仅，而且’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么他们的合取式 (A \\land B) 的赋值必须满足以下合取等式要求：对 (A \\land B) 的赋值为 1 的充分必要条件是 “（对 A 的赋值为 1 ，并且对 B 的赋值也为 1 ）”，对 (A \\land B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，或对 B 的赋值为 0 ）”。\n5.对等词计算规则：‘当且仅当’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的对等式 (A \\leftrightarrow B) 的赋值必须满足以下对等等式要求：对 (A \\leftrightarrow B) 赋值为 1 的充分必要条件是 “（对 A 和对 B 的赋值是相等的）”，对 (A \\leftrightarrow B) 赋值为 0 的充分必要条件是 “（对 A 和对 B 的赋值是不相等的）”。\n从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）\n\\begin{array}{l} 1. \\, A \\, \\text{与} \\, (\\neg(\\neg A)) \\, \\text{等价} \\\\ 2. \\, (A \\to B) \\, \\text{与} \\, ((\\neg B) \\to (\\neg A)) \\, \\text{等价} \\\\ 3. \\, (A \\lor B) \\, \\text{与} \\, (B \\lor A) \\, \\text{等价} \\\\ 4. \\, (A \\land B) \\, \\text{与} \\, (B \\land A) \\, \\text{等价} \\\\ 5. \\, (A \\leftrightarrow B) \\, \\text{与} \\, (B \\leftrightarrow A) \\, \\text{等价} \\end{array} 另外两条规律也值得注意：\n\\begin{array}{l} 6. \\, \\text{如果} \\, (A \\to B) \\, \\text{并且} \\, (B \\to C), \\, \\text{则} \\, (A \\to C) \\\\ 7. \\, \\text{如果} \\, (A \\leftrightarrow B) \\, \\text{并且} \\, (B \\leftrightarrow C), \\, \\text{则} \\, (A \\leftrightarrow C) \\end{array} 在数学逻辑中，我们实际上可以只要一条基本的推导规则：由 A 和 (A \\to B) 导出 B 来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。\n另外还需要注意，人们时常使用 \\Leftarrow 代替 \\leftarrow ， \\Rightarrow 代替 \\rightarrow ， \\Leftrightarrow 代替 \\leftrightarrow 。\n1.1.2 表达式及其语义解释 基本表达式及其语义解释 一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。\n比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：\nx+(y+z)=(x+y)+z\\\\ 当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。\n前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如， x+y=y+x 这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?\n在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为论域。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的结构就是线性代数的基本对象。\n因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。\n第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如\n1，2，3\\cdots2024\\cdots\\\\ 为一个项。\n任何一个被用来表示任意个体的变量（符号），比如\nx,y,z,A,B,C\\cdots \\\\ 也是一个项。\n然后，由任意两个已有的项 t_1 和 t_2 经过加法、乘法运算就可以得到新的项\nt_1+t_2,t_1\\cdot t_2 \\\\ 最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots+a_nx_n\\\\ x^m+b_1x^m+\\cdots+b_{m-1}x_1 \\end{array} 就是两个项。\n第二，我们规定，任何一个基本表达式无非就是由两个项所组成的一个等式，比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots a_nx_n=1,\\\\ x_m+\\cdots+b_m=0\\\\ \\end{array} 如果我们还关心诸如实数的线性序（例如 \u003c 就是被用来表达线性序的符号），那么任何一个涉及线性序的基本表达式就是由两个项所组成的不等式。比如\n\\begin{array}{l} a_1x_1+\\cdots+a_nx_n\u003c0,\\\\ b_1m_1+\\cdots+b_2m_2\u003ex_1+\\cdots+x_n\\\\ \\end{array} 不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种基本表达式：项之间的等式、项之间的不等式。以上两种基本表达式我们就分别称之为基本等式和基本不等式。\n第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。\n第四，在前述的基础上，我们来解决基本表达式的真假判定问题。\n给定一个基本表达式，令 t_1(x_1, \\cdots, x_n) 、 t_2(x_1, \\cdots, x_n) 为所涉及的两个项，并且约定，无论是 t_1 还是 t_2 ，在项中出现的所有自变量都出自变量 x_1, \\cdots, x_n 中。那么这 n 个变量就可以彼此独立地在实数范围内取任何值。\n我们规定任何一个实数的 n -元组 (a_1, \\cdots, a_n) 就是上述 n 个变量的一组取值。我们称 (a_1, \\cdots, a_n) 为 x_1, \\cdots, x_n 的一组赋值或者解释。\n并且，我们规定，记号 t_1(a_1, \\cdots, a_2) 和 t_2(a_1, \\cdots, a_2) 分别用来标识由计算过程 t_i (i=1, 2) 以数据 (a_1, \\cdots, a_n) 为输入所计算出来的结果，并且称 t_i 在数据 (a_1, \\cdots, a_n) 处的赋值或者解释。\n在此基础上，我们称数值等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 为基本等式 t_1 = t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n类似的我们称数值不等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 为基本不等式 t_1 \u003c t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n现在，我们就规定：\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n量词与表达式 前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入量词。\n既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。\n比如说考虑基本等式 x = y 和基本不等式 x \u003c y ，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。\n我们将“存在”这个词作为一种量词引入数学，并且用符号 \\exists 来表征“存在”：\n\\begin{array}{l} (\\exists x (\\exists y (x = y))), \\\\ (\\exists x (\\exists y (x \u003c y))) \\end{array} 其中 \\exists x, \\exists y 就都被称为一个存在量词。一个存在量词由符号 \\exists 与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号 () 将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n又比如，考虑基本等式 x + y = y + x 和基本不等式 0 \u003c (x + y)^2 。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。\n我们将“对于所有”这个短语作为一个量词引入，并且用符号 \\forall 来表征这个短语：\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 其中， \\forall x, \\forall y 就都被称为一个全称量词。一个全称量词由符号 \\forall 和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号 () 将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。\n第一，每一个基本表达式都是一个表达式：\n\\begin{array}{l} (t_1 = t_2), \\quad (t_1 \u003c t_2) \\quad (\\text{为了规范起见，我们加上圆括号}) \\end{array} 第二，假设已经得到一个表达式，比如说这个表达式被记作 \\varphi ，那么这个表达式的否定式 (\\neg \\varphi) 也是一个表达式。\n第三，假设已经得到两个表达式，比如说它们被记为 \\varphi 和 \\psi ，那么\n(1) (\\varphi \\lor \\psi) 是一个表达式\n(2) (\\varphi \\land \\psi) 是一个表达式\n(3) (\\varphi \\to \\psi) 是一个表达式\n第四，假设已经得到一个表达式 \\varphi ， x 是一个变量符号，那么\n(1) (\\exists x \\varphi) 是一个表达式\n(2) (\\forall x \\varphi) 是一个表达式\n最后，除了以上的规定，没有获得新的表达式的可能途径。\n关于两个量词的否定，我们规定\n\\begin{array}{l} (\\neg (\\forall x \\varphi)) \\text{ 即为 } (\\exists x (\\neg \\varphi)) \\end{array} 以及\n\\begin{array}{l} (\\neg (\\exists x \\varphi)) \\text{ 即为 } (\\forall x (\\neg \\varphi)) \\end{array} 自由变元与约束变元 关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式 \\varphi 和一个变量符号 x ，假设这个 x 在表达式中出现若干次。\n如果 x 在某一处的出现不在任何存在量词或全称量词的作用范围内，就称 x 为 \\varphi 的一个自由变量。反之，则被称为约束变量。\n在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为语句。比如\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 就是一个语句。\n在应用中，我们常常会使用形如下述的受囿量词：\n\\begin{array}{l} \\forall x \\in A, \\quad \\exists x \\in A \\end{array} 这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围 A 之中，并且通常 A 就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如\n\\begin{array}{l} (\\forall x \\in A \\varphi(x)) \\end{array} 这个表达式实际上是\n\\begin{array}{l} \\forall x ((x \\in A) \\to \\varphi(x)) \\end{array} 同样的\n\\begin{array}{l} (\\exists x \\in A \\varphi(x)) \\iff \\exists x ((x \\in A) \\land \\varphi(x)) \\end{array} 更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。\n表达式语义解释与真假判定 仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。\n我们现在设 \\varphi(x_1, x_2, \\cdots, x_n) 是一个表达式，并且 \\varphi 中出现的任何的自由变元都来自 (x_1, x_2, \\cdots, x_n) 中，设 (a_1, a_2, \\cdots, a_n) 是实数的一个 n 元组。我们将 \\varphi 中出现的自由变元 x_i 进行赋值，使得自由变元 x_i 被相应的赋值为 a_i ，这时 \\varphi[a_1, a_2, \\cdots, a_n] 就是对 (a_1, a_2, \\cdots, a_n) 的性质描述，其中没有任何的需要特定赋值的自由变元。\n我们将根据表达式 \\varphi(x_1, x_2, \\cdots, x_n) 构造中可能存在的结构来规定如何判定\n\\varphi[a_1, a_2, \\cdots, a_n] 的真假。\n(1) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是一个基本表达式，那么 \\varphi[a_1, a_2, \\cdots, a_n] 的真假已经在前文被确定好了。\n(2) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是表达式 \\phi(x_1, x_2, \\cdots, x_n) 的否定式，即 \\varphi = (\\neg \\phi) 并且 \\phi[a_1, a_2, \\cdots, a_n] 的真假已经被确定，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为假\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为真\n(3) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是由两个表达式 \\psi_1(x_1, x_2, \\cdots, x_n) 和 \\psi_2(x_1, x_2, \\cdots, x_n) 通过联结词 \\lor 联结而成，即 \\varphi = (\\psi_1 \\lor \\psi_2) ，并且 \\psi_1[a_1, a_2, \\cdots, a_n] 和 \\psi_2[a_1, a_2, \\cdots, a_n] 的真假已经确定，那么\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(4) 把上述推导的联结词换成 \\land ，那么 (a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(5) 如果 \\varphi = (\\psi_1 \\to \\psi_2) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，但是 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(6) 如果 \\varphi = (\\forall y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为假\n(7) 如果 \\varphi = (\\exists y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为假\n当一个表达式在一组数据 (a_1, \\cdots, a_n) 下为真时，我们说这组数据满足表达式。反之则不满足。\n比如，下面这三句话在任何地方都是真语句，只要涉及到等号，下面三个语句就都为真。\n\\begin{array}{l} (\\forall x (x = x)) \\\\ (\\forall x (\\forall y ((x = y) \\to (y = x)))) \\\\ (\\forall x (\\forall y (\\forall z (((x = y) \\land (y = z)) \\to (x = z))))) \\end{array} 这三句话称为基本等号律，也称同一律。\n","cover":null,"tags":["代数学"],"title":"1.1  逻辑基础","url":"/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/"},{"content":"函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。\n若函数 f(t) 变成了另一个函数 f(t)\\longrightarrow \\tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \\delta f 被定义为\n\\delta f(t):=\\tilde{f(t)}-f(t)\\\\ 上式中的变分符号\u0026quot; \\delta \u0026quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \\delta f 是作为另一个函数存在的。\n函数的变分 \\delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变\nf(t)\\xrightarrow{t\\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\\cdots\\\\ 而函数的变分 \\delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关\nf(t)\\rightarrow\\tilde{f(t)}\\equiv(f+\\delta f)(t)=f(t)+\\delta f(t)\\\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如\n\\delta (f^n)=nf^{n-1}\\delta f\\\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有\n\\begin{align} \\delta(af_1+bf_2)=a\\delta f_1+b\\delta f_2\\\\ \\delta(f_1f_2)=(\\delta f_1)f_2+f_1(\\delta f_2) \\end{align}\\\\ 另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“\nd(\\delta f)=\\delta(df)\\\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B' 点的差，即\n\\tilde{f}(t+dt)-f(t)\\\\ 若先微分后变分(路径 A\\rightarrow B\\rightarrow B' ),精确到一阶小量有\n\\begin{align} C'B长度\u0026=f(t+dt)-f(t)=df(t)\\\\ BB'长度\u0026=\\tilde{f}(t+dt)-f(t+dt)\\\\ \u0026=\\delta(f(t+dt))\\\\ \u0026=\\delta(f(t)+df(t))\\\\ \u0026=\\delta(f(t))+\\delta(d(f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=df(t)+\\delta f(t)+\\delta (df(t))\\\\ 若先变分再微分(路径 A\\rightarrow A'\\rightarrow B ),精确到一阶小量有\n\\begin{align} AA'长度\u0026=\\tilde{f}(t)-f(t) \\\\\u0026=\\delta f(t)\\\\ A'C长度\u0026=\\tilde{f}(t+dt)-\\tilde{f}(t)\\\\ \u0026=d\\tilde{f}(t)\\\\ \u0026=d((f+\\delta f)(t))\\\\ \u0026=df(t)+d(\\delta f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=\\delta f(t)+df(t)+d(\\delta f(t))\\\\ 进而有，\nd(\\delta f)=\\delta(df)\\\\ 上式的直接推论即变分和求导运算也可以交换顺序，即是说\u0026quot;导数的变分\u0026quot;=\u0026ldquo;变分的导数\u0026rdquo;.\n\\frac{d}{dt}(\\delta f(t))=\\delta(\\frac{d}{dt}f(t))\\\\ 这里的关键在于，变分变化的是函数本身，而与自变量无关。\n","cover":null,"tags":["经典力学"],"title":"1.2 变分","url":"/notes/physcis/classical-mechnics/gaoxian/1.2/"},{"content":"我们首先来回顾一下函数的概念。\n一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：\n函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\\in X 和 y\\in Y 之间建立的一个对应关系即为映射。\nf:x\\rightarrow y=f(x) \\\\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。\n例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。\n上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。\n这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。\n至此，**\u0026ldquo;泛函\u0026rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\\cdots,f_n(x) ，所有这些函数自然也构成集合 \\mathcal{F}=\\{f_1,f_2,\\cdots,f_n\\} ,把函数 f 的泛函记为 s[f] ，即\nS:f\\longmapsto S=S[f],\\quad\\mathcal{F}\\longmapsto \\mathcal{C}\\\\ 其中， \\mathcal{C} 代表复数集合。\n泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。\n1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如\n平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函\nS(曲线长度)=S[f](曲线方程f的泛函)=\\int\\limits_{曲线}dx\\sqrt{1+(f'(x))^2}\\\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函\nW=W[p]=\\int\\limits_{过程}p(V)dV\\\\ 三维空间曲线方程记为 z=\\phi(x,y) ，则曲面面积 A 为二元函数 z=\\phi(x,y) 的泛函\nA=A[\\phi]=\\iint_{\\text {区域 }} \\mathrm{d} x \\mathrm{~d} y \\sqrt{1+\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial \\phi}{\\partial y}\\right)^{2}} \\\\ 经典力学中的遇见的泛函，通常为以下形式\nS[f]=\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right)\\\\ 此处的被积函数 L=L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 是函数 f(t) 及其导数的一般函数。\n可以再次看到，泛函的结果或者说输出 s[f] 是一个数，但是 s[f] 描述的对象是函数的函数，也就是函数所遵循的具体的对应关系，在上式中，它是 f(t) 遵循 \\int\\limits_{t_1}^{t_2} dtL\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 。\n我们称数 s[f] 是 f 的泛函，其实是\u0026quot; s[f] 所描述的函数的函数是函数 f 的泛函\u0026quot;的简洁说法，因为 s[f] 的结果是数，所以简称数 s[f] 是 f 的泛函。\n","cover":null,"tags":["经典力学"],"title":"1.1 泛函","url":"/notes/physcis/classical-mechnics/gaoxian/1.1/"},{"content":"1.Markdown 语法 元素 Markdown 语法 标题 (Heading) # H1 ## H2 ### H3 粗体 (Bold) bold text 斜体 (Italic) italicized text 引用块 (Blockquote) \u0026gt; blockquote 有序列表 (Ordered List) 1. First item 2. Second item 3. Third item 无序列表 (Unordered List) - First item - Second item - Third item 代码 (Code) code 分隔线 (Horizontal Rule) \u0026mdash; 链接 (Link) title 一级列表项 1 二级列表项 1.1 三级列表项 1.1.1 二级列表项 1.2 一级列表项 2 元素 Markdown 语法 表格 (Table) | Syntax | Description | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | Header | Title | | Paragraph | Text | 代码块 (Fenced Code Block) \u0026lt;br\u0026gt; { \u0026lt;br\u0026gt; \u0026quot;firstName\u0026quot;: \u0026quot;John\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;lastName\u0026quot;: \u0026quot;Smith\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;age\u0026quot;: 25 \u0026lt;br\u0026gt; } \u0026lt;br\u0026gt; 脚注 (Footnote) Here\u0026rsquo;s a sentence with a footnote. [^1] [^1]: This is the footnote. 标题编号 (Heading ID) ### My Great Heading {#custom-id} 定义列表 (Definition List) term : definition 删除线 (Strikethrough) The world is flat. 任务列表 (Task List) - [x] Write the press release - [ ] Update the website - [ ] Contact the media 以上内容来自 Markdown 语法官方中文教程\n2.LaTex渲染测试 S[x^A(t)]=\\int dtL(x^A(t),\\dot{x}^A(t))\\tag{1.0} Equation d \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over B} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\times \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over r} }}{{{r^3}}} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\sin \\theta }}{{{r^2}}} ","cover":"https://chiara-lee.netlify.app/notes/test-page/cover_hud9949164f33296b940c3365d1d09af90_3836494_100x100_resize_q75_box.jpg","tags":null,"title":"测试专用页","url":"/notes/test-page/"},{"content":"1.关于这个网站的用途： 本网站为个人博客网站。主要的用途有三个部分：\n读书笔记的记录。 学习过程中的思考记录 资源的合法分享 由于本人能力不足，无法做到在教材的基础之上进行创新的讲述，因此，读书笔记的内容可能会与原文存在很大重合。 但为了保证对原教材的权益保护。本网站绝不会进行任何的盈利活动，读书笔记的分享也仅出于个人的记录需要和学习的分享需要。 如果您发现网站有任何事实不正确、侵犯版权或任何其他问题，请联系我，我会按照您的要求进行删改。对于任何此类错误，我提前表示歉意。\n2.关于这个网站的目的： 由于一些特殊的原因，我没有在学校进行学习。我所有的学习资源和途径均来自于互联网上秉持着开源精神的伟大的人们。\n为此，我也希望对互联网进行力所能及的微小回馈。我将在这个网站分享我所有的读书笔记，希望我的资料可以帮助到对相关领域同样感兴趣的朋友们。另外，欢迎您通过网站内所提供的任何途径联系我，希望我们之间可能存在的沟通能够为您带来一些帮助。\n3.关于本人的联系方式 您可以通过邮箱和知乎联系我：\nQQ mail: chiaralee953@foxmail.com Zhihu：Chiara Lee 最后，希望您在我的网站玩的愉快。请尽情的享受探索知识的乐趣吧。\nChiara Lee Chiara Lee\n以理性审视世界，凭理想创造世界。\n社交网络\nTwitter ZhiHu @Chiara-Lee Github @Chiara-Lee ","cover":null,"tags":null,"title":"关于","url":"/about/"},{"content":"","cover":null,"tags":null,"title":"友人帐","url":"/friends/"}]