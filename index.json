[{"content":"在上一节中，我们已经证明了所知道的所有关于加法和序的基本事实。为了节省篇幅以及避免赘述那些显然的事情，接下来我们将允许使用所熟悉的关于加法和序的代数法则，而不加进一步的说明。于是我们可以写出 a+b+c=c+b+a 这样的内容，不需要进一步解释说明。现在我们引入乘法。正如加法是重复的增量运算一样，乘法是重复的加法运算。\n定义 2.3.1（自然数的乘法）\n令 m 表示任意一个自然数，\n我们定义 0\\times m:= 0 来表示将 0 乘到 m 上。现在归纳假设我们已经定义了 n\\times m （即把 n 乘到 m 上）。\n那么，我们可以定义\n(n++)\\times m:= (n\\times m)+m 以上，我们就定义好了自然数的乘法规则。\n引理 2.3.2 （乘法是可交换的） 令 n 和 m 表示任意两个自然数，那么有 n\\times m=m\\times n 成立。\n证明： 使用数学归纳法。\n首先我们需要证明 m\\times 0= 0 。当 m=0 时，我们有\n0\\times 0:= 0 归纳假设当 m=m 时 m\\times 0= 0 是成立的，那么现在我们来证明 m=m++ 时等式成立。\n\\begin{align} (m++)\\times 0\u0026=(m\\times 0)+0[(n++)\\times m:= (n\\times m)+m]\\\\ \u0026=0 \\end{align} 以上，我们就得到了基础情况 0\\times m=m\\times 0 。\n接下来，我们需要证明\nn\\times (m++)=(n\\times m)+n 当 n=0 时， 0\\times (m++)=0=0\\times m+0 （第一个等号来源于定义，第二个等号是为了交换形式而拼凑出来的）。假设当 n=n 时结论已经成立，即有 n\\times (m++)=(n\\times m)+n ，需证 (n++)\\times (m++)=(n++)\\times m+(n++) \\begin{align} (n++)\\times (m++)\u0026=[n\\times(m++)]+(m++)\\\\ \u0026=n\\times m+n+(m++)\\\\ \u0026=n\\times m+m+(n++)\\\\ \u0026=(n++)\\times m+(n++) \\end{align} 其中第三个等号是因为\n\\begin{align} \u0026n+(m++)=n+(m+1)\\\\ \u0026(n++)+m=(n+1)+m\\\\ \u0026n+(m+1)=(n+1)+m\\\\ \u0026n+(m++)=(n++)+m \\end{align} 综上,引理得证。\n我们将把 n\\times m 简写为 nm ，而且按照惯例，乘法运算优先于加法运算。\n引理 2.3.3（正自然数没有零因子） 令 n 和 m 表示任意两个自然数，那么 n\\times m=0 当且仅当 n 和 m 中至少有一个为 0 .\n证明： 设 n、m 均为正自然数，并且满足 n=c++、m=d++ ，其中 c、d 均为自然数。\n\\begin{aligned} \u0026 (n \\text { is positive }) \\wedge(m \\text { is positive }) \\\\ \\Rightarrow \u0026 \\exists c, d \\in N, c++=n, d++=m \\\\ \\Rightarrow \u0026 n m=(c++) \\times(d++)=c \\times(d++)+(d++)=(c \\times(d++)+d)++ \\\\ \\Rightarrow \u0026 n m \\text { is positive } \\end{aligned} 命题 2.3.4（分配律）\n对于任意自然数 a,b,c \\begin{align} \u0026a(b+c)=ab+ac\\\\ \u0026(b+c)a=ba+ca \\end{align} 均成立\n证明： 由于乘法是可交换的，因此只需要证明第一个等式 a(b+c)=ab+ac 成立即可。\n对 c 进行数学归纳。当 c=0 时，\n\\begin{align} \u0026a(b+0)=ab\\\\ \u0026ab+a0=ab\\\\ \u0026a(b+0)=ab+a0 \\end{align} 现在我们归纳性地假设 a(b+c)=ab+ac 成立，接下来要证明的是 a(b+(c++))=ab+a(c++) 。\n\\begin{align} \u0026a(b+(c++))=a[(b+c)++]\\\\ \u0026a[(b+c)++]=a(b+c)+a\\\\ \u0026ab+a(c++)=ab+ac+a \\end{align} 根据 a(b+c)=ab+ac ，因此可知 c++ 的情况亦成立。，那么到这里归纳过程就结束了。\n命题 2.3.5（乘法是可结合的）\n对于任意自然数 a,b,c (a\\times b)\\times c=a\\times(b\\times c) 均成立。\n证明：\n对 b 进行数学归纳 : 对于 0: (a \\times 0) \\times c=0 \\times c=0=a 0=a(0 \\times c) 如果 b 是正确的，即 (a\\times b)\\times c=a\\times(b\\times c) , 那么\n\\begin{array}{l} (a(b++)) c=(a b+a) c=(a b) c+a c \\\\ =a(b c)+a c=a(b c+c)=a((b++) c) \\end{array} 命题 2.3.6（乘法保持序不变）\n如果 a,b 是满足 a","cover":null,"tags":["数学分析"],"title":"2.3  乘法","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.3/"},{"content":"定义 3.1.1（非正式的）（集合）\n我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \\{3,8,5,2\\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\\in A ，否则，记作 x\\notin A 。\n这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。\n首先阐明一个观点：我们把集合本身看作一类对象。\n公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。\n到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \\in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \\in A 是无定义的。例如， 3 \\in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。）\n接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合 \\{3, 8, 5, 2\\} 与 \\{2, 3, 5, 8\\} 看作同一个集合。另外， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5, 2, 1\\} 是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素 1 。基于类似的原因， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5\\} 也是不同的集合。我们把这部分内容作为一个定义。\n定义 3.1.4（集合的相等） 称两个集合 A 和 B 是相等的，即 A = B ，当且仅当 A 中的每个元素都是 B 中的元素并且 B 中的每一个元素也都是 A 中的元素。也就是说， A = B ，当且仅当 A 中的任一元素 x 属于 B ，同时 B 中的任一元素 y 也属于 A ，这记为 (\\forall x \\in A, x \\in B),(\\forall y \\in B, y \\in A) 相等是如何定义的取决于所考察对象的类型，而且从某种程度上来说，这只不过是一个关于下定义的问题而已。然而，从逻辑学的角度来说，我们要求相等遵守下面四条 相等公理 ：\n（自反公理） 给定任意的对象 x ，我们有 x = x 。 （对称公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么 y = x 。 （传递公理） 给定任意三个同类型的对象 x 、 y 和 z ，若 x = y 且 y = z ，则 x = z 。 （替换公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么对任意一个函数或者运算 f 都有 f(x) = f(y) 。类似地，对任意一个关于 x 的性质 P(x) ，如果 x = y ，那么 P(x) 和 P(y) 就是等价的命题。 容易验证，定义3.1.4满足自反、对称、传递三个性质。\n自反性（Reflexive）: (\\forall x \\in A, x \\in A) \\Rightarrow A = A 对称性（Symmetric）: (A = B) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in A) \\Rightarrow B = A 传递性（Transitive）: (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in C) \\Rightarrow (\\forall x \\in A, x \\in C) (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in B, x \\in A) \\land (\\forall x \\in C, x \\in B) \\Rightarrow (\\forall x \\in C, x \\in A) \\text{以上两种情况同时成立，这意味着 } A = C 根据定义 3.1.4 观察可知，如果 x \\in A 并且 A = B ，那么 x \\in B 。于是 “是……的元素” 这种 \\in 关系遵守替换公理。正因如此，只要我们能够把定义在集合上的新运算仅用 \\in 的语言来描述，这个新运算就会遵守替换公理。例如，对于本节中剩下的定义，情况就是这样。（另外，在良好的定义方式中，我们不能使用集合中 “第一个” 或者 “最后一个” 元素这样的概念，因为这将违背替换公理。例如，虽然集合 \\{1, 2, 3, 4, 5\\} 与 \\{3, 4, 2, 1, 5\\} 表示同一个集合，但是它们的第一个元素是不一样的。）\n","cover":null,"tags":["数学分析"],"title":"3.1  基础知识","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/"},{"content":"1.3.1 泛函导数的概念 对于普通函数的导数，函数的微分是由自变量的微分引起的：\n\\begin{align} f(t) \\xrightarrow{t \\to t+\\epsilon} f(\\tilde{t}) \u0026= f(t+ \\epsilon) \\\\ \u0026= f(t) + \\epsilon df(t) + \\frac{\\epsilon^2}{2!} d^2 f(t) + \\frac{\\epsilon^3}{3!} d^3 f(t) + \\cdots \\end{align} 其中 \\epsilon 是无穷小参数， \\epsilon^n 项即为函数的 n 阶微分，函数的 n 阶导数则由函数的 n 阶微分与 dt 的关系给出。对于一阶导数：\ndf(t) = \\frac{df(t)}{dt} dt 高阶导数则为：\nd^{(n)} f(t) = \\frac{d^{(n)}f(t)}{dt^n} dt 只要计算出函数的各阶微分，就可以给出相应的各阶导数。\n泛函导数从形式上完全是对普通函数导数的类比。对于泛函 S[f] ，其变分是由函数的变分引起的：\n\\begin{align} S[f] \\xrightarrow{f \\to \\tilde{f}} S[\\tilde{f}] \u0026= S[f + \\epsilon f] \\\\ \u0026= S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots \\end{align} 这里 \\epsilon^n 项即被称为是泛函的 n 阶变分 \\delta^n S[f] 。仿照函数的 n 阶导数即可定义 n 阶泛函导数。\n定义 1 阶泛函导数\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 其中：\n\\delta f(t) = \\tilde{f}(t) - f(t) 这里 \\delta S 是泛函的一阶变分， \\frac{\\delta S}{\\delta f(t)} 即为一阶泛函导数（the first order functional derivative）。可以看出，一阶泛函导数的作用，是将函数的变分 \\delta f(t) （无穷小函数）映射到泛函的一阶变分 \\delta S （无穷小的数）。这也解释了为什么定义式中出了 dt 的积分。\n为了更好的理解泛函导数，可以将泛函与多元函数进行类比，例如：\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 可以和多元函数 F = F(x_1, x_2, \\cdots, x_n) 的一阶微分\ndF = \\sum_n \\frac{\\partial F}{\\partial x_n} dx_n 相类比。\n类比函数的高阶导数，高阶泛函导数定义为：\n\\delta^2 S[f] := \\int dt_1 \\int dt_2 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} \\delta f(t_1) \\delta f(t_2) \\delta^3 S[f] := \\int dt_1 \\int dt_2 \\int dt_3 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} \\delta f(t_1) \\delta f(t_2) \\delta f(t_3) 这里的 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} 和 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} 即分别代表 S[f] 对 f 的二阶泛函导数和三阶泛函导数。\n例如，二阶泛函导数的作用，是将函数的变分 \\delta f(t) 映射为泛函的二阶变分 \\delta^2 S （二阶无穷小数）。在经典力学中，我们大多只关注一阶泛函导数。\n","cover":null,"tags":["经典力学"],"title":"1.3 泛函导数","url":"/notes/physcis/classical-mechnics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3/"},{"content":"1.3.2 泛函导数的操作定义 根据上面的讨论，泛函导数归结于计算泛函 S[f] 的变分。\n换个角度，在泛函 S[f + \\epsilon \\delta f] 中， \\epsilon 是一个参数，而泛函 S 是一个数，其值依赖于 \\epsilon 。所以，泛函 S[f + \\epsilon \\delta f] 可以被看作是 \\epsilon 的普通函数，于是公式：\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots 可以视为 S[f + \\epsilon \\delta f] 相对于 \\epsilon 的普通泰勒展开。\n一般函数在 x_0 处以及 x_0 = 0 的泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^2 + R_n R_n=o[(x-x_0)^n] f(x) = f(0) + \\frac{f'(0)}{1!}(x) + \\frac{f''(0)}{2!}(x)^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}(x)^2 + R_n R_n=o[(x)^n] 通过比较\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots S[f + \\epsilon \\delta f] = S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots 即可得到一阶泛函导数的形式：\n\\delta S=\\left.\\frac{d}{d\\epsilon}S[f+\\epsilon \\delta f]\\right|_{\\epsilon=0}=\\int\\limits dt\\frac{\\delta S}{\\delta f(t)}\\delta f(t) \\delta S^2=\\left.\\frac{d^2}{d\\epsilon^2}S[f+\\epsilon\\delta f]\\right|_{\\epsilon=0}=\\int dt_1\\int dt_2\\frac{\\delta ^2S}{\\delta f(t_1)\\delta f(t_2)}\\delta f(t_1)\\delta f(t_2) 高阶泛函导数的形式可以类似的写出。\n对于下述形式的泛函\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots) 可以联系一阶泛函导数的形式可以得到\n\\begin{align} \\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026\\text{其中} f+\\epsilon\\delta f \\text{是关于} \\epsilon \\text{的函数} f(\\epsilon)，f' \\text{同理}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align} 上式的被积函数就是 L 的一阶变分 \\delta L ，与其微分形式 dL 全同。只是微分换成了变分。\n这意味着\n\\delta S\\equiv\\delta(\\int\\limits_{t_1}^{t_2}dtL)=\\int\\limits_{t_1}^{t_2}dt\\delta L 即是说，变分符号可以移到积分内。\n观察一阶泛函导数的形式\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f 右边只出现了函数的变分 \\delta f 。但是在\n\\begin{align} \\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align}\\\\ 中却出现了函数的导数的变分 \\delta f',\\delta f'',\\cdots ，在处理这个情况时，我们就需要使用变分法中非常重要的技巧——分部积分（integration by parts）。\n分部积分的基本思路是：利用变分和求导可以交换顺序的性质，将作用于 \\delta f 的导数移除，代价是产生额外的“全导数”项，然后设定全导数为边界项，并且忽略边界项，使得泛函的变分式中各项的共有项为 \\delta f ，提出 \\delta f 后即得一阶泛函导数。\n例如，对于正比于 \\delta f' 的项。\n\\frac{\\partial L}{\\partial f'}\\delta f'\\xlongequal{\\text{变分与求导交换顺序}}\\frac{\\partial L}{\\partial f'}\\frac{d}{dt}\\delta f=\\underbrace{\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'}\\delta f)}_{\\text{全导数}}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f 第二个等号是因为\n\\begin{align} \u0026(uv)'=u'v+uv'\\\\ \u0026uv'=(uv)'-u'v \\end{align} 类似的，\n\\begin{align} \\frac{\\partial L}{\\partial f''}\\delta f''\u0026=\\frac{\\partial L}{\\partial f''}\\frac{d^2}{dt^2}\\delta f={\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''}\\frac{d}{dt}\\delta f)}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\frac{d}{dt}\\delta f\\\\ \u0026=\\underbrace{\\frac{d}{dt}\\bigg(\\frac{\\partial L}{\\partial f''}\\delta f'-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\delta f\\bigg)}_{\\text{全导数}}+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f \\end{align} 由此类推，有\n\\begin{align} \\delta S\u0026=\\int\\limits_{t_1}^{t_2}dt\\bigg[\\frac{\\partial L}{\\partial f}\\delta f-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f+\\cdots+\\frac{d\\mathcal{B}}{dt}\\bigg]\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt[\\frac{\\partial L}{\\partial f}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})+\\cdots]\\delta f+\\left.\\mathcal{B}\\right|_{t_1}^{t_2} \\end{align} 这里 \\frac{d\\mathcal{B}}{dt} 代表全导数项。积分后得到的 \\left.\\mathcal{B}\\right|_{t_1}^{t_2} 被称为边界项（boundary term）,在积分的端点（边界）处取值。对比\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f \\delta S 在上式中的积分已经具有泛函导数的形式，主要的阻碍来自于边界项。由上面的推导可知，如果泛函的被积函数 L 包含 f(t) 的最高 n 阶导数，则边界项 \\mathcal{B} 就包含 \\delta f(t) 的最高 n-1 阶导数。\n因此，变分法的一个基本假设就是： 如果泛函的被积函数包含函数的最高 n 阶导数，那么在积分的边界处，函数及其直到 n-1 阶导数的变分为零。 即\n\\left.\\delta f\\right|_{t_1}=\\left.\\delta f\\right|_{t_2}=0 \\left.\\delta f'\\right|_{t_1}=\\left.\\delta f'\\right|_{t_2}=0 \\vdots \\left.\\delta f^{(n-1)}\\right|_{t_1}=\\left.\\delta f^{(n-1)}\\right|_{t_2}=0 在这样的假设下，边界项 \\left.\\mathcal{B}\\right|_{t_1}=\\left.\\mathcal{B}\\right|_{t_2}=0 恒为零。这也意味着，被积函数可以加上函数 f(t) 及其直到 n-1 阶导数的任意函数 F=F(t,f,f',\\cdots,f^{(n-1)}) 的全导数，而不影响泛函导数。\n两个被积函数相差全导数，或者两个积分相差边界项，这件事在变分法中非常重要。因此通常使用专门的符号\u0026quot; \\simeq \u0026quot;来表示：\nL_1\\simeq L_2\\Leftrightarrow L_1=L_2+\\frac{dF(t,f,f',\\cdots)}{dt} 之所以全导数项是 \\frac{dF(t,f,f',\\cdots)}{dt} 是因为上文中的所有函数 f(t) 都是关于 t 的函数，而所有的泛函 s[f+\\epsilon \\delta f] ，则可被视为是 \\epsilon 的函数。\n以及\nS_1\\simeq S_2\\Leftrightarrow S_1=S_2+\\left.L\\right|_{t_1}^{t_2} 基于以上假设，对于泛函导数的计算来说，边界项不重要。在实际计算中，都是直接丢掉边界项，而无需写出其具体形式的。例如\n\\frac{\\partial L}{\\partial f^{\\prime}} \\delta f^{\\prime} \\simeq-\\frac{\\mathrm{d}}{\\mathrm{d} t}\\left(\\frac{\\partial L}{\\partial f^{\\prime}}\\right) \\delta f, \\quad \\frac{\\partial L}{\\partial f^{\\prime \\prime}} \\delta f^{\\prime \\prime} \\simeq \\frac{\\mathrm{d}^{2}}{\\mathrm{d} t^{2}}\\left(\\frac{\\partial L}{\\partial f^{\\prime \\prime}}\\right) \\delta f 基于同样的理由，泛函积分的上下限也经常被省略，即\nS=\\int\\limits dtL 1.3.3 计算一阶泛函的标准手续 变分原理是整个分析力学的第一原理，而变分法的核心就是计算一阶泛函导数。\n对于\nS[f] = \\int_{t_1}^{t_2} dt L(t, f(t), f'(t), \\cdots) 这种形式的泛函，可以总结一下关于一阶泛函导数的计算手续。\n(1) 将变分符号 “ \\delta ” 移到积分号内\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\delta L(t, f(t), f'(t), \\cdots) (2) 按照类似复合函数求导的规则来计算 \\delta L \\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right) 这里变分和微分的形式全同，只是微分被换成了变分。\n(3) 做分部积分，将 \\delta f 的导数移除，这是计算一阶泛函导数的最关键的一步。 在实际操作中，只需要不断地将 \\delta f 的导数移除，并不需要关注全导数项的具体形式。\n(4) 提取 \\delta f 前的系数，即为一阶泛函导数。\n根据以上的手续，经过分部积分，式子\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right) 成为\n\\delta S \\simeq \\int_{t_1}^{t_2} dt \\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots \\right] \\delta f 从中得到一阶泛函导数\n\\boxed{\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots} 需要强调的是，虽然上式在形式上绝对正确， 但是最好不要将偏导数 \\frac{\\partial L}{\\partial f} 、 \\frac{\\partial L}{\\partial f'} 、 \\frac{\\partial L}{\\partial f''} ……先计算出来再代入式子中，而应该按照上面的“变分—分部积分”操作步骤。\n例 1.1 一阶泛函导数\n考虑泛函 S[f] = \\int dt \\left[ (f'(t))^2 - (f(t))^2 \\right] ，有\n\\begin{align} \\delta S[f] \u0026= \\int dt \\, \\delta \\left( f'^2 - f^2 \\right) \\\\ \u0026= \\int dt \\left( 2 f' \\delta f' - 2 f \\delta f \\right) \\\\ \u0026= \\int dt \\left( 2 f' \\delta f' \\right) - \\int dt \\left( 2 f \\delta f \\right) \\\\ \\int dt \\, f' \\delta f' \u0026= \\left[ f' \\delta f \\right] - \\int dt \\, f'' \\delta f \\\\ \\Rightarrow\\int dt \\, f' \\delta f' \u0026= - \\int dt \\, f'' \\delta f \\\\ \\delta S[f] \u0026= - \\int dt \\, 2 f'' \\delta f - \\int dt \\, 2 f \\delta f \\\\ \\delta S[f] \u0026\\approx \\int dt \\left( - 2 f'' - 2 f \\right) \\delta f(t) \\end{align} 因此一阶泛函导数为\n\\frac{\\delta S}{\\delta f(t)} = -2 f''(t) - 2 f(t). 例 1.2 一阶泛函导数与全导数\n考虑泛函 S[f] = \\int dt \\left[ f(t) f'(t) + f'(t) f''(t) \\right] ，有\n\\begin{align} \\delta S[f] \u0026= \\int dt \\, \\delta \\left( f f' + f' f'' \\right) \\\\ \u0026= \\int dt \\left( \\delta f f' + f \\delta f' + \\delta f' f'' + f' \\delta f'' \\right) \\\\ \u0026= \\int dt \\left( \\delta f f' \\right) + \\int dt \\left( f \\delta f' \\right) + \\int dt \\left( \\delta f' f'' \\right) + \\int dt \\left( f' \\delta f'' \\right) \\\\ \\end{align} \\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f \\int dt \\, \\delta f' f'' = \\left[ \\delta f' f' \\right] - \\int dt \\, f' \\delta f'' = - \\int dt \\, f' \\delta f'' \\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f \\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f 最终 \\begin{align} \\delta S[f] \u0026= \\int dt \\left( f' \\delta f - f' \\delta f - f''' \\delta f + f''' \\delta f \\right) \\\\ \u0026= 0 \\end{align} 其中，在此例的推导过程中，第一项\n\\int dt \\delta f f' 这一项可以选择直接处理，不需要分部积分，主要是因为 \\delta f 只是一个变分项，而 f' 是一个普通的导数函数，这里没有更高阶的导数存在，所以我们没有对其进行分部积分。\n第二项\n\\int dt f\\delta f' 这一项需要分部积分，目的是将 \\delta f' 变分项中的导数和变分分离开来，通过分部积分后得到\n\\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f 这里我们将 \\delta 和 f' 分离，避免处理变分的导数项。同时丢弃了边界项。 \\left[ f \\delta f \\right] 。\n基于同样的理由，第三项和第四项都进行了分部积分丢弃全导数项的过程。因此一阶泛函导数为零。\n在这个例子中，出现了泛函导数为零的情况。实际上，观察泛函中的被积函数， f f' + f' f'' = \\frac{d}{dt} \\left( \\frac{1}{2} f^2 + \\frac{1}{2} f'^2 \\right) \\equiv \\frac{dF}{dt} ，其自身就是个全导数。而根据上面的讨论，被积函数中的全导数可以自然舍去，所以 f f' + f' f'' \\approx 0 ，难怪其对应的泛函导数为零了。\n","cover":null,"tags":["经典力学"],"title":"1.3.2 泛函导数的操作定义","url":"/notes/physcis/classical-mechnics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3.2/"},{"content":"目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。\n具体做法如下：\n5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。\n定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：\n0+m:=m 现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为\n(n++)+m:=(n+m)++ 于是， 0+m 就是 m， 1+m 就是 (0++)+m=(0+m)++=m++ ， 2+m 就是 (1++)+m=(1+m)++=(m++)++ ，以此类推。例如：\n2+m=(1++)+m=(1+m)++=(m++)++\\\\ 2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\\\ 根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。\n现在，我们将之前一般化的讨论特殊化为， a_n=n+m 和 f_n(a_n)=a_n++ 的情景。\n注意：我们以上定义的自然数加法是不对称的： 3+5 表明将 3 增长了 5 次，而 5+3 表明将 5 增加了 3 次。不过，它们生成的值是一样的。更一般，对于任意自然数 m、n。有\nm+n=n+m 均成立。（我们将稍后给出其证明）\n引理 2.2.2 对任意自然数 n， n+0=n 恒成立。\n注意，我们的定义是 0+m:=m ，由于我们尚未证明 m+n=n+m 对于任意自然数 n、m 均成立，因此我们不可以直接通过交换律得到 n+0=n 。\n证明:\n采用归纳法来证明。因为 0 + m = m 对任意自然数 m 均成立并且 0 是一个自然数，所以我们能得到最基本的情况 0 + 0 = 0 。\n现在归纳性地假设 n + 0 = n 成立。我们希望证明 (n++) + 0 = n++ 。\n根据加法的定义， (n++) + 0 = (n + 0)++ ；\n又根据 n + 0 = n 可以推导出 (n + 0)++ = n++ 。\n至此整个归纳过程就结束了。 \\Box 引理 2.2.3 对任意的自然数 n 和 m ，有\nn + (m++) = (n + m)++ 成立。\n同样，因为目前我们还不知道有 a + b = b + a ，所以不能从 (n++) + m = (n + m)++ 中推导出本结论。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先考虑最基本的情况， n = 0 。此时我们必须证明\n0 + (m++) = (0 + m)++ 根据加法定义，左侧等于 m++ ，再次根据加法定义，显然右侧也为 m++ ，因此等式成立。\n现在归纳性地假定 n + (m++) = (n + m)++ 成立，那么我们必须证明\n(n++) + (m++) = ((n++) + m)++ 根据加法的定义，上式左端等于 (n + (m++))++ 又由归纳假设可得 (n+(m++))++ = ((n + m)++)++ 。 类似地，根据加法的定义可得， (n++) + m = (n + m)++ ，从而等式的右端也等于 ((n + m)++)++ 。\n因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。 \\Box 作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到\nn++ = n + 1。 因为 n+1=n+(0++)=(n+0)++=n++ 。\n如之前承诺的，现在，我们来证明 a + b = b + a 。\n命题 2.2.4 （加法是可交换的）\n对任意的自然数 n 和 m ，有\nn + m = m + n 成立。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先证明当 n = 0 时结论成立，也就是说证明 0 + m = m + 0 。\n一方面，根据加法的定义可以推出 0 + m = m ；\n另一方面，根据引理 2.2.2 可得 m + 0 = m 。\n于是 n = 0 时结论成立。\n现在归纳性地假设 n + m = m + n 成立，那么我们要证明\n(n++) + m = m + (n++) 来完成归纳。\n根据加法的定义， (n++) + m = (n + m)++ ；\n根据引理 2.2.3， m + (n++) = (m + n)++ ；\n但由归纳假设 n + m = m + n 可知 (m + n)++ = (n + m)++ 。\n因此 (n++) + m = m + (n++) ，进而归纳过程结束。 \\Box 命题 2.2.5 （加法是可结合的）\n对任意三个自然数 a 、 b 、 c ，有\n(a + b) + c = a + (b + c) 成立。\n证明:\n固定 a, c \\in N , 对 b 进行归纳讨论.\n设定当 b = 0 :\n(a + 0) + c = a + c = a + (c + 0) = a + (0 + c) 现在归纳假设 b=n 时命题成立, 需要证明 b=n++ 时命题成立:\n\\begin{align} (a + (n++)) + c \u0026= ((a + n)++) + c \\\\ \u0026= c + ((a + n)++) \\\\ \u0026= (c + a + n)++ \\\\ \u0026= ((a + n) + c)++ \\\\ \u0026= (a + (n + c))++ \\\\ \u0026= a + (n + c)++ \\\\ \u0026= a + ((n++) + c) \\end{align} 根据数学归纳法，命题对所有自然数均成立。\n正是因为有了这条结合律，我们可以把 a, b, c 的和写成 a + b + c 的形式，而无需顾虑它们是按照什么样的次序加起来的。\n下面，我们给出消去律。\n命题 2.2.6 （消去律）\n令 a, b, c 为任意三个自然数并且满足\na + b = a + c, 那么 b = c 成立。\n注意:\n由于目前我们还没有给出减法和负数的概念，所以这里不能利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及了一种“虚拟减法”。\n证明:\n我们通过对 a 进行归纳来证明该命题。\n首先考虑最基本的情况 a = 0 ，我们有\n0 + b = 0 + c, 那么根据加法的定义，由 0 + b = 0 + c 可以得到 b = c ，故命题成立。\n现在归纳性假设关于 a 的消去律成立（进而从 a + b = a + c 中可以得到 b = c ），接下来我们要证明关于 a++ 的消去律也成立。换言之，就是在假设\n(a++) + b = (a++) + c 成立时，去证明 b = c 成立。根据加法的定义，我们有\n(a++) + b = (a + b)++ 和\n(a++) + c = (a + c)++, 从而可以得到\n(a + b)++ = (a + c)++. 根据公理 2.4（任意两个不同的自然数的后继也是不同的），我们进一步得到\na + b = a + c. 显然上式为待证情况的充要条件。因为我们已知关于 a 的消去律成立，所以有 b = c 成立，结论得证。至此归纳法结束。\n\\Box 现在我们讨论加法与正性是如何相互作用的。\n定义 2.2.7 （正自然数） 称一个自然数 n 是正的，当且仅当它不等于 0 。\n命题 2.2.8 如果 a 是正的并且 b 是自然数，那么 a + b 是正的（从而根据命题2.2.4可知， b + a 也是正的）。\n证明： 我们通过对 b 进行归纳来证明该命题。如果 b = 0 ，那么\na + b = a + 0 = a 显然是正的，从而 b = 0 时的结论得证。\n现在归纳性地假设 a + b 是正的。那么根据公理 2.3 (0 不是任何自然数的后继)可知，\na + (b++) = (a + b)++ 不等于零，从而 a + (b++) 是正的。至此归纳法结束。\n\\Box 推论 2.2.9\n如果 a 和 b 是自然数并且满足 a + b = 0 ，那么 a = 0 且 b = 0 。\n证明：\n假设结论的反面 a \\neq 0 或 b \\neq 0 成立。如果 a \\neq 0 ，那么 a 是正的，从而根据 命题 2.2.8 可知， a + b 是正的，这显然与已知条件 a + b = 0 相矛盾。类似地，如果 b \\neq 0 ，那么 b 是正的，同样根据 命题 2.2.8 可知， a + b 是正的，这与 a + b = 0 相矛盾。于是 a 和 b 必须同时为 0 。□\n引理 2.2.10 令 a 表示一个正自然数，那么恰存在一个自然数 b 使得 b++ = a 。\n证明： 根据皮亚诺公理 3 （0 不是任何自然数的后继）和 4（不同自然数的后继互不相同）有 \\forall m, n \\in \\mathbb{N}, S(m) = S(n) \\implies m = n. 则， \\begin{align} \u0026S(b)=a\\\\ \u0026\\forall n \\in \\mathbb{N},\\text{if} S(n)=S(b)=a \\implies n = b. \\end{align} 至此命题成立。\n定义 2.2.11 （自然数的序）\n令 n 和 m 表示任意两个自然数。我们称 n 大于等于 m ，并且记作 n \\geq m 或者 m \\leq n ，当且仅当存在自然数 a 使得 n = m + a 。我们称 n 大于 m ，并且记作 n \u003e m 或者 m \u003c n ，当且仅当 n \\geq m 且 n \\neq m 。\n于是，例如由于 8 = 5 + 3 并且 8 \\neq 5 ，所以 8 \u003e 5 。另外注意，对任意的 n 均有 n++ \u003e n ；因此不存在最大的自然数 n ，这是因为下一个数 n++ 总是更大。\n命题 2.2.12 （自然数的序的基本性质）\n令 a, b, c 为任意自然数，那么：\n(a) （序是自反的） a \\geq a 。\n(b) （序是可传递的）如果 a \\geq b 并且 b \\geq c ，那么 a \\geq c 。\n(c) （序是反对称的）如果 a \\geq b 并且 b \\geq a ，那么 a = b 。 (d) （加法保持序不变） a \\geq b ，当且仅当 a + c \\geq b + c 。\n(e) a \u003c b ，当且仅当 a++ \\leq b 。\n(f) a \u003c b ，当且仅当存在正自然数 d 使得 b = a + d 。\n证明:\n(a) a \\geq a a + 0 = a \\rightarrow a \\geq a (b) a \\geq b,b \\geq c ，那么 a \\geq c \\begin{align} a \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\ b \\geq c \\rightarrow b = c + m, m \\in \\mathbb{N}\\\\ \\end{align} 因此， a = b + n = c + m + n 显然就可得结论， a \\geq c (c) a \\geq b，b \\geq a ，则 a = b \\begin{align} a \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\ b \\geq a \\rightarrow b = a + m, m \\in \\mathbb{N}\\\\ \\end{align} 即 a = a + m + n 显然， m = 0，n = 0 ，则 a = b 。\n(d) a \\geq b if and only if a + c \\geq b + c . \\begin{align} (a \\geq b) \u0026\\iff a = b + m, \\, m \\in \\mathbb{N} \\\\ \u0026\\iff a + c = b + m + c = b + c + m, \\, m \\in \\mathbb{N} \\\\ \u0026\\iff a + c \\geq b + c. \\end{align} (e) a \u003c b if and only if a++ \\leq b .\nWe have\n\\begin{align} (a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\ \u0026\\iff ((a + m = b, \\, m \\in \\mathbb{N}) \\land (a \\neq b)) \\\\ \u0026\\iff m \\neq 0 \\\\ \u0026\\iff \\exists n \\in \\mathbb{N}, \\, n++ = m \\\\ \u0026\\iff a + (n++) = b, \\, n \\in \\mathbb{N} \\\\ \u0026\\iff (a++) + n = b, \\, n \\in \\mathbb{N} (引理 2.2.3)\\\\ \u0026\\iff a++ \\leq b. \\end{align} (f) a \u003c b if and only if b = a + d for some positive number d .\nWe have\n\\begin{align} (a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\ \u0026\\iff (a + d = b, \\, d \\in \\mathbb{N}) \\land (d \\neq 0) \\\\ \u0026\\iff a + d = b, \\, d \\text{ is positive.} \\end{align} 命题 2.2.13 （自然数的序的三歧性）\n令 a 和 b 表示任意两个自然数，那么在下面三种表述中恰有一种表述为真： a \u003c b ， a = b ， a \u003e b 。\n证明：\n首先我们证明 a \u003c b ， a = b 以及 a \u003e b 这三种表述中同时为真的表述个数不超过一个。如果 a \u003c b ，那么根据定义可知 a \\neq b ；同样，如果 a \u003e b ，根据定义可知 a \\neq b 。如果 a \u003e b 并且 a \u003c b ，那么根据命题 2.2.12 可知 a = b ，这显然与 a \\neq b 相矛盾。因此同时为真的表述个数不超过一个。\n现在我们证明至少有一个表述为真。\n保持 b 固定不变，对 a 进行归纳。当 a = 0 时，对所有的 b 均有 0 \\leq b （为什么？）因此我们得到 0 = b 或者 0 \u003c b ，从而 a = 0 时的结论得证。\n现在归纳性地假设关于 a 的命题已经被证明是成立的，下面我们要证明 a++ 也同样成立。\n从关于 a 的三歧性中可知，存在三种可能的情况： a \u003c b ， a = b 以及 a \u003e b 。如果 a \u003e b ，那么有 a++ \u003e b 。（为什么？）如果 a = b ，那么 a++ \u003e b 。（为什么？）现在假设 a \u003c b ，那么根据命题 2.2.12 可知 a++ \\leq b 。于是我们得到要么 a++ = b ，要么 a++ \u003c b ，其中任何一种情况都符合我们的要求。至此归纳法结束。\nWhy 1: When a = 0 , we have 0 \\leq b for all b .\n(0 + b = b, b \\in \\mathbb{N}) \\Rightarrow (0 \\leq b, b \\in \\mathbb{N}) Why 2: If a \u003e b , then a++ \u003e b .\n(a \u003e b) \\Rightarrow (a = b + m, m \\in \\mathbb{N}) \\land (a \\neq b) \\\\ \\Rightarrow a++ = b + (m++) \\Rightarrow a++ \u003e b Why 3: If a = b , then a++ \u003e b .\n(a = b) \\Rightarrow a++ = b++ = (b + 0)++ = b + (0++) = b + 1 \\\\ \\Rightarrow a++ \u003e b 命题 2.2.14 （强归纳法原理）\n令 m_0 表示一个自然数， P(m) 表示与任意自然数 m 有关的性质。假设对任意满足 m \\geq m_0 的自然数 m ，均有如下内容成立：若 P(m') 对任意满足 m_0 \\leq m' \u003c m 的自然数 m' 均为真，那么 P(m) 也为真。（特别地，这意味着 P(m_0) 为真，因为当 m = m_0 时，前提中的 m' 取值范围为空。）于是我们能够断定，对于任意满足 m \\geq m_0 的自然数 m ， P(m) 为真。\n注 2.2.15 在应用强归纳法原理的时候，我们通常令 m_0 = 0 或者 m_0 = 1 。\n证明： 设 P(m) 是一个与自然数 m 相关的命题。如果满足以下条件：\n基础情况：当 m = m_0 时， P(m_0) 为真。 归纳假设：对于任意 m \u003e m_0 ，如果 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 也为真。 则结论是： P(m) 对所有 m \\geq m_0 成立。\n证明过程\n1. 用普通归纳法重新定义问题\n设 Q(n) 表示如下命题：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ，命题 P(m) 都为真。\n我们的目标是证明：对于所有正整数 n ， Q(n) 成立。这等价于强归纳原理，因为 Q(n) 的结论覆盖了 P(m) 在 m \\geq m_0 的所有情况。\n2. 验证基础情况\n当 n = 1 时， Q(1) 的含义是：对于所有 m 满足 m_0 \\leq m \u003c m_0 + 1 ， P(m) 为真。\n因为能满足 m_0 \\leq m \u003c m_0 + 1 的自然数 m 只有 m_0 ，因此此情况下性质仅涉及 P(m_0) ，而强归纳原理假设， P(m_0) 为真，因此 Q(1) 为真。\n3. 验证归纳步骤\n假设 Q(n) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ， P(m) 为真。\n需要证明 Q(n+1) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n + 1 ， P(m) 为真。\n根据 Q(n) ，我们已经知道：\nP(m') 对于所有 m_0 \\leq m' \u003c m_0 + n 都成立。 我们现在需要证明 P(m_0 + n) 为真。这与基础情况的逻辑是相同的。\n因为 Q(n+1) 的定义是 Q(n+1) := \\forall m(m_0 \u003c m \u003c m_0 + n + 1 \\rightarrow P(m) \\text{为真}) 根据归纳假设， Q(n) 为真，即 P(m) \\text{对于所有的} m_0 \\le m \u003c m_0 + n \\text{都为真} 所以我们有待验证的范围还剩下 m_0 + n \\le m \u003c m_0 + n + 1 而满足上述范围的自然数 m 只有 m_0 + n 。\n综上，我们只需要证明 P(m_0 + n) 为真，即可得到 Q(n+1) 为真。\n根据强归纳原理假设，若 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 为真。\n将 m = m_0 + n 代入，这里 P(m') 对所有 m_0 \\leq m' \u003c m_0 + n 已经成立（由归纳假设 Q(n) ），因此 P(m_0 + n) 为真。\n结合归纳假设，我们得出 Q(n+1) 为真。\n4. 归纳完成\n通过普通数学归纳法，我们证明了 Q(n) 对所有正整数 n 都成立。这意味着：\n对于所有 m \\geq m_0 ， P(m) 为真。 逆向归纳法原理\n令 n 表示一个自然数， P(m) 是关于自然数的一个性质并且满足：只要 P(m++) 为真， P(m) 就为真。假设 P(n) 也为真，证明： P(m) 对任意满足 m \\leq n 的自然数 m 均为真；这被称为逆向归纳法原理。（提示：对变量 n 使用归纳法。）\n证明： Induction on n , let Q(n) represent:\nQ(n) := \\{ P(m) \\text{ is true, } \\forall m \\leq n \\} Case 0: Q(0) is true.\nIf Q(k) is true, then consider Q(k++) :\nQ(k++) = \\{ P(m) \\text{ is true, } \\forall m \\leq k++ \\} ,\nas P(k++) is true. Hence, Q(k++) is true.\nThe induction is valid.\n","cover":null,"tags":["数学分析"],"title":"2.2 加法和归纳原理的两个变体","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/"},{"content":"在学习实数分析之前，我们首先要回溯数的概念以及数的性质。\n我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?\n实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。\n现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。\n自然数集定义 定义 2.1.1 （非正式的）自然数是集合\nN := \\{ 0, 1, 2, 3, \\cdots \\} 的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。\n注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \\{1, 2, 3, \\cdots \\} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。\n从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：\nN 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？\n我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？\n我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：\na^3 = a \\cdot a \\cdot a 。\n乘法运算只不过是对加法运算的重复迭代：\n3 \\cdot a = a + a + a 。\n（由于减法和除法运算并不完全适用于自然数的运算，因此我们暂不讨论。我们在整数数和有理数对应的章节时，会对这些运算进行讨论。）\n加法和增量运算 那么加法又是怎么定义的呢？加法就是重复往前计数或者不断增加的运算。\n如果你把 5 加上 3 ，也就是使得 5 增长了三次。另外，增长看起来是一个基本的运算，它不能再被拆解为更加简单的运算。\n于是，为了定义自然数，我们将使用如下两个基本概念：数 0 和增量运算。我们使用 n++ 来表示 n 的增量或者紧跟在 n 后面的数字。例如： 3++ = 4, (3++)++ = 5 。\n注意，这与计算机的语言不同，在数学中，我们对一个变量只赋值一次。\n因此，这看起来就似乎说明 N 是由 0 以及所有能通过增量运算由 0 得到的数构成的。这就是 N 应该如下对象构成的：\n0, 0++, (0++)++, \\cdots 如果我们把自然数用上述对象来表示，那么得到了如下关于 0 和增量运算的公理。\n公理2.1 ~ 定义2.1.3 定义自然数集的具体元素 公理 2.1 0 是自然数。\n公理 2.2 如果 n 是自然数，那么 n++ 也是自然数。\n于是，举例来说，我们能通过公理2.1和公理2.2，可以推的 (0++)++ 是一个自然数。为了计数书写的方便，我们又有如下的定义。\n定义 2.1.3\n我们定义1为数 0++ ，2为数 (0++)++ 等等。\n于是，举例来说，我们有：\n命题 2.1.4 3 是一个自然数\nproof:\n根据公理2.1可知， 0 是一个自然数。根据公理2.2， 0++ = 1 是一个自然数。又根据公理2.2， 1++ = 2 也是自然数，那么再通过依序公理2.2， 2++ = 3 自然也是自然数。\n目前看来，我们对自然数已经有了充分的描述，但对于 N 的性质尚未彻底厘清。\n公理2.3 ~ 公理2.5 定义自然数系的具体性质 虽然我们定义了 0 和增量运算，并打算以此来构建自然数系，但是我们并没有对自然数系的性质做出规定。例如我们目前没有方法确定定义的自然数系会不会出现循环的情况，即\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 0 为了防止以上这种循环情况的产生，我们将引入另外的公理。\n公理 2.3\n0 不紧跟在任何自然数之后。换言之，对于任意一个自然数 n ， n++ \\neq 0 均成立。\n如此一来，我们就有防止循环情况出现的工具了。\n命题 2.1.6 4 \\neq 0 proof:\n根据定义 4 = 3++ ，根据公理2.1和公理2.2，可知 3 是一个自然数，故根据公理2.2， 4 也是一个自然数，再根据公理2.3，我们就有 3++ = 4 \\neq 0 。\n除此之外，我们还需要对其他的性质进行研究和规定，否则我们的数系仍然会存在很多病态的性质。\n例 2.1.7\n考虑由 0, 1, 2, 3, 4 构成的数系。在这个数系里，增量运算在遇到 4 时达到了运算的极限。换言之，在这个数系里\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 4, \\, 4++ = 4 （换言之，也就是 5 = 4++ = 4, 7 = 4++ = 4 ）。这种情况并不违背我们上面规定的任何公理或者定义，甚至，我们虽然防止了我们的自然数系出现绕回到 0 的情况，但它仍然可以绕回到 1, 2 等其他自然数。\n有许多的方法可以阻止这些情况发生，最简单的方法是设定下面的公理成立。\n公理 2.4\n对于不同的自然数而言，紧跟在它们之后的数字也必然不同。也就是说，如果 n 和 m 都是自然数，并且 n \\neq m ，那么 n++ \\neq m++ 。\n等价地说，如果 n++ = m++ ，则 n = m 。\n命题 2.1.8 6 不等于 2\nproof:\n使用反证法，假设 6 = 2 ，那么有 5++ = 1++ 。根据公理2.4，有 5 = 1 ，进而有 4++ = 0++ 。再次利用公理2.4，也就有 4 = 0 。在我们的数系中，只有 0 \\sim 4 这几个数是被定义好的，所有根据我们的规定， 4 = 0 与命题2.1.6矛盾，所有我们有结论 6 \\neq 2 。\n规定了上述的公理后，我们还需要考虑这样的自然数系的元素问题，目前来看，好像所有的自然数都是两两不同的，我们已经确定 0, 1, 2, 3, 4, \\cdots 是自然数系的不同对象，但是它们之间是否有其他形式的数字存在呢？\n例 2.1.9 （非正式的）\n假设我们的数系 N 是由如下的整数和半整数共同构成的：\nN := \\{0, 0.5, 1, 1.5, 2, 2.5, \\cdots\\} （该例之所以是非正式的是因为，我们提前使用了实数，但我们现在还没有定义实数。）容易验证，这个例子仍然满足公理2.1~公理2.4。\n为此我们希望有这样一个公理，它告诉我们自然数系的所有元素都可以通过对 0 进行增量运算来得到，从而能够从 N 中排除像 0.5 这种形式的元素。幸运的是，我们有一种巧妙的解决办法达到前述要求：\n公理 2.5 （数学归纳法）\n令 P(n) 表示自然数 n 满足的一种任意的性质，如果 P(0) 为真并且 P(n) 为真时 P(n++) 也为真，则对于任意的自然数 n ， P(n) 一定为真。\n隐藏在这个公理中的通俗的直观的说明如下：假设 P(n) 满足以下条件： P(0) 为真，且 P(n) 为真时 P(n++) 也为真，那么由于 P(0) 为真，所以 P(0++) = P(1) 也为真，进而 P(1++) = P(2) 也为真，以此类推我们可以得到 P(0), P(1), P(2), P(3), \\cdots 均为真。\n然而根据这样的规定，我们根本没有定义 0.5 这样的元素，因此公理2.5对 P(0.5) 是失效的，从而我们就避免了自然数系中出现附带的奇怪对象。\n在公理2.5之上，我们将在习题中给出关于它的其他形式，它们分别是：逆向归纳法、强化归纳法和超限归纳法*（这名字好酷对吧）。\n公理2.1 ~ 公理2.5被称为皮亚诺公理，这套公理系统就是定义自然数系的方法之一。为了定义自然数系，我们假设存在一个数系 N ，我们称 N 中的元素为自然数，而且公理2.1 ~ 公理2.5对 N 均成立。\n根据前面的所有规定，我们可以得到以下的这个结论：现在我们可以递归的定义序列。\n递归定义 假设我们通过以下方式来构造数列 a_0, a_1, a_2, \\cdots ：首先定义 a_0 的基值。例如，令 a_0 = c ，其中 c 是一个固定的数字。然后令 a_1 为关于 a_0 的某个函数： a_1 := f_0(a_0) ，令 a_2 为关于 a_1 的某个函数： a_2 := f_1(a_1) 。以此类推，一般地，我们记 a_{n++} := f_n(a_n) ，其中 f_n 是 N \\to N 的某个函数。利用前面的公理可以推出，对于任意给定的自然数 n ，上述过程将对应数列中的元素 a_n 给出唯一的值。\n更准确的说：\n命题 2.1.10 （递归定义）\n假设对于任何自然数 n ，都存在从自然数系到自然数系的函数 f_n: N \\to N ，令 c 为某个固定的自然数，那么对于任意的自然数 n ，都可以唯一确定自然数 a_n ，使得 a_0 = c 以及 a_{n++} = f_n(a_n) 恒成立。\nproof:\n利用归纳法。首先，根据题设，我们有 a_0 = c 。假设，题设的过程对 a_m 赋予了单一的值，由于公理2.3（ n++ \\neq 0 ）和公理2.4（ n++ \\neq m++ \\iff n \\neq m ），可知上述过程 a_{n++} := f_n(a_n) 对 a_n 来说是不会改变 a_n 的赋值的，因此可知上述过程也同样使得 a_{n++} 被唯一赋值了。那么根据数学归纳法，对于任意的自然数 n ， a_n 都被定义了，并且每个 a_n 都赋予了唯一的值。\n注意所有的公理在这个过程中是如何被应用的。在一个数系中，如果存在某种类型的绕回状况，那么递归定义就不适用于该数系。这是因为序列中的某些元素将会连续不断地被重新定义。例如，在例2.1.5中，因为 3++ = 0 ，所以 a_0 （至少）存在两种相矛盾的定义， c 或者 f_3(a_3) 。在一个含有多余元素（比如 0.5 ）的数系中，元素 a_{0.5} 将永远不会被定义。\n对于递归定义，我（笔记书写者）的理解是，我们首先固定了 a_0 = c ，然后递归的过程是\n\\begin{aligned} a_1 \u0026 := f_0(a_0), \\\\ a_2 \u0026 := f_1(a_1), \\\\ a_3 \u0026 := f_2(a_2), \\\\ \\text{也就是 } a_3 \u0026 := f_2(f_1(f_0(a_0))). \\end{aligned} 所以它就是固定一个对象，然后通过一系列函数的嵌套运算过程给出另一个对象的唯一赋值，通过对递归定义的重复应用，我们就可以定义出一系列对象，从而组成一个序列。\n一个简单的示例就是泰勒展开：\n我们知道导数的定义是\n\\frac{dy}{dx} = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} 从图像上讲，也就是说在曲线上的两点 (x_0, f(x_0)), (x_0 + \\Delta x, f(x_0 + \\Delta x)) 当横坐标无限靠近时，导数曲线上两点的点成也无限靠近，此时连接两点的直线成为曲线上的切线，两点成为一个切点。在这个切点上，切线与曲线的斜率就是导数的值。\n二阶导数是\n\\frac{d^2y}{dx^2} = \\lim_{\\Delta x \\to 0} \\frac{df(x_0 + \\Delta x) - df(x_0)}{\\Delta x}. 也就是说对于原函数曲线，一阶导组成的曲线在 (x_0, df(x_0)) , (x_0 + \\Delta x, df(x_0 + \\Delta x)) 切点处的导数， df(x_0) 就是原函数曲线在 x_0 和 x_0 + \\Delta x (\\Delta x \\to 0) 处的导数， df(x_0 + \\Delta x) 就是原函数曲线在 x_0 + \\Delta x 和 x_0 + 2\\Delta x (\\Delta x \\to 0) 处的导数，这在原函数曲线上表现为 f(x_0) \\sim f(x_0 + \\Delta x)(\\Delta x \\to 0) ， f(x_0 + \\Delta x) \\sim f(x_0 + 2\\Delta x)(\\Delta x \\to 0) 。这两段相连的曲线，我们知道因为 \\Delta x \\to 0 所以这两段曲线都缩略了两个点，而二阶导就是对这两点之间曲线段的拟合度的衡量。\n以此类推， x_0 处的三阶导、四阶导实际上就是通过对求导这个操作把原函数曲线在 x_0 的邻域内的曲线段一遍遍的放大，然后用切线来拟合曲线。\n所以泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x - x_0) + \\frac{f''(x_0)}{2!}(x - x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n, \\, R_n(x) = o\\left((x - x_0)^n\\right) 就是函数 f(x) 在 x_0 处，通过 n 次求导迭代得到的最终拟合的结果。而根据迭代的定义，我们知道这个迭代的拟合的过程中给出的赋值是唯一的，并且我们可以根据迭代次数来构造一个不同次迭代赋值得到的函数值的序列。\n总结 总而言之，以下是皮亚诺公理的全部内容：\n公理假设 皮亚诺公理假设存在一个集合 \\mathbb{N} ，其元素被称为自然数，以及一个称为“后继函数”的映射 S: \\mathbb{N} \\to \\mathbb{N} ，满足以下五条公理：\n五条皮亚诺公理 零是自然数：\n0 \\in \\mathbb{N}. （注：有些表述中将 0 换为 1 ，视具体情况而定。）\n每个自然数都有一个后继：\n\\forall n \\in \\mathbb{N}, S(n) \\in \\mathbb{N}. 后继函数 S 为每个自然数定义一个唯一的“下一个”自然数。\n零不是任何自然数的后继：\n\\forall n \\in \\mathbb{N}, S(n) \\neq 0. 这保证了自然数序列是以 0 为起点、向后无限延伸的，且没有“前驱”。\n不同的自然数有不同的后继（后继函数是单射）：\n\\forall m, n \\in \\mathbb{N}, \\, S(m) = S(n) \\implies m = n. 这保证了后继函数不会将两个不同的自然数映射到同一个自然数。\n数学归纳原理：\n若一个性质 P 满足以下两点：\nP(0) 成立； 对任何 n \\in \\mathbb{N} ，如果 P(n) 成立，则 P(S(n)) 也成立， 则 P(n) 对所有 n \\in \\mathbb{N} 成立。\n数学归纳原理确保可以对自然数集合进行递归定义和归纳证明。\n解释与扩展 皮亚诺公理定义了自然数的基本结构，其中 S 通常被解释为“加 1”操作。例如：\nS(0) 通常表示 1 ， S(S(0)) 表示 2 ，以此类推。 递归定义 通过皮亚诺公理可以递归定义自然数的加法和乘法等运算：\n加法定义：\nn + 0 = n, \\quad n + S(m) = S(n + m). 乘法定义：\nn \\cdot 0 = 0, \\quad n \\cdot S(m) = (n \\cdot m) + n. 数学基础中的地位 皮亚诺公理在数学基础中占有重要地位，为数理逻辑、集合论以及模型论等领域提供了形式化的支柱。\n","cover":null,"tags":["数学分析"],"title":"2.1 皮亚诺公理","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/"},{"content":"层叠样式表（Cascading Style Sheets，CSS）是一种强大的编程语言，可用于改变文档或文档集合的呈现方式，它几乎已经渗透到网络的每个角落以及许多表面上非网络的环境中。例如，嵌入式设备的显示通常使用 CSS 来设计其用户界面，许多 RSS 客户端允许你对订阅源和订阅条目应用 CSS，一些即时消息客户端使用 CSS 来格式化聊天窗口。CSS 的某些方面甚至可以在 JavaScript (JS) 框架的语法中以及 JS 本身中找到。它无处不在！\nCSS 最早在 1994 年被提出，当时正值互联网开始真正流行之际。当时，浏览器赋予用户大量的样式控制能力——例如，NCSA Mosaic 的显示偏好允许用户定义每种元素的字体系列、大小和颜色。而文档作者却没有任何这样的能力；他们只能将内容标记为段落、某一级别的标题、预格式化文本或其他十几种元素类型之一。如果用户将其浏览器配置为使所有一级标题变得又小又粉红，而所有六级标题变得又大又红，那完全是用户自己的选择。\nCSS 正是在这种环境中被引入的。其目标是为网页作者提供一种简单的声明式样式语言，既灵活又强大，最重要的是，能够同时为作者和用户提供样式控制能力。通过层叠机制，这些样式可以被组合和优先排序，使网站作者和读者都能表达自己的需求——尽管最终的决定权始终在读者手中。\n工作迅速推进，到 1996 年底，CSS1 已经完成。尽管新成立的 CSS 工作组继续推进 CSS2 的开发，但浏览器在以互操作性方式实现 CSS1 时遇到了困难。尽管 CSS 的每个部分本身都相对简单，但它们的组合却产生了一些令人意想不到的复杂行为。不幸的是，还出现了一些问题，比如臭名昭著的盒模型实现差异。这些问题一度威胁到 CSS 的发展，但幸运的是，一些巧妙的提议被实施，浏览器开始趋于一致。在接下来的几年里，随着互操作性的增强以及像《Wired》杂志基于 CSS 的重新设计和 CSS Zen Garden 等高调发展项目的推动，CSS 开始流行起来。\n在这一切发生之前，CSS 工作组于 1998 年初完成了 CSS2 规范。CSS2 甫一完成，随即开始了 CSS3 的开发以及一个经过澄清的版本 CSS2.1 的工作。与当时的潮流一致，最初称为 CSS3 的规范被设计为一系列（理论上）独立的模块，而不是一个庞大的整体规范。这种方法反映了当时活跃的 XHTML 规范，它也因类似的原因被分解为模块。\n对 CSS 进行模块化的理由是，每个模块可以按照自己的节奏进行开发，特别是重要或流行的模块可以沿着万维网联盟（W3C）的进展路径快速推进，而不会被其他模块拖延。事实上，这种方式确实奏效了。截至 2012 年初，已有三个 CSS Level 3 模块（以及 CSS1 和 CSS 2.1）达到了完整的推荐标准——CSS Color Level 3、CSS Namespaces 和 Selectors Level 3。同时，有七个模块达到了候选推荐（Candidate Recommendation）状态，还有数十个模块处于各种工作草案阶段。如果按照旧的方法，颜色、选择器和命名空间模块必须等到规范的所有其他部分完成或被舍弃之后，才能成为完成的规范的一部分。多亏了模块化设计，它们无需等待。\n因此，虽然我们无法指着一本完整的文档说“这就是 CSS”，但我们可以根据模块名称来讨论特性，因为这些特性是通过模块引入的。模块带来的灵活性远远弥补了它们有时造成的语义上的尴尬。（如果你想要接近单一整体规范的内容，CSS 工作组每年都会发布“Snapshot”文档。）\n有了这些背景知识，我们就可以开始理解 CSS 了。让我们从样式表的基本内容开始讲起。\n","cover":null,"tags":["前端开发"],"title":"1.1 (web)style 简史","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.1/"},{"content":"在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：\n1 2 3 4 5 6 7 8 /* 示例代码，仅用于展示 */ .example h1 { color: maroon; /* 改变一级标题颜色 */ } .example body { background: yellow; /* 设置背景颜色 */ } 诸如此类的样式共同构成了样式表的主体。\n规则的结构 为了更详细的说明规则的概念，让我们分解下代码的结构。\n每条规则由两个基本部分组成：选择器（selector）和声明块（declaration block）。声明块包含一个或多个声明（declaration），而每个声明由一个属性（property）和一个值（value）组成。每个样式表都是由这样的一系列规则构成的。图 1-1 展示了规则的各个部分。 选择器位于规则的左侧，用于定义文档中哪些部分将被选中进行样式应用。在图 1-1 中，选择器为 \u0026lt;h1\u0026gt;，表示选择所有一级标题（heading level 1）元素。如果选择器是 p，那么所有段落（\u0026lt;p\u0026gt;）元素将被选中。\n规则的右侧是声明块，由一个或多个声明组成。每个声明由一个 CSS 属性和该属性的值组成。在图 1-1 中，声明块包含两个声明。第一个声明指定规则会将文档的某些部分设置为红色文本，第二个声明指定文档的某些部分将有一个黄色背景。因此，文档中的所有 \u0026lt;h1\u0026gt; 元素（由选择器定义）将被设置为红色文本，并带有黄色背景。\n供应商前缀（Vendor Prefixing） 有时，您会看到 CSS 的某些部分带有连字符和标签，例如：-o-border-image。这些供应商前缀是浏览器供应商用来标记某些属性、值或其他 CSS 部分为实验性或专有功能（或者两者兼有）的一种方式。截至 2023 年初，仍有一些供应商前缀在使用，其中最常见的如表 1-1 所示。 如表1-1所示，供应商前缀的通用格式通常是连字符、标签和连字符，尽管有几个前缀错误地省略了第一个连字符。\n供应商前缀的使用与滥用历史悠久、复杂且超出了本书的范围。简单来说，它们最初的目的是为浏览器供应商提供测试新功能的方式，从而加速互操作性的发展，同时避免被与其他浏览器不兼容的遗留行为所束缚。这避免了一类几乎在 CSS 初期扼杀其发展的问题。然而，不幸的是，这些带前缀的属性随后被网页作者广泛使用，最终导致了全新的一类问题。\n截至 2023 年初，带有供应商前缀的 CSS 功能几乎已经不存在，旧的前缀属性和值正被浏览器实现逐步且稳定地移除。您可能永远不需要编写带前缀的 CSS，但可能会在实际项目中遇到，或者从遗留代码库中继承以下类似的代码：\n/* 示例代码，演示供应商前缀 */ .example { -webkit-transform: rotate(45deg); /* WebKit 内核浏览器 */ -moz-transform: rotate(45deg); /* Gecko 内核浏览器 */ -ms-transform: rotate(45deg); /* Trident 内核浏览器 */ -o-transform: rotate(45deg); /* 旧版 Opera 浏览器 */ transform: rotate(45deg); /* 标准 CSS 写法 */ } 这段代码实际上表达了同样的内容四次：分别为 WebKit（如 Safari、Chrome）、Gecko（如 Firefox）和 Opera 浏览器的前缀版本，最后是符合 CSS 标准的写法。再次强调，这种写法已经不再必要。我们在此仅包含它是为了让您对其可能的外观有一个概念，以备将来遇到类似情况时能够识别。\n空白符处理 CSS 基本上对规则之间的空白符不敏感，对规则内部的空白符也不太敏感，尽管存在一些例外情况。\n通常，CSS 处理空白字符的方式与 HTML 相同：任何连续的空白字符序列都会在解析时折叠为一个空格。因此，你可以以下列方式格式化这个假设的彩虹规则：\nrainbow: infrared red orange yellow green blue indigo violet ultraviolet;\nrainbow: infrared red orange yellow green blue indigo violet ultraviolet ; 以及你能想到的任何其他分隔模式。唯一的限制是分隔字符必须是空白字符：空格、制表符或换行符，单独使用或组合使用，数量不限。\n类似地，你可以以任何喜欢的方式用空格格式化一系列规则。以下这些都是这只是无数可能性中的五个例子：\n/* 示例代码，演示空白符处理 */ /* 示例样式仅应用于 .example 类范围 */ .example html {color: black;} /* 黑色文字 */ .example body {background: white;} /* 白色背景 */ .example p {color: gray;} /* 灰色段落文字 */ .example h2 {color: silver;} /* 银色标题 */ .example ol { color: silver; /* 银色有序列表 */ } 正如你从第一条规则中看到的，空白字符在很大程度上可以省略。实际上，这通常是压缩 CSS 的情况，压缩 CSS 是指移除了所有多余空白字符的 CSS，通常由某种自动化的服务器端脚本完成。第一条规则之后的规则逐步使用了更多的空白字符，直到最后一条规则，几乎每个可以分开到单独一行的部分都被分开了。\n所有这些方法都是有效的，所以您应该选择最有意义的格式——也就是最容易读懂的格式，并坚持使用它。\nCSS 中的注释 CSS允许注释。这些注释与 C/C++ 注释非常相似，它们被/* 和 */包围：\n/* This is a CSS comment */\n注释可以跨越多行，就像 C++ 一样。\n/* This is a CSS comment, and it can be several lines long without any problem whatsoever. */\n重要的是要记住，CSS 注释不能嵌套。例如，这是不正确的：\n/* This is a comment, in which we find another comment, which is WRONG /* Another comment */ and back to the first comment, which is not a comment.*/ 一种意外创建“嵌套”注释的情况是暂时注释掉包含注释的大块样式表。由于 CSS 不允许嵌套注释，“外层”注释会在“内层”注释结束的地方结束。\n不幸的是，CSS 中没有像 // 或 # 这样的“单行注释”模式（其中 # 已经被保留用于 ID 选择器）。CSS 中唯一的注释模式是 /* */。因此，如果您希望在与标记相同行中添加注释，需要注意放置的方式。例如，这是正确的做法：\n/* 示例代码，演示 CSS 单行注释的正确用法 */ .example h1 {color: gray;} /* 一级标题为灰色 */ .example h2 {color: silver;} /* 二级标题为银色 */ .example p {color: white;} /* 段落文字为白色 */ .example pre {color: gray;} /* 预格式化文字为灰色 */ 以下示例中，因为有四行注释都没有正确标注，大部分样式表将成为注释的一部分，因此将无法生效：\n.example h1 {color: gray;} /* This CSS comment is several lines .example h2 {color: silver;} long, but since it is not wrapped .example p {color: white;} in comment markers, the last three .example pre {color: gray;} styles are part of the comment. */ 在此示例中，只有第一条规则（h1 {color: gray;}）会应用到文档中。其余规则作为注释的一部分，被浏览器的渲染引擎忽略。\nCSS 注释被 CSS 解析器视为完全不存在，因此在解析时不算作空白字符。这意味着我们可以将它们放在规则的中间，甚至直接插入到声明中！\n标记（Markup） 样式表中没有标记（markup）。唯一的例外是 HTML 注释标记，由于历史原因，它被允许出现在 \u0026lt;style\u0026gt; 元素中：\n\u0026lt;!-- 示例代码，用于展示历史标记 --\u0026gt; \u0026lt;style\u0026gt; /* 这种写法仅为历史兼容性展示 */ .example h1 {color: maroon;} /* 一级标题为栗色 */ .example body {background: yellow;} /* 背景为黄色 */ \u0026lt;/style\u0026gt; 就像这样，不过即使是以上这样的代码也不再被推荐；需要它的浏览器已经几乎被遗忘了。\n说到标记，现在是时候稍微绕一下弯路来讨论 CSS 将用于设置样式的元素，以及 CSS 如何以最基本的方式影响这些元素。\n特别提示：在 Markdown 文档中嵌入示例代码块时，请注意添加诸如 .example 这类的名称来规避代码块对页面的影响。例如，如果我们在本文的第一个示例中忽略 .example 而直接书写 p 等选择器时，由于恰好示例代码是 css 代码，且示例代码恰好是全局选择器，因此我们新添加的属性值就会更改原来的页面样式。\n","cover":null,"tags":["前端开发"],"title":"1.2 样式表内容","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/"},{"content":"使用简单的文本编辑器，输入前面的任一示例并以文件名保存，如 helloworld.html 或 helloworld.htm；你可以选择使用 .htm 或 .html 文件扩展名，但无论你选择哪个进行开发，都要保持一致。这本书的所有文件都使用 .html。\n将示例文件保存到本地文件系统后，在 Web 浏览器中打开它，方法是打开文件菜单，然后根据你的浏览器选择打开、打开页面或打开文件： 一旦您的浏览器读取了该文件，它就应该呈现如下所示的页面： 如果由于某种原因没有使用适当的扩展名保存文件，则浏览器不会尝试解释 HTML 标记。例如，请注意当你尝试以 .txt 扩展名打开内容时: 如果要对文档进行更改，可以更新标记，保存文件，返回浏览器，然后单击重新加载或刷新按钮。有时，浏览器仍会从其缓存中重新加载页面；如果页面在重新加载时没有正确更新，请在按住 Shift 键的同时单击重新加载按钮，浏览器应该会刷新该页面。\n在编写标记时，保持浏览器和编辑器同时打开是一个非常好的主意，以避免不断地重新打开其中之一。许多 Web 编辑器将帮助您将 Web 页面加载到各种浏览器中，甚至直接预览标记的可视化。图1-1显示了 Adobe 广受欢迎的 Dreamweaver 程序[]。 ","cover":null,"tags":["前端开发"],"title":"1.3 Viewing Markup Locally","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.3/"},{"content":"在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。\n1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。\n数学中的语句按照分支被分为各自分支中的基本语句和复合语句。\n具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\\cdot7+2\\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 \u003c 来表征小于的线性序关系，那么 1+2\u003c2+3 、 5\\cdot2\u003c5\\cdot3 就都是基础语句。\n复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如\n\\begin{array}{l} ((5 \\cdot 2\u003c3 \\cdot 2) \\rightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\leftrightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\vee(\\neg(0=1))) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\wedge(\\neg(0=1))) \\end{array} 就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：\n\\neg(非),\\rightarrow(蕴含),\\leftrightarrow(对等),\\vee(或),\\wedge(且) 其中，\n1.符号\u0026quot; \\neg \u0026quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”\n2.符号\u0026quot; \\rightarrow \u0026quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”\n3.符号\u0026quot; \\leftrightarrow \u0026quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思\n4.符号\u0026quot; \\vee \u0026quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”\n5.符号\u0026quot; \\wedge \u0026quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”\n基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：\n\\begin{array}{l} 5\\cdot7+2\\cdot3=41\\\\ 5\\cdot3=11 \\end{array} 在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \\{0,1\\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。\n复合语句真假判定归结过程 复合语句的真假判定依赖于复合语句的布尔值计算规则。\n同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。\n我们约定用 1 来表示真，用 0 来表示假。并且 1\\ne 0 。复合语句的真假赋值必须遵从以下五条计算等式规则：\n1.否定词计算规则：‘并非’\n如果 A 是一个已经被赋值了的较低层次的逻辑命题，那么对于 A 的否定式 (\\neg A) 的赋值必须满足下述背反等式的要求：\n对 (\\neg A) 赋值为 1 的充要条件是对 A 的赋值为 0 ,对 (\\neg A) 赋值为 0 的充要条件是对 A 的赋值为 1 2.蕴含词计算规则：‘如果，那么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式 (A\\rightarrow B) 的真值赋值必须满足下述蕴含等式要求：对 (A\\rightarrow B) 的赋值为 0 的充分必要条件是 “(对 A 赋值为 1 ，对 B 赋值为 0 )”。 在蕴含赋值计算表中，我们将蕴含式 (A \\to B) 放于最右侧是因为， (A \\to B) 命题的层级比 A 和 B 都高，对于 (A \\to B) 的真值的赋值依赖于对 A 和 B 的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。\n3.析取词计算规则：‘要么，要么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的析取式 (A \\lor B) 的赋值必须满足下述析取等式要求：对 (A \\lor B) 的赋值为 1 的充分必要条件是 “（或对 A 的赋值为 1 ，或对 B 的赋值为 1 ）”，对 (A \\lor B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，并且对 B 的赋值也为 0 ）”。\n4.合取词计算规则：‘不仅，而且’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么他们的合取式 (A \\land B) 的赋值必须满足以下合取等式要求：对 (A \\land B) 的赋值为 1 的充分必要条件是 “（对 A 的赋值为 1 ，并且对 B 的赋值也为 1 ）”，对 (A \\land B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，或对 B 的赋值为 0 ）”。\n5.对等词计算规则：‘当且仅当’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的对等式 (A \\leftrightarrow B) 的赋值必须满足以下对等等式要求：对 (A \\leftrightarrow B) 赋值为 1 的充分必要条件是 “（对 A 和对 B 的赋值是相等的）”，对 (A \\leftrightarrow B) 赋值为 0 的充分必要条件是 “（对 A 和对 B 的赋值是不相等的）”。\n从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）\n\\begin{array}{l} 1. \\, A \\, \\text{与} \\, (\\neg(\\neg A)) \\, \\text{等价} \\\\ 2. \\, (A \\to B) \\, \\text{与} \\, ((\\neg B) \\to (\\neg A)) \\, \\text{等价} \\\\ 3. \\, (A \\lor B) \\, \\text{与} \\, (B \\lor A) \\, \\text{等价} \\\\ 4. \\, (A \\land B) \\, \\text{与} \\, (B \\land A) \\, \\text{等价} \\\\ 5. \\, (A \\leftrightarrow B) \\, \\text{与} \\, (B \\leftrightarrow A) \\, \\text{等价} \\end{array} 另外两条规律也值得注意：\n\\begin{array}{l} 6. \\, \\text{如果} \\, (A \\to B) \\, \\text{并且} \\, (B \\to C), \\, \\text{则} \\, (A \\to C) \\\\ 7. \\, \\text{如果} \\, (A \\leftrightarrow B) \\, \\text{并且} \\, (B \\leftrightarrow C), \\, \\text{则} \\, (A \\leftrightarrow C) \\end{array} 在数学逻辑中，我们实际上可以只要一条基本的推导规则：由 A 和 (A \\to B) 导出 B 来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。\n另外还需要注意，人们时常使用 \\Leftarrow 代替 \\leftarrow ， \\Rightarrow 代替 \\rightarrow ， \\Leftrightarrow 代替 \\leftrightarrow 。\n1.1.2 表达式及其语义解释 基本表达式及其语义解释 一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。\n比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：\nx+(y+z)=(x+y)+z\\\\ 当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。\n前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如， x+y=y+x 这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?\n在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为论域。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的结构就是线性代数的基本对象。\n因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。\n第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如\n1，2，3\\cdots2024\\cdots\\\\ 为一个项。\n任何一个被用来表示任意个体的变量（符号），比如\nx,y,z,A,B,C\\cdots \\\\ 也是一个项。\n然后，由任意两个已有的项 t_1 和 t_2 经过加法、乘法运算就可以得到新的项\nt_1+t_2,t_1\\cdot t_2 \\\\ 最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots+a_nx_n\\\\ x^m+b_1x^m+\\cdots+b_{m-1}x_1 \\end{array} 就是两个项。\n第二，我们规定，任何一个基本表达式无非就是由两个项所组成的一个等式，比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots a_nx_n=1,\\\\ x_m+\\cdots+b_m=0\\\\ \\end{array} 如果我们还关心诸如实数的线性序（例如 \u003c 就是被用来表达线性序的符号），那么任何一个涉及线性序的基本表达式就是由两个项所组成的不等式。比如\n\\begin{array}{l} a_1x_1+\\cdots+a_nx_n\u003c0,\\\\ b_1m_1+\\cdots+b_2m_2\u003ex_1+\\cdots+x_n\\\\ \\end{array} 不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种基本表达式：项之间的等式、项之间的不等式。以上两种基本表达式我们就分别称之为基本等式和基本不等式。\n第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。\n第四，在前述的基础上，我们来解决基本表达式的真假判定问题。\n给定一个基本表达式，令 t_1(x_1, \\cdots, x_n) 、 t_2(x_1, \\cdots, x_n) 为所涉及的两个项，并且约定，无论是 t_1 还是 t_2 ，在项中出现的所有自变量都出自变量 x_1, \\cdots, x_n 中。那么这 n 个变量就可以彼此独立地在实数范围内取任何值。\n我们规定任何一个实数的 n -元组 (a_1, \\cdots, a_n) 就是上述 n 个变量的一组取值。我们称 (a_1, \\cdots, a_n) 为 x_1, \\cdots, x_n 的一组赋值或者解释。\n并且，我们规定，记号 t_1(a_1, \\cdots, a_2) 和 t_2(a_1, \\cdots, a_2) 分别用来标识由计算过程 t_i (i=1, 2) 以数据 (a_1, \\cdots, a_n) 为输入所计算出来的结果，并且称 t_i 在数据 (a_1, \\cdots, a_n) 处的赋值或者解释。\n在此基础上，我们称数值等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 为基本等式 t_1 = t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n类似的我们称数值不等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 为基本不等式 t_1 \u003c t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n现在，我们就规定：\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n量词与表达式 前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入量词。\n既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。\n比如说考虑基本等式 x = y 和基本不等式 x \u003c y ，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。\n我们将“存在”这个词作为一种量词引入数学，并且用符号 \\exists 来表征“存在”：\n\\begin{array}{l} (\\exists x (\\exists y (x = y))), \\\\ (\\exists x (\\exists y (x \u003c y))) \\end{array} 其中 \\exists x, \\exists y 就都被称为一个存在量词。一个存在量词由符号 \\exists 与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号 () 将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n又比如，考虑基本等式 x + y = y + x 和基本不等式 0 \u003c (x + y)^2 。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。\n我们将“对于所有”这个短语作为一个量词引入，并且用符号 \\forall 来表征这个短语：\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 其中， \\forall x, \\forall y 就都被称为一个全称量词。一个全称量词由符号 \\forall 和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号 () 将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。\n第一，每一个基本表达式都是一个表达式：\n\\begin{array}{l} (t_1 = t_2), \\quad (t_1 \u003c t_2) \\quad (\\text{为了规范起见，我们加上圆括号}) \\end{array} 第二，假设已经得到一个表达式，比如说这个表达式被记作 \\varphi ，那么这个表达式的否定式 (\\neg \\varphi) 也是一个表达式。\n第三，假设已经得到两个表达式，比如说它们被记为 \\varphi 和 \\psi ，那么\n(1) (\\varphi \\lor \\psi) 是一个表达式\n(2) (\\varphi \\land \\psi) 是一个表达式\n(3) (\\varphi \\to \\psi) 是一个表达式\n第四，假设已经得到一个表达式 \\varphi ， x 是一个变量符号，那么\n(1) (\\exists x \\varphi) 是一个表达式\n(2) (\\forall x \\varphi) 是一个表达式\n最后，除了以上的规定，没有获得新的表达式的可能途径。\n关于两个量词的否定，我们规定\n\\begin{array}{l} (\\neg (\\forall x \\varphi)) \\text{ 即为 } (\\exists x (\\neg \\varphi)) \\end{array} 以及\n\\begin{array}{l} (\\neg (\\exists x \\varphi)) \\text{ 即为 } (\\forall x (\\neg \\varphi)) \\end{array} 自由变元与约束变元 关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式 \\varphi 和一个变量符号 x ，假设这个 x 在表达式中出现若干次。\n如果 x 在某一处的出现不在任何存在量词或全称量词的作用范围内，就称 x 为 \\varphi 的一个自由变量。反之，则被称为约束变量。\n在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为语句。比如\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 就是一个语句。\n在应用中，我们常常会使用形如下述的受囿量词：\n\\begin{array}{l} \\forall x \\in A, \\quad \\exists x \\in A \\end{array} 这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围 A 之中，并且通常 A 就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如\n\\begin{array}{l} (\\forall x \\in A \\varphi(x)) \\end{array} 这个表达式实际上是\n\\begin{array}{l} \\forall x ((x \\in A) \\to \\varphi(x)) \\end{array} 同样的\n\\begin{array}{l} (\\exists x \\in A \\varphi(x)) \\iff \\exists x ((x \\in A) \\land \\varphi(x)) \\end{array} 更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。\n表达式语义解释与真假判定 仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。\n我们现在设 \\varphi(x_1, x_2, \\cdots, x_n) 是一个表达式，并且 \\varphi 中出现的任何的自由变元都来自 (x_1, x_2, \\cdots, x_n) 中，设 (a_1, a_2, \\cdots, a_n) 是实数的一个 n 元组。我们将 \\varphi 中出现的自由变元 x_i 进行赋值，使得自由变元 x_i 被相应的赋值为 a_i ，这时 \\varphi[a_1, a_2, \\cdots, a_n] 就是对 (a_1, a_2, \\cdots, a_n) 的性质描述，其中没有任何的需要特定赋值的自由变元。\n我们将根据表达式 \\varphi(x_1, x_2, \\cdots, x_n) 构造中可能存在的结构来规定如何判定\n\\varphi[a_1, a_2, \\cdots, a_n] 的真假。\n(1) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是一个基本表达式，那么 \\varphi[a_1, a_2, \\cdots, a_n] 的真假已经在前文被确定好了。\n(2) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是表达式 \\phi(x_1, x_2, \\cdots, x_n) 的否定式，即 \\varphi = (\\neg \\phi) 并且 \\phi[a_1, a_2, \\cdots, a_n] 的真假已经被确定，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为假\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为真\n(3) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是由两个表达式 \\psi_1(x_1, x_2, \\cdots, x_n) 和 \\psi_2(x_1, x_2, \\cdots, x_n) 通过联结词 \\lor 联结而成，即 \\varphi = (\\psi_1 \\lor \\psi_2) ，并且 \\psi_1[a_1, a_2, \\cdots, a_n] 和 \\psi_2[a_1, a_2, \\cdots, a_n] 的真假已经确定，那么\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(4) 把上述推导的联结词换成 \\land ，那么 (a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(5) 如果 \\varphi = (\\psi_1 \\to \\psi_2) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，但是 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(6) 如果 \\varphi = (\\forall y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为假\n(7) 如果 \\varphi = (\\exists y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为假\n当一个表达式在一组数据 (a_1, \\cdots, a_n) 下为真时，我们说这组数据满足表达式。反之则不满足。\n比如，下面这三句话在任何地方都是真语句，只要涉及到等号，下面三个语句就都为真。\n\\begin{array}{l} (\\forall x (x = x)) \\\\ (\\forall x (\\forall y ((x = y) \\to (y = x)))) \\\\ (\\forall x (\\forall y (\\forall z (((x = y) \\land (y = z)) \\to (x = z))))) \\end{array} 这三句话称为基本等号律，也称同一律。\n","cover":null,"tags":["代数学"],"title":"1.1  逻辑基础","url":"/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/"},{"content":"函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。\n若函数 f(t) 变成了另一个函数 f(t)\\longrightarrow \\tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \\delta f 被定义为\n\\delta f(t):=\\tilde{f(t)}-f(t)\\\\ 上式中的变分符号\u0026quot; \\delta \u0026quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \\delta f 是作为另一个函数存在的。\n函数的变分 \\delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变\nf(t)\\xrightarrow{t\\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\\cdots\\\\ 而函数的变分 \\delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关\nf(t)\\rightarrow\\tilde{f(t)}\\equiv(f+\\delta f)(t)=f(t)+\\delta f(t)\\\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如\n\\delta (f^n)=nf^{n-1}\\delta f\\\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有\n\\begin{align} \\delta(af_1+bf_2)=a\\delta f_1+b\\delta f_2\\\\ \\delta(f_1f_2)=(\\delta f_1)f_2+f_1(\\delta f_2) \\end{align}\\\\ 另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“\nd(\\delta f)=\\delta(df)\\\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B' 点的差，即\n\\tilde{f}(t+dt)-f(t)\\\\ 若先微分后变分(路径 A\\rightarrow B\\rightarrow B' ),精确到一阶小量有\n\\begin{align} C'B长度\u0026=f(t+dt)-f(t)=df(t)\\\\ BB'长度\u0026=\\tilde{f}(t+dt)-f(t+dt)\\\\ \u0026=\\delta(f(t+dt))\\\\ \u0026=\\delta(f(t)+df(t))\\\\ \u0026=\\delta(f(t))+\\delta(d(f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=df(t)+\\delta f(t)+\\delta (df(t))\\\\ 若先变分再微分(路径 A\\rightarrow A'\\rightarrow B ),精确到一阶小量有\n\\begin{align} AA'长度\u0026=\\tilde{f}(t)-f(t) \\\\\u0026=\\delta f(t)\\\\ A'C长度\u0026=\\tilde{f}(t+dt)-\\tilde{f}(t)\\\\ \u0026=d\\tilde{f}(t)\\\\ \u0026=d((f+\\delta f)(t))\\\\ \u0026=df(t)+d(\\delta f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=\\delta f(t)+df(t)+d(\\delta f(t))\\\\ 进而有，\nd(\\delta f)=\\delta(df)\\\\ 上式的直接推论即变分和求导运算也可以交换顺序，即是说\u0026quot;导数的变分\u0026quot;=\u0026ldquo;变分的导数\u0026rdquo;.\n\\frac{d}{dt}(\\delta f(t))=\\delta(\\frac{d}{dt}f(t))\\\\ 这里的关键在于，变分变化的是函数本身，而与自变量无关。\n","cover":null,"tags":["经典力学"],"title":"1.2 变分","url":"/notes/physcis/classical-mechnics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.2/"},{"content":"我们首先来回顾一下函数的概念。\n一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：\n函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\\in X 和 y\\in Y 之间建立的一个对应关系即为映射。\nf:x\\rightarrow y=f(x) \\\\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。\n例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。\n上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。\n这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。\n至此，**\u0026ldquo;泛函\u0026rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\\cdots,f_n(x) ，所有这些函数自然也构成集合 \\mathcal{F}=\\{f_1,f_2,\\cdots,f_n\\} ,把函数 f 的泛函记为 s[f] ，即\nS:f\\longmapsto S=S[f],\\quad\\mathcal{F}\\longmapsto \\mathcal{C}\\\\ 其中， \\mathcal{C} 代表复数集合。\n泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。\n1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如\n平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函\nS(曲线长度)=S[f](曲线方程f的泛函)=\\int\\limits_{曲线}dx\\sqrt{1+(f'(x))^2}\\\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函\nW=W[p]=\\int\\limits_{过程}p(V)dV\\\\ 三维空间曲线方程记为 z=\\phi(x,y) ，则曲面面积 A 为二元函数 z=\\phi(x,y) 的泛函\nA=A[\\phi]=\\iint_{\\text {区域 }} \\mathrm{d} x \\mathrm{~d} y \\sqrt{1+\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial \\phi}{\\partial y}\\right)^{2}} \\\\ 经典力学中的遇见的泛函，通常为以下形式\nS[f]=\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right)\\\\ 此处的被积函数 L=L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 是函数 f(t) 及其导数的一般函数。\n可以再次看到，泛函的结果或者说输出 s[f] 是一个数，但是 s[f] 描述的对象是函数的函数，也就是函数所遵循的具体的对应关系，在上式中，它是 f(t) 遵循 \\int\\limits_{t_1}^{t_2} dtL\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 。\n我们称数 s[f] 是 f 的泛函，其实是\u0026quot; s[f] 所描述的函数的函数是函数 f 的泛函\u0026quot;的简洁说法，因为 s[f] 的结果是数，所以简称数 s[f] 是 f 的泛函。\n","cover":null,"tags":["经典力学"],"title":"1.1 泛函","url":"/notes/physcis/classical-mechnics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.1/"},{"content":"1.Markdown 语法 元素 Markdown 语法 标题 (Heading) # H1 ## H2 ### H3 粗体 (Bold) bold text 斜体 (Italic) italicized text 引用块 (Blockquote) \u0026gt; blockquote 有序列表 (Ordered List) 1. First item 2. Second item 3. Third item 无序列表 (Unordered List) - First item - Second item - Third item 代码 (Code) code 分隔线 (Horizontal Rule) \u0026mdash; 链接 (Link) title 一级列表项 1 二级列表项 1.1 三级列表项 1.1.1 二级列表项 1.2 一级列表项 2 元素 Markdown 语法 表格 (Table) | Syntax | Description | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | Header | Title | | Paragraph | Text | 代码块 (Fenced Code Block) \u0026lt;br\u0026gt; { \u0026lt;br\u0026gt; \u0026quot;firstName\u0026quot;: \u0026quot;John\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;lastName\u0026quot;: \u0026quot;Smith\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;age\u0026quot;: 25 \u0026lt;br\u0026gt; } \u0026lt;br\u0026gt; 脚注 (Footnote) Here\u0026rsquo;s a sentence with a footnote. [^1] [^1]: This is the footnote. 标题编号 (Heading ID) ### My Great Heading {#custom-id} 定义列表 (Definition List) term : definition 删除线 (Strikethrough) The world is flat. 任务列表 (Task List) - [x] Write the press release - [ ] Update the website - [ ] Contact the media ~ 公理1.1 ~\n公理1.1\n以上内容来自 Markdown 语法官方中文教程\n2.Markdown 语法报错修正 代码块 `` Markdown 代码块中的代码是保存功能而不仅仅只是展示用的，因此，当处于代码块中的代码是关于页面设定的代码，那么，它就会影响网页的生成。\n为了避免这种情况，我们需要采用如下语法来规避影响：\nHTML 标签 在需要显示代码时，可以使用 \u0026lt;code\u0026gt; 或 \u0026lt;pre\u0026gt; 标签来确保代码的正确显示，这些标签不会引起 Markdown 渲染问题。\n例如：\n1 \u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt; 更保险一些可以改写为\n1 \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 其中 pre 标签是 HTML 中的一个标签，用于定义 预格式化文本。它的作用是按照原样保留文本的格式，尤其是 空格、换行和制表符 等白空格字符，不会被浏览器自动压缩或忽略。常用于显示格式化的文本内容，比如代码、日志文件等。\n以及，三个反引号之后的语法声明，例如 三反引号+html 只是使得代码块中的 HTML 语法高亮显示，而不是对其格式化。\n3.LaTex渲染测试 测试项目（1）：行内渲染和展示渲染\nS[x^A(t)]=\\int dtL(x^A(t),\\dot{x}^A(t))\\tag{1.0} d \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over B} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\times \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over r} }}{{{r^3}}} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\sin \\theta }}{{{r^2}}} 结果表明，展示渲染块内无需添加 // 以声明展示居中，这正是我们特地定义展示渲染模式的目的。（事实上，展示渲染加 // 会导致报错）\n根据 layouts/shortcode/latex.html 设定，{{latex}} 默认 display=\u0026ldquo;true\u0026rdquo; 因此展示渲染可以直接使用 {{latex}}{{/latex}}，行内展示则需要定义 display=\u0026ldquo;false\u0026rdquo;。(但是保险起见还是全都加上 dispaly 属性的好，因为有时 api 会因为一些神必原因而为此报错)\n测试结果项目（2）：公式内空格\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots)\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots) S[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\nS[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots) 测试结果项目（3）：公式写法\n\\bigg、\\equiv 等特殊符号都是可用的。 align 环境中不可插入中文，需要使用 \\text{}。 特殊符号也不可携带中文，例如：\\xlongequal{\\text{变分与求导交换顺序}}、_{\\text{全导数}}。因此，我们或者使用全英文，或者对中文使用 \\text{} 转写。 {{latex}} 内可以无需在意符号转义。但是为了避免报错，还是建议当输入 f\u0026rsquo;(x) 这样的符号时，\u0026rsquo; 尽量使用英文冒号键而不是反引号键。 测试项目(2)证明了特殊符号之间的空格不影响渲染结果，但是，需要注意的是，特殊符号和字母之间必须有空格，例如 \\delta L。因为 \\deltaL 这个特殊符号是不存在的。 Markdown 加粗语法可以包裹 LaTeX 代码。 有序列表、无序列表都需要在文本和序号之间加一个空格符。\n","cover":null,"tags":null,"title":"测试专用页","url":"/notes/test-page/"},{"content":"","cover":null,"tags":["数学分析"],"title":"1.2","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.2/"},{"content":"1.请给出以下集合的笛卡尔积的几何解释：\n二线段（矩形） 二直线（平面） 直线和圆周（圆柱面） 直线和圆面（圆柱体） 二圆周（圆环面） 圆周和圆面（圆环体） 解答：\n二线段（矩形） 集合： A = [a_1, a_2] ， B = [b_1, b_2] 。 笛卡尔积：\nA \\times B = {(x, y) \\mid x \\in [a_1, a_2], y \\in [b_1, b_2] } 。\n几何解释：\n该笛卡尔积代表了二维平面中的一个矩形区域，其中横坐标范围为 [a_1, a_2] ，纵坐标范围为 [b_1, b_2] 。因此，笛卡尔积构成了一个矩形。\n二直线（平面） 集合： A = \\mathbb{R} ， B = \\mathbb{R} 。 笛卡尔积：\nA \\times B = \\mathbb{R}^2 几何解释：\n二直线的笛卡尔积是二维平面。每个直线可以看作一个一维空间（实数集合 \\mathbb{R} ），而笛卡尔积将其结合形成了一个二维平面 \\mathbb{R}^2 。\n直线和圆周（圆柱面） 集合： A = \\mathbb{R} ， B = S^1 （单位圆周）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times S^1 几何解释：\n直线和圆周的笛卡尔积在三维空间中形成了一个圆柱面。圆周 S^1 提供了一个循环的二维几何结构，直线 \\mathbb{R} 沿该圆周的每个点延伸，因此形成了一个圆柱面。圆柱面每一“层”都是一个圆周。\n当我们将圆周 S^1 中的点用极坐标表示时，通常会使用坐标对 (r,\\theta) ，由于 S^1 形成的圆周是一个单位圆，因此 r=1 。\nA=\\mathbb{R} 表示一条直线（即 x 轴）。 B=S^1 表示单位圆周，圆周上的任意一个点的极坐标表示为 (r,\\theta)=(1,\\theta) 基于以上条件，笛卡尔积 A \\times B = \\mathbb{R} \\times S^1 中的每一个元素就都是形如 (x,(1,\\theta)) 的元素。\n更进一步，如果我们考虑的是三维空间中的直线和圆周的笛卡尔积，则我们需要用笛卡尔坐标系来表示这些点。\n圆周上的点 (r,\\theta)=(1,\\theta) 通过极坐标转换到笛卡尔坐标时，可以得到圆周上一个点的笛卡尔坐标表示：\n(x,y)=(\\cos(\\theta),\\sin(\\theta)) 因此，笛卡尔积中元素点所对应的三维坐标形式即为：\n(x,y,z)=(\\cos(\\theta),\\sin(\\theta),a) 其中 a\\in A 。\n这个结果表明了情况三的笛卡尔积的几何结构：\n直线（z 轴）上的每一个点 a 都对应圆周上的一个点 (\\cos(\\theta),\\sin(\\theta),a) (\\cos(\\theta),\\sin(\\theta),a) 最终构成的集合的几何形式即为 x-y 平面上的单位圆（简单起见，我们可以把圆心与坐标原点重合）。 (x,y,z)=(\\cos(\\theta),\\sin(\\theta),a) 所构成的几何形状自然就是，以 x-y 平面上的单位圆为底，整个 z 轴为高的一个圆柱面。（圆柱面是一个曲面，它由一族平行的直线构成，每条直线都通过一个固定的曲线（通常是圆形）。圆柱面是二维的，没有“内部”部分，它只包含外部的“面”。） 直线和圆面（圆柱体） 集合： A = \\mathbb{R} ， B = \\mathbb{R}^2 （二维圆面，如 x^2 + y^2 = r^2 ）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times \\mathbb{R}^2 几何解释：\n直线和圆面的笛卡尔积生成一个圆柱体。直线 \\mathbb{R} 是圆柱体的轴，而二维圆面 \\mathbb{R}^2 在每个点沿轴方向扩展，形成圆柱体的横截面。\n实际上，基于上一情况的描述，我们容易知道，这个圆周体上的元素的形式为：\n(x,y,z)=(r\\cos(\\theta),r\\sin(\\theta),a) 二圆周（圆环面） 集合： A = S^1 ， B = S^1 。 笛卡尔积：\nA \\times B = S^1 \\times S^1 几何解释：\n两个圆周的笛卡尔积描述了一个圆环面。每个点在这个圆环面上都可以由两个角度来标定，分别属于两个独立的圆周。形象地说，圆环面是两个圆周的组合，类似于圆环的表面。\n在这个情况下，由于笛卡尔积的两个坐标都可以使用极坐标来表示，因此我们可以完全使用极坐标系来描述这个笛卡尔积，那么，该笛卡尔积上的每一个元素的形式即为：\n(r\\theta_1,r\\theta_2)=(\\theta_1,\\theta_2) 让我们来看一些更有趣的事实：\n1. S^1 \\times S^1 的拓扑维度：\nS^1 是一个一维流形，它在拓扑意义上需要一个参数（ |\\theta ）即可描述。因此\nS^1 的维度是 1 维。 S^1 \\times S^1 的维度是 2 维。 从流形的角度，它本质上是一个二维流形（常称为环面或圆环面，torus）。这个二维性与所使用的坐标系无关——它是一个固有性质。无论你用哪种坐标（极坐标、角度坐标或其他），该流形本身的拓扑维度始终是 2。\n2.极坐标描述 vs. 笛卡尔坐标描述：\n在描述 S^1 \\times S^1 时，我们只需要用两组角度来参数化描述：\n(\\theta_1,\\theta_2) 这里用两个角度参数就能完全描述这个流形上的任意一点，因此体现了它的二维本质。\n如果你尝试用“笛卡尔坐标”来描述每个 S^1 ，你可能会写出\nS^1=\\{(x,y)|x^2+y^2=1^2\\} 这里的每一个 S^1 都嵌入到 \\mathbb{R}^2 中，因此 S^1 \\times S^1 被嵌入到 \\mathbb{R}^2 \\times \\mathbb{R}^2=\\mathbb{R}^4 中，在这种表示下，笛卡尔积元素中的一个点 (\\theta_1,\\theta_2) 被映射为：\n(\\cos(\\theta_1),\\sin(\\theta_1),\\cos(\\theta_2),\\sin(\\theta_2))\\in\\mathbb{R}^4 虽然这里用了四个坐标数值来描述这个环面上的一个点，但这并不意味着该流形是四维的。它只意味着当你以这种方式嵌入到 \\mathbb{R}^4 时，这个二维流形占据了一个四维空间中的二维子集。换句话说，它是一个嵌入在四维空间中的二维曲面，就像一条线（1维）可以嵌入到平面（2维）中，而不会改变线本身是一维的事实。坐标系的选择不会改变流形的维数。\n因此，我们在情况3、4中说讨论的笛卡尔积，实际上都是二维流形嵌入三维空间的实例，它们本身仍然是二维的。\n圆周和圆面（圆环体） 集合： A = S^1 ， B = \\mathbb{R}^2 （二维圆面）。 笛卡尔积：\nA \\times B = S^1 \\times \\mathbb{R}^2 几何解释：\n圆周和圆面的笛卡尔积描述了一个圆环体。圆周 S^1 确定了该体的一个边界，而二维圆面 \\mathbb{R}^2 表示内部的自由度。圆环体可以想象为一个在三维空间中的“管状”体，外部表面是由圆周和圆面笛卡尔积形成的。\n有了情况5的讨论，我们很容易就可以看出此笛卡尔积的几何意义，本质上，它是一个三维流形，\n将 S^1 理解为一个“环”（圆周），将 \\mathbb{R}^2 理解为一个无限扩展的平面。那么 S^1 \\times \\mathbb{R}^2 可以看作是在圆周的每一点上，都“附着”了一个与之关联的二维平面。\n换句话说，如果你固定一个 \\theta \\in S^1 ，那么对应的 {\\theta} \\times \\mathbb{R}^2 就是一个平面。随着 \\theta 沿着圆周变化，这些平面在空间中“环绕”一圈，形成了一个三维的几何结构。\n若仅有 S^1 \\times \\mathbb{R} ，我们会得到一个圆柱面（2维流形：圆周 × 直线）。 而当直线 \\mathbb{R} 替换为平面 \\mathbb{R}^2 ，每个圆周点对应的不是一条线，而是一个无限扩展的平面。将这些无数平面按照圆周参数拼接起来，就会得到一个比圆柱面更高维的结构——一个 3维流形，可以形象地称其为“环状分布的无限平面叠加”。\n虽然这个形状很难在我们的三维直观中完全可视化，但从拓扑维度与参数化的角度，它是一个3维的流形，其内部结构由一个环状方向（ S^1 ）和两个线性无界方向（ \\mathbb{R}^2 ）组成。\n1. 什么是流形？\n首先，**流形（manifold）**是一个具有局部欧几里得空间结构的几何对象。对于 二维流形 来说，它在局部看起来就像一个二维平面，即在每个点附近都有一个局部坐标系统（通常是二维坐标）。但全局结构可能更复杂，具有弯曲或扭曲的特性。\n例如，地球表面是一个二维流形，它局部看上去是平面的（如地图上的小区域），但全局却是球形的。\n2. 二维流形嵌入到三维空间\n当我们说一个 二维流形 嵌入到 三维空间 中时，实际上是指流形的每个点都通过一个嵌入函数与三维空间中的一个点一一对应。这个嵌入的意义是，流形可以通过一些连续函数与三维空间的点相对应，使得流形在局部看起来和欧几里得平面一致，但可能具有全局的弯曲或曲率。 常见的二维流形嵌入三维空间的例子：\n圆环（圆周）：圆周是一个二维流形，局部上看起来像平面，但在三维空间中，它形成了一个二维曲面。 球面（如地球表面）：球面是一个二维流形，在三维空间中它表现为一个弯曲的表面。尽管它是二维流形，但它的形状在三维空间中是显而易见的。 环面（如甜甜圈形状）：环面是两个圆周的笛卡尔积( S^1 \\times S^1 )，它是一个二维流形，嵌入三维空间时，表现为一个环状的表面。 3. 流形看上去是否是三维的？\n当二维流形嵌入三维空间时，它 在整体上 不会显现出三维的结构，因为它只有 二维。然而，二维流形的形状和性质可能会因为其弯曲、扭曲等特性而使得它的几何体积在视觉上更为复杂，从而给人一种“近似三维”的感觉。 例如：\n一个 圆柱面 是一个二维流形，在三维空间中表现为一个有曲率的表面，尽管它是二维的，但由于其延伸在三维空间中，它看上去很像三维物体。(实际上，它的对应物体就是一张无限薄的，位于三维空间的，弯曲的矩形纸张。) 球面 是二维流形，但它在三维空间中的嵌入是弯曲的，从几何学上看，它显然是一个弯曲的三维物体，尽管它本质上是二维流形。 因此，二维流形在三维空间中的“外观”并不意味着它变成了三维物体，而是它依然是二维的，但是由于其在空间中是弯曲的，或者有拓扑结构，它会在视觉上显得有一定的复杂性。我们可以通过其 局部坐标系 和 全局形状 来区分它是二维的。\n3. 局部坐标系与全局形态\n我们之前讨论过，局部坐标系 能够描述流形在某一点附近的几何性质，但它无法揭示流形的 全局形态。对于 球面（S²） 或 球体（B³） 这样的物体，局部坐标系只能提供该物体某个小区域的欧几里得性质。\n在球面上的某个小区域，局部坐标系看起来像平面，但这不能描述球面的弯曲结构，尤其是球面的 全局曲率。局部坐标系无法直接揭示球面如何从局部变到整体的弯曲形状。球体的局部坐标系也只能描述球体某一点附近的结构，不能通过局部坐标系统来理解球体的 整体体积 和 三维结构。\n4.三维物体与二维物体的本质区别\n三维物体和二维物体的本质区别，不仅在于维度上的差异，还在于它们的 几何性质 和 拓扑结构。\n4.1 维度差异\n二维物体的每个点都可以用两个参数来描述，例如在平面上的 (x,y) 。在球面上，你可以使用极坐标 (r,\\theta) 来描述每个点。 三维物体每个点需要三个参数来描述，例如在三维空间中的 (x,y,z) 坐标。对于球体，球体的内部点和球面上的点都属于同一个物体，但它们在 维度 上有根本的区别，球体的内部有额外的体积和空间扩展。 4.2 几何性质\n二维物体：只有 两维几何属性（如弯曲度、曲率等）。二维物体通常不能再扩展成其他维度的结构，它只能弯曲或扭曲。\n三维物体：三维物体有 体积、厚度 和 空间，可以有不同的结构和属性，比如 体积的分布、内外结构、容积 等。这些特性使得三维物体与二维物体本质上有很大区别。 4.3 拓扑结构\n二维物体的拓扑：二维物体的拓扑结构决定了它的边界、孔洞等性质。一个球面是 无边界 的，且在全局上是 闭合 的。三维物体的拓扑：三维物体的拓扑结构决定了它的体积、边界和孔洞。一个球体是一个 三维 闭合体，具有 体积 和 内部结构。\n5.球面被嵌入三维空间时，其表面上的点将使用三个坐标参数来描述，为什么这不代表它具有第三个维度属性？\n这个问题实际上与经典力学的约束与自由度的解释是一致的。在数学中，球面 S^2 被视为一个二维流形。这意味着，尽管球面嵌入三维空间，我们仍然认为球面只有二维，因为我们用 两个参数 就能描述球面上的任何一点。\n球面是通过两个参数（比如极坐标系中的 \\theta 和 \\phi 来描述的\nS^2=\\{(x,y,z)\\in\\mathbb{R}^3|x^2+y^2+z^2=r^2\\} 虽然在三维空间中，球面上的每个点都需要三个坐标来表示，但这三个坐标是由 两个自由参数( \\theta 和 \\phi )和一个约束条件( x^2+y^2+z^2=r^2 ) 共同决定的。这些坐标并不增加球面作为流形的维度，而是描述了它的嵌入。\n","cover":null,"tags":["数学分析"],"title":"1.2 集合及其基本运算习题选做","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.1/"},{"content":"1.关于这个网站的用途： 本网站为个人博客网站。主要的用途有三个部分：\n读书笔记的记录。 学习过程中的思考记录 资源的合法分享 由于本人能力不足，无法做到在教材的基础之上进行创新的讲述，因此，读书笔记的内容可能会与原文存在很大重合。 但为了保证对原教材的权益保护。本网站绝不会进行任何的盈利活动，读书笔记的分享也仅出于个人的记录需要和学习的分享需要。 如果您发现网站有任何事实不正确、侵犯版权或任何其他问题，请联系我，我会按照您的要求进行删改。对于任何此类错误，我提前表示歉意。\n2.关于这个网站的目的： 由于一些特殊的原因，我没有在学校进行学习。我所有的学习资源和途径均来自于互联网上秉持着开源精神的伟大的人们。\n为此，我也希望对互联网进行力所能及的微小回馈。我将在这个网站分享我所有的读书笔记，希望我的资料可以帮助到对相关领域同样感兴趣的朋友们。另外，欢迎您通过网站内所提供的任何途径联系我，希望我们之间可能存在的沟通能够为您带来一些帮助。\n3.关于本人的联系方式 您可以通过邮箱和知乎联系我：\nQQ mail: chiaralee953@foxmail.com Zhihu：Chiara Lee 最后，希望您在我的网站玩的愉快。请尽情的享受探索知识的乐趣吧。\nChiara Lee Chiara Lee\n以理性审视世界，凭理想创造世界。\n社交网络\nTwitter ZhiHu @Chiara-Lee Github @Chiara-Lee ","cover":null,"tags":null,"title":"关于","url":"/about/"},{"content":"","cover":null,"tags":null,"title":"友人帐","url":"/friends/"},{"content":"网站建设部分 本网站借助了以下平台的服务，感谢这些平台慷慨的免费计划：\n1.网站框架及部署\nHugo 构建框架 Tailwind CSS 构建网站样式 Netlify 网站部署平台 ChatGPT 修复帮助、问题纠正以及资料查询(哦，等等，这个是付费的) 特别致谢：\nHugo in Action\u0026ndash;by Atishay Jain 该书为本网站建设的参考教材，网站前期的主体架构均来源于书中。在此感谢作者 Atishay Jain 的开源精神。 Atishay Jain 书作者 Github 账号 2.网站图片及文本\n圆角方 网站壁纸 Fontawesome 网站图标 重返未来1999 友人帐背景 Georgia 网站字体 [LaTeX] 网站上的 LaTeX 渲染来自\u0026quot;Hugo in Action\u0026quot;中的 api 文件，读者可以在我的 GitHub Calenton 库找到它 以上即为本网站目前引用的所有资料，关于本网站引用的教材资料，将会在 笔记 页进行特殊声明。最后，再次感谢以上资源提供者。\n","cover":null,"tags":null,"title":"引用资料致谢","url":"/reference/"}]