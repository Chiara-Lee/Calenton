[{"content":" 前言 [第 1 章 变分法] 1.1 泛函 [1.1 泛函的概念] [1.1 泛函的具体形式] 1.2 变分 [1.2 变分的概念] [1.2 变分的运算规则] [1.3 泛函导数] 1.3 泛函导数的概念 1.3 泛函导数的操作定义 1.3 计算一阶泛函导数的标准手续 [1.4 泛函极值] 1.4 泛函极值的必要条件 [1.4 欧拉拉格朗日方程] [1.4 多个变量与多元函数] [习题] [第 2 章 位形空间] [2.1 位形与时间演化] [2.1 位形] [2.1 位形空间与流形] [2.1 世界线] [2.2 广义坐标] [2.2 广义坐标的概念] [2.2 广义坐标的变换] ","cover":null,"tags":null,"title":"经典力学-高显  目录","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/catalogue/"},{"content":"2.1.1 位形 力学研究的基本问题是物理系统的时间演化。具体而言，即是要研究物理系统的“位形”随时间的演化。位形是粒子在空间中的位置这一概念的推广。简单之，**位形（configuration）**即粒子系统中各个粒子的空间位置，或者更一般的物理系统在空间中的形状、分布。\n例如，考虑 N 个粒子构成的粒子系，给出 N 个粒子的空间坐标 {x_1, x_2, \\dots, x_N} 即给出粒子系的一个位形。又例如，琴弦振动的形状，即是琴弦的位形；鼓面弯曲的形状，即是鼓面的位形。\n位形的概念可以推广至连续系统和非机械系统。例如，描述气体扩散，给出空间中每一点气体分子数密度 \\rho(x) ，即给出气体的位形。描述热传导，给出空间中每一点的局域温度 T(x) ，即给出温度的位形。描述电磁场，给出空间中每一点的矢量 E(x) ，即给出电场的位形。\n2.1.2 位形空间与流形 系统所有可能位形的集合，就构成位形空间（configuration space）。位形空间中的一点，即代表系统的一种可能的位形。\n例如，在水平面上运动的粒子，其位形即水平面上的点，其位形空间即水平面；限制在圆环上运动的粒子，其位形即圆环上的点，其位形空间即整个圆环；限制在球面上运动的粒子，其位形即球面上的点，其位形空间就是整个球面。\n一般来说，物理系统的位形空间一般都不是平坦的线性空间（矢量空间）。例如，球面是一个二维空间，但显然不是平坦的。但是，球面局部的一个小块，看上去又和二维平面很像。数学上对于这种一般的空间的描述，即所谓流形（manifold）理论。简单之，流形即局部看起来像是平坦空间的东西，但是其一般是弯曲的，往往还是具有很复杂的结构。数学上“空间”一词经常特指线性空间，因此位形流形（configuration manifold）是更确切的称呼，不过本书一般仍然用物理上习惯的“位形空间”一词。\n2.1.3 世界线 现在考虑时间演化。随着时间参数 t 的变化，系统在位形空间中连续地由一点（某个位形）移动到另一点，所“扫出”的曲线即位形空间中的轨迹。把“时间”这一维加进来，可以认为“位形空间”和“时间轴”合在一起构成更大的空间。\n随着时间的演化，位形空间中的点在这个空间中也扫出一条连续的曲线，有时被称作世界线（world line），如图 2.1 所示。因为某一时刻的位形本身不能唯一决定此前或此后的位形，所以世界线是可以相交的，如图 2.1 中 A 点和 B 点。\n","cover":null,"tags":["经典力学"],"title":"2.1 位形和时间演化","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/2.1/"},{"content":"2.2.1 广义坐标的概念 坐标无非是某种空间的参数化，即只要给定一组数，能够唯一确定空间中的一点，就可以称这组数为“坐标”。例如，通常的 3 维空间中的点粒子，我们可以采用直角坐标 \\{x, y, z\\} ，柱坐标 \\{r, \\phi, z\\} ，球坐标 \\{r, \\theta, \\phi\\} 等来参数化其位置。点粒子在空间中的位置的参数化是普通坐标，而位形是点粒子位置概念的推广，自然而然，对位形空间的参数化即广义坐标（generalized coordinates），其是任何一组能够唯一确定系统某个位形的独立参数。这些概念的推广可以总结如下：\n物理系统 s 个独立的广义坐标：\n\\boxed{\\{q^1, \\cdots, q^s\\} \\equiv \\{q^a\\}, \\quad a = 1, 2, \\cdots, s} \\tag{2.1} 代表位形空间中的一点，即代表系统某个唯一确定的位形。因此，\n\\text{位形空间的维数} = \\text{独立广义坐标的个数}. \\tag{2.2} 此处的重点在于，独立广义坐标 的个数即为位形空间的维数。\n广义坐标是用于描述系统状态的一组参数。独立的广义坐标指的是相互之间不受约束的那些参数。例如，在一个无约束的粒子系统中，每个粒子的三个位置坐标 (x,y,z) 都是独立的。然而，如果系统中有约束（如两粒子用一根固定长度的杆连接），那么它们的坐标之间会存在关系，使得一些坐标不再独立。\n位形空间的维数等于描述系统状态所需的独立广义坐标的个数。这是因为每个独立广义坐标提供一个自由度。如果一个系统有 n 个自由度，就意味着它的位形空间是 n 维的。例如：\n一个三维空间中的点粒子，其位形空间是三维（由 x, y, z 描述）。 一个三维刚体（不考虑形变）有 6 个自由度，其位形空间是六维（3 个平移 + 3 个旋转参数）。 我们在知乎上回答的问题 为什么广义坐标个数和自由度不一样? 则是将减少维数的约束类型具体的讨论的出来，但其实归根结底，位形空间的维数和广义坐标的关系就是上面这句简单的\n\\text{位形空间的维数} = \\text{独立广义坐标的个数}. 广义坐标只是位形空间的参数化，所以选择非常任意。原则上，广义坐标的选取有无限多种。广义坐标的量纲不一定是长度量纲，一般也不能三个（或者多个）一组合成一个矢量，这也是位形空间一般不是线性空间的反映。例如，球面不是平坦的线性空间，球面坐标 \\{\\theta, \\phi\\} 也不是任何矢量的分量。\n2.2.2 广义坐标的变换 从概念上来说，广义坐标是对位形空间的参数化，我们当然有选取不同参数化的自由。从技术上来说，一组广义坐标下复杂的运动方程，换成另一组广义坐标经常就变得容易求解。例如，球对称引力场中粒子的运动，运动方程在球坐标下就比在直角坐标下要简单得多。\n现在假设有两组广义坐标 \\{\\boldsymbol{q}\\} 1和 \\{\\tilde{\\boldsymbol{q}}\\} ，描述同一个位形空间。考虑此位形空间中的任意某点 P （给定的位置），对应 \\{\\boldsymbol{q}\\} 坐标的数值记作 \\boldsymbol{q}|_P ， \\{\\tilde{\\boldsymbol{q}}\\} 坐标的数值记作 \\tilde{\\boldsymbol{q}}|_P 。两组坐标的数值满足函数关系：\n\\tilde{q}^a \\big|_P = f^a \\left( t, \\boldsymbol{q} \\big|_P \\right), \\quad a = 1, \\cdots, s. \\tag{2.3} 1. 广义坐标不是矢量分量的原因\n非线性性：广义坐标的定义通常是基于系统的物理状态，而它们可能受复杂的非线性约束。例如，刚体的转动角度（如欧拉角）本质上是非线性的，不能像欧几里得空间中的矢量那样简单地加法、标量乘法。\n量纲多样性：广义坐标的不同分量可能具有不同的量纲。例如，一个刚体的广义坐标可能包括位置坐标（具有长度量纲）和角度（无量纲或弧度量纲）。在这种情况下，不同分量无法以矢量的方式合成。\n坐标系统依赖：广义坐标与具体选定的坐标系统有关，而这些坐标可能是曲线坐标系中的坐标（如极坐标、球坐标），这些系本身并不满足矢量空间的性质。\n这意味着，尽管书中用广义坐标 \\boldsymbol{q} 表示一个集合，但其本质上不是一个矢量，而只是用于描述位形空间状态的参数集合。 2. (2.3) 式的分量化分析是否适用？\n公式 (2.3) 给出了一组函数关系：\n\u003e \\tilde{q}^a \\big|_P = f^a \\left( t, \\boldsymbol{q} \\big|_P \\right), \\quad a = 1, \\ldots, s. \u003e 可以尝试用“分量”的思路理解，但需要注意以下几点：\n(a) 分量的意义\n\\tilde{q}^a 是描述位形空间中状态的一个变量。它确实类似于“分量”，但由于位形空间并非线性空间，我们不能将这些“分量”看作传统意义上的几何矢量分量。 这意味着，我们可以从数学上把 \\tilde{q}^a 当作一个映射结果的单独输出，但它们之间并没有简单的矢量结构关系。 (b) 函数关系的非线性性\nf^a \\left( t, \\boldsymbol{q}|_P \\right) 是一个一般的非线性函数。因此，虽然我们可以从广义坐标的集合 \\boldsymbol{q}|_P = \\{q^1, q^2, \\ldots, q^s\\} 中提取每个变量的单独分量，但这些分量通过 f^a 映射后的关系可能非常复杂。 这种非线性性进一步说明了，广义坐标的“分量”并不是简单的线性加和的构造。 3. 如何重新理解式子 (2.3) 在公式 (2.3) 的框架下，我们可以用以下方式重新审视分量的概念：\n\\boldsymbol{q} 是广义坐标的集合，它本质上是一个参数化集合，而不是矢量。\n每个 q^a 可以看作广义坐标在某个维度上的“变量”，但这些变量不能简单地组合为矢量分量。\n\\tilde{q}^a 是通过映射函数 f^a(t, \\boldsymbol{q}) 从原始广义坐标中变换得到的变量。同样，它不是矢量的分量，而是描述状态的一个独立变量。\n因为 P 是任意一点，所以即有坐标之间的关系 \\tilde{q}^a = f^a(t, \\boldsymbol{q}) 。一般来说，变换可以显含时间参数 t ，即在不同时刻有不同的变换关系。习惯上用 \\tilde{q}^a 本身作为变换的函数名，即写成\n\\boxed{q^a \\longrightarrow \\tilde{q}^a = \\tilde{q}^a(t, \\boldsymbol{q}), \\quad a = 1, \\cdots, s}. \\tag{2.4} 这种广义坐标之间的变换也被称作点变换（point transformation），因为其将 \\{\\boldsymbol{q}\\} 坐标描述的点，变换到用 \\{\\tilde{\\boldsymbol{q}}\\} 描述的点。我们要求变换式 (2.4) 是可逆的，换句话说存在\n\\tilde{q}^a \\longrightarrow q^a = q^a(t, \\tilde{\\boldsymbol{q}}), \\quad a = 1, \\cdots, s. \\tag{2.5} 也就是说 \\{\\boldsymbol{q}\\} 和 \\{\\tilde{\\boldsymbol{q}}\\} 是一一对应的 2。可逆性要求坐标变换的雅可比行列式非零，即\n\\det\\left( \\frac{\\partial \\tilde{q}^a}{\\partial q^b} \\right) \\neq 0. \\tag{2.6} 注意， \\frac{\\partial \\tilde{q}^b}{\\partial q^c} 的逆即 \\frac{\\partial q^a}{\\partial \\tilde{q}^b} ，满足\n\\sum_{b=1}^s \\frac{\\partial q^a}{\\partial \\tilde{q}^b} \\frac{\\partial \\tilde{q}^b}{\\partial q^c} = \\frac{\\partial q^a}{\\partial q^c} \\equiv \\delta^a_c, \\tag{2.7} 这里 \\delta_c^a 为克罗内克符号，取值当 a = c 时为 1， a \\neq c 时为 0。\n坐标变换有两种等价的观点，或者说对 \\{\\boldsymbol{q}\\} \\to \\{\\tilde{\\boldsymbol{q}}\\} 有两种等价的解释。一种是认为用不同的坐标描述同一点，如图 2.7(a) 所示，这种观点被称作被动观点（passive point of view），即“对象不变，坐标在变”。上面我们即采用这种观点，这时 \\{\\boldsymbol{q}\\} ** 和 ** \\{\\tilde{\\boldsymbol{q}}\\} 是同一位形空间的不同参数化。\n但是换一个角度，我们总可以将变换后 \\tilde{\\boldsymbol{q}}|_P 的坐标数值对应到同一空间上的另外一点 P' ，使得 \\boldsymbol{q}|_{P'} \\equiv \\tilde{\\boldsymbol{q}}|_P 。也就是说我们总是可以将坐标变换重新解释为将同一空间上一点变换到另外一点，如图 2.7(b) 所示。这种观点被称作主动观点（active point of view），即“坐标不变，对象在变”。\n坐标变换的被动观点和主动观点是等价且相对的，孰有便利，需要根据具体问题选择使用。\n简洁起见，本书中经常用黑体字母代表一组多个变量，例如 \\boldsymbol{q} = \\{q^a\\} = \\{q^1, \\cdots, q^s\\} ，等等。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n数学上管这种一一对应且可微的关系叫\u0026quot;微分同胚\u0026quot; (diffeomorphism).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":["经典力学"],"title":"2.2 广义坐标","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/2.2/"},{"content":"a.一般性质 我们在这里总结数列的一组性质，但将来可以看到，这些性质并非数列所独有。只取一个值的数列称为常数列。\n定义 4. 数列 \\{x_n\\} 称为 最终常数列，如果存在数 A 与序号 N ，使得对于任意 n \u003e N ，均有 x_n = A 。\n1. ε-接近性 (ε-approximation)：\n定义 4.3.4 中表述的是：给定 \\epsilon \u003e 0 ，两个实数 x, y 当 |x - y| \\leq \\epsilon 时称为 ε-接近的。\n这一层面只有两点之间的距离概念，是最基本的“接近”定义。\n2. ε-稳定性 (ε-stability)：\n定义 5.1.3 中谈到序列 (a_n)_{n=0}^\\infty 的 ε-稳定。序列是 ε-稳定的，意味着该序列中的任意两个元素 a_j, a_k （无论下标多大），都有 |a_j - a_k| \\leq \\epsilon 。\n换句话说，一个 ε-稳定的序列整体上“被压缩在一个 ε-宽度的间隔中”。不仅仅是相邻项或者后期的项接近，而是整数序列的任意两项都足够接近。这是一个很强的条件，通常只有非常特殊的序列才能全局达到这一点（例如常数序列）。\n注意：ε-稳定性并没有提及“从某项开始”或“最终”这种概念，它是对整个序列的要求。\n3. 最终ε-稳定性 (eventual ε-stability)：\n定义 5.1.6 提到了最终 ε-稳定的概念。一个序列最终 ε-稳定是指：存在某个 N 使得序列从第 N 项开始（即尾部子序列 a_N, a_{N+1}, a_{N+2}, \\dots ）是 ε-稳定的。\n这和上一个定义的差别在于，上一个定义要求整数序列对任意两项都接近，这里则放宽为：前面几项不管，但从某一个固定起点之后，序列的尾部内部达到 ε-稳定。\n换言之，“最终ε-稳定”说的是：虽然序列开始可能比较散，但在序列走得够远之后，其任意两项都挤在一条宽度为 \\epsilon 的间隔中。这个概念实际上与 Cauchy 序列 的定义很接近：Cauchy 序列要求对任意 \\epsilon ，都有这样一个 N ，使得 N 后的所有两项都很接近。\nTao 的逻辑梯度：\n首先定义点与点之间的 ε-接近性，从而获得一个度量空间中的基本接近概念。 接着将该概念推广到序列上，看序列全局是否 ε-稳定，这是一个强烈的条件，但有助于理解“接近”是如何在无限集合（序列的值集）中推广。 最后放宽要求到“最终 ε-稳定”，这里接近序列逼近某个值的本质概念，虽然这里还没有直接引入一个具体的极限点 A ，但是要求从某项之后序列内部各项间越来越接近，已经为 Cauchy 序列 与极限定义铺平了道路。 最终常数列 vs. 最终ε-稳定：\n最终ε-稳定性 (eventual ε-stability) 要求的是，从某个 N 开始，序列中任意两项的差都不超过 \\epsilon 。换句话说，序列的尾部所有项都挤在一个 \\epsilon -长度的区间中，但它们不一定是完全相等的。 最终常数列要求从某个 N 开始，序列中所有后继项都完全等于某个固定数 A ，也就是尾部部分不但靠得很近，而是完全重合在一个点上。 最终常数列是一种特别强的最终ε-稳定性：如果从 N 开始所有项都等于 A ，那么显然它们任意两项之间的距离为 0，不管 \\epsilon 多小，都轻松满足最终ε-稳定性。这说明最终常数列是最终ε-稳定序列的一种特殊情况，且是最强的一种，因为你不用控制 \\epsilon 的大小，序列尾部都已经缩成了一个点。\n与极限的关系：\n一个最终常数列对任何给定的 A 来说，都显然有极限 A 。而且它比有极限还要强烈：从某项以后，序列根本没有变化。\n而最终ε-稳定性只是保证了序列后半段的内部紧凑性，但不一定指向某个固定的极限值，也不要求序列像常数列那样凝固在一个点上。最终ε-稳定性是走向极限存在的中间概念之一，如果在收敛序列的定义中引入一个候选极限值，那么最终ε-稳定性加上序列接近该值才能给出极限定义。\n而前文开头给出的数列极限定义（邻域版）就满足了以上的这些条件：数列中所有序号大于 N 的项都包含在点 A 的邻域 V(A) 中。\nn\u003eN 时所有项都落在邻域内，这保证了后半段内部的紧凑性。 包含在点 A 的邻域 V(A) 中，这表明存在一个确定的极限值。 因此，这就是我们需要的极限定义。\n但是请注意，一个数列收敛到极限 A 的定义并没有要求数列的项只在 A 的一侧趋近 A ，也没有要求数列的项永远不会“越过” A 所在的位置。在数轴上，接近 A 是一个关于距离的概念，而不是关于朝向的概念。也就是说，当我们谈论 |x_n - A| \u003c \\epsilon 时，我们指的是 x_n 距离 A 很小，而不管 x_n 比 A 大还是小。\n让我们更系统地来看：\n1. 极限定义的中立性（不关心方向）：\n定义中说：“对于点 A 的任意邻域 V(A) ——如果我们在实数轴上用 \\epsilon -邻域来表达它，那么是对于任意 \\epsilon \u003e 0 ，存在 N 使得当 n \u003e N 时， |x_n - A| \u003c \\epsilon 。”\n这个不等式对 x_n 是对称的，它只要求 x_n 距离 A 的绝对值小于 \\epsilon ，并没有要求 x_n \\leq A 或 x_n \\geq A 。\n因此， x_n 可以在 A 左右两侧来回晃动，只要它最终都进入那个越来越小的区间，就满足极限定义。\n2. 越过极限值的直观解释：\n当你想到“越过 A ”时，你可能有一种单方向的想法：数列像是朝着 A 前进，然后“超越”了 A 再从另一边逼近。实际上，这非常正常。例如，考虑数列 x_n = A + \\frac{(-1)^n}{n} 。\n当 n 是偶数时， x_n 在 A 的左侧稍微高于 A 。 当 n 是奇数时， x_n 在 A 的左侧稍微低于 A 。 随着 n 增大，这个数列的项逐渐围绕 A 摆动，但振幅变得越来越小。\n虽然它不断“越过” A ，一会儿比 A 大，一会儿比 A 小，但最终所有项都会在任意小的区间内围绕 A 摆动。这没有违背极限定义，反而很好地体现了极限定义的宽泛性：极限只在乎最终距离是否足够小，而不在乎你是从左逼近还是从右逼近，或是否“越过”。\n3. 极限的内涵\n极限的哲学内涵是关于潜在无穷性的：“可以无限接近而不一定要真正等于”。数列本身也不要求最终停在 A 上。实际上，数列项可以有无数次穿过 A 的点，也可以一次都不等于 A ——极限只管当 n 越来越大时， x_n 与 A 的距离能否变得任意小。\n在极限定义中，关键是对于任意的 \\epsilon 都能在足够大的 N 后实现 |x_n - A| \u003c \\epsilon 。“越过”只是表示数列的项出现在 A 的上方，有时在下方，但足够大的 n ，无论在上方还是下方，数列始终被压缩在任意小的间隔内（两边都接近 A ）。这种逻辑上完全成立，而不需要数列保持单调或不超越。\n实际上，当数列项越过极限的时候，即使确实发生了“触碰”，那也是完全不违背极限的定义的，因为，这只是表明数列项与极限之间的距离为零，二者发生了重合，它们的距离仍然是任意小的（事实上，它们之间没有距离），因此，最终常数列是有极限的。\n定义 5. 数列 \\{x_n\\} 称为 有界数列，如果存在数 M ，使得对于任意 n \\in \\mathbb{N} ，均有 |x_n| \u003c M 。\n定理 1.\na) 最终常数列收敛。 b) 数列极限的任何一个邻域都包含数列中为数有限的项之外的所有项。 c) 数列不可能有两个不同的极限。 d) 收敛数列有界。 证明：\na) 如果当 n \u003e N 时 x_n = A ，则对于点 A 的任何一个邻域 V(A) ，当 n \u003e N 时 x_n \\in V(A) ，即 \\lim_{n \\to \\infty} x_n = A 。\nb) 此结论直接得自数列极限的定义。\nc) 这是定理的重点。设 \\lim_{n \\to \\infty} x_n = A_1 ， \\lim_{n \\to \\infty} x_n = A_2 。假如 A_1 \\neq A_2 ，我们就选定点 A_1, A_2 的两个不相交的邻域 V(A_1), V(A_2) 。\n例如，可以在 \\delta \u003c |A_1 - A_2| / 2 时取这两个点的 \\delta 邻域。根据极限的定义，可以求出序号 N_1 和 N_2 ，使得 \\forall n \u003e N_1 (x_n \\in V(A_1)) 且 \\forall n \u003e N_2 (x_n \\in V(A_2)) 。于是，当 n \u003e \\max{N_1, N_2} 时，我们得到 x_n \\in V(A_1) \\cap V(A_2) 。但这是不可能的，因为 V(A_1) \\cap V(A_2) = \\varnothing 。\nd) 设 \\lim_{n \\to \\infty} x_n = A 。如果在极限的定义中取 \\epsilon = 1 ，就可以求出 N ，使得 \\forall n \u003e N (|x_n - A| \u003c 1) 。这意味着，当 n \u003e N 时有 |x_n| \u003c |A| + 1 。如果现在取 M \u003e \\max {|x_1|, |x_2|, \\dots, |x_n|, |A| + 1}, 就得到 \\forall n (x_n \u003c M) 。\nb.极限过程和算术运算 定义 6.(数列的算术运算) 如果数列 \\{x_n\\}, \\{y_n\\} 是两个数列，则数列\n\\{(x_n + y_n)\\}, \\{(x_n y_n)\\}, \\left\\{\\frac{x_n}{y_n}\\right\\} 分别称为这两个数列的和、积与商（与函数的和、积与商的一般定义一致）。\n当然，商仅在 y_n \\neq 0, \\ n \\in \\mathbb{N} 时才有定义。\n定理 2. 设 \\{x_n\\}, \\{y_n\\} 是数列。如果 \\lim_{n \\to \\infty} x_n = A ， \\lim_{n \\to \\infty} y_n = B ，则\na) \\lim_{n \\to \\infty} (x_n + y_n) = A + B ； b) \\lim_{n \\to \\infty} x_n \\cdot y_n = A \\cdot B ； c) 当 y_n \\neq 0 \\ (n = 1, 2, \\cdots) 且 B \\neq 0 时 \\lim_{n \\to \\infty} \\frac{x_n}{y_n} = \\frac{A}{B} 。 证明：\n我们已经知道如何在近似值的算术运算中估计绝对误差（见第二章 §2 第 4 小节）。作为练习，我们来运用这些估计。\n令 |A - x_n| = \\Delta(x_n), \\ |B - y_n| = \\Delta(y_n) 则对于 a)，我们有：\n|(A + B) - (x_n + y_n)| \\leq \\Delta(x_n) + \\Delta(y_n). 此处使用了 三角不等式 （Triangle Inequality）的性质：\n对于实数（或更一般的度量空间）中的任意两个数 u 和 v ，有：\n\u003e |u + v| \\leq |u| + |v|. \u003e 在这个例子中，将 u = (A - x_n) 和 v = (B - y_n) ，则有：\n\u003e |(A - x_n) + (B - y_n)| \\leq |A - x_n| + |B - y_n|. \u003e 因此得到不等式：\n\u003e |(A + B) - (x_n + y_n)| \\leq |A - x_n| + |B - y_n|. \u003e 之所以是“小于等于”而非“等于”，是因为三角不等式的典型形式就是不等式，而不等式只有在特定的情况下（例如 u 和 v 同向且为非负实数时）才会退化为等式。对于绝大多数情况，这仅能保证一个“不超过”的关系，而不是严格的等价关系。\n设数 \\varepsilon \u003e 0 是给定的。因为 \\lim_{n \\to \\infty} x_n = A ，所以可以找到序号 N' ，使得 \\forall n \u003e N' \\ (\\Delta(x_n) \u003c \\varepsilon / 2) 。类似地，因为 \\lim_{n \\to \\infty} y_n = B ，所以可以找到序号 N'' ，使得 \\forall n \u003e N'' \\ (\\Delta(y_n) \u003c \\varepsilon / 2) 。\n于是，当 n \u003e \\max\\{N', N''\\} 时，我们有：\n|(A + B) - (x_n + y_n)| \u003c \\varepsilon. 根据极限的定义，这就证明了命题 a)。\nb) 我们知道，\n|A \\cdot B - x_n \\cdot y_n| \\leq |x_n| \\Delta(y_n) + |y_n| \\Delta(x_n) + \\Delta(x_n) \\cdot \\Delta(y_n). 推导过程：\n1. 开始表达式：\n我们想要给出 |A \\cdot B - x_n \\cdot y_n| 的上界。\n2. 因式分解：\n将 A \\cdot B - x_n \\cdot y_n 分解为易于处理的多项式形式。可以写成：\n\u003e A \\cdot B - x_n \\cdot y_n = (A - x_n)(B - y_n) + x_n(B - y_n) + y_n(A - x_n). \u003e 这一步是关键，它使得后续应用三角不等式更为直接。\n3. 应用三角不等式：\n对上述取绝对值，并使用三角不等式 |u + v + w| \\leq |u| + |v| + |w| ：\n\u003e |A \\cdot B - x_n \\cdot y_n| \\leq |(A - x_n)(B - y_n)| + |x_n(B - y_n)| + |y_n(A - x_n)|. \u003e 4. 替换记号与进一步估计：\n已知 |A - x_n| = \\Delta(x_n) 且 |B - y_n| = \\Delta(y_n) 。因此：\n\u003e |(A - x_n)(B - y_n)| = |A - x_n||B - y_n| = \\Delta(x_n)\\Delta(y_n). \u003e 同时：\n\u003e |x_n(B - y_n)| = |x_n|\\Delta(y_n), \\quad |y_n(A - x_n)| = |y_n|\\Delta(x_n). \u003e 将这些代入上式得到：\n\u003e |A \\cdot B - x_n \\cdot y_n| \\leq |x_n|\\Delta(y_n) + |y_n|\\Delta(x_n) + \\Delta(x_n)\\Delta(y_n). \u003e 对于给定的 \\varepsilon \u003e 0 ，可以求出序号 N' 和 N'' ，使得\n\\forall n \u003e N' \\quad \\left( \\Delta(x_n) \u003c \\min \\left{ 1, \\frac{\\varepsilon}{3(|B| + 1)} \\right} \\right), \\forall n \u003e N'' \\quad \\left( \\Delta(y_n) \u003c \\min \\left{ 1, \\frac{\\varepsilon}{3(|A| + 1)} \\right} \\right). 于是，当 n \u003e N = \\max{N', N''} 时，我们有\n|x_n| \u003c |A| + \\Delta(x_n) \u003c |A| + 1, |y_n| \u003c |B| + \\Delta(y_n) \u003c |B| + 1, \\Delta(x_n) \\cdot \\Delta(y_n) \u003c \\min \\left{ 1, \\frac{\\varepsilon}{3} \\right} \\cdot \\min \\left{ 1, \\frac{\\varepsilon}{3} \\right} \u003c \\frac{\\varepsilon}{3}. 因此，当 n \u003e N 时，\n|x_n| \\Delta(y_n) \u003c (|A| + 1) \\cdot \\frac{\\varepsilon}{3(|A| + 1)} = \\frac{\\varepsilon}{3}, |y_n| \\Delta(x_n) \u003c (|B| + 1) \\cdot \\frac{\\varepsilon}{3(|B| + 1)} = \\frac{\\varepsilon}{3}, \\Delta(x_n) \\cdot \\Delta(y_n) \u003c \\frac{\\varepsilon}{3}, 所以，当 n \u003e N 时， |AB - x_n y_n| \u003c \\varepsilon. 可见最初设定 \\frac{\\varepsilon}{3(|B| + 1)} 时，就是为了分母能与 |B| + 1 粤曲，以凑出 \\frac{\\varepsilon}{3} ，而在 \\Delta(x_n) \\cdot \\Delta(y_n) 中直接取其小于 \\min \\left{ 1, \\frac{\\varepsilon}{3} \\right} \\cdot \\min \\left{ 1, \\frac{\\varepsilon}{3} \\right} 而忽略之前的复杂分母，也是为了凑出 \\frac{\\varepsilon}{3} 。\nc) 我们利用估计\n\\left| \\frac{A}{B} - \\frac{x_n}{y_n} \\right| \\leq \\frac{|x_n| \\Delta(y_n) + |y_n| \\cdot \\Delta(x_n)}{y_n^2} \\cdot \\frac{1}{1 - \\delta(y_n)}, 其中 \\delta(y_n) = \\Delta(y_n)/|y_n| 。\n过程\n设 x = \\tilde{x} + \\alpha, y = \\tilde{y} + \\beta ，则\n\u003e \\Delta \\left( \\frac{\\tilde{x}}{\\tilde{y}} \\right) = \\left| \\frac{x}{y} - \\frac{\\tilde{x}}{\\tilde{y}} \\right| = \\left| \\frac{x \\tilde{y} - y \\tilde{x}}{y \\tilde{y}} \\right| = \\left| \\frac{(\\tilde{x} + \\alpha)\\tilde{y} - (\\tilde{y} + \\beta)\\tilde{x}}{\\tilde{y}^2} \\right| \\cdot \\left| \\frac{1}{1 + \\beta / \\tilde{y}} \\right| \u003e \u003e \\leq \\frac{|\\tilde{x}||\\beta| + |\\tilde{y}||\\alpha|}{\\tilde{y}^2} \\cdot \\frac{1}{1 - \\delta(\\tilde{y})} = \\frac{|\\tilde{x}|\\Delta(\\tilde{y}) + |\\tilde{y}|\\Delta(\\tilde{x})}{\\tilde{y}^2} \\cdot \\frac{1}{1 - \\delta(\\tilde{y})}. \u003e 对于给定的 \\varepsilon \u003e 0 ，可以求出序号 N' 和 N'' ，使得\n\\forall n \u003e N' \\quad \\left( \\Delta(x_n) \u003c \\min \\left\\{ 1, \\frac{\\varepsilon |B|}{8} \\right\\} \\right), \\forall n \u003e N'' \\quad \\left( \\Delta(y_n) \u003c \\min \\left\\{ \\frac{|B|}{4}, \\frac{\\varepsilon \\cdot B^2}{16(|A| + 1)} \\right\\} \\right). 于是，当 n \u003e N = \\max\\{N', N''\\} 时，我们有\n|x_n| \u003c |A| + \\Delta(x_n) \u003c |A| + 1, |y_n| \u003e |B| - \\Delta(y_n) \u003e |B| - \\frac{|B|}{4} \u003e \\frac{|B|}{2}, \\frac{1}{|y_n|} \u003c \\frac{2}{|B|}, \\quad 0 \u003c \\delta(y_n) = \\frac{\\Delta(y_n)}{|y_n|} \u003c \\frac{|B|/4}{|B|/2} = \\frac{1}{2}, 1 - \\delta(y_n) \u003e \\frac{1}{2}. 所以，\n|x_n| \\cdot \\frac{1}{y_n^2} \\Delta(y_n) \u003c (|A| + 1) \\cdot \\frac{4}{B^2} \\cdot \\frac{\\varepsilon B^2}{16(|A| + 1)} = \\frac{\\varepsilon}{4}, \\left| \\frac{1}{y_n} \\right| \\cdot \\Delta(x_n) \u003c \\frac{2}{|B|} \\cdot \\frac{\\varepsilon |B|}{8} = \\frac{\\varepsilon}{4}, 0 \u003c \\frac{1}{1 - \\delta(y_n)} \u003c 2. 从而，当 n \u003e N 时，\n\\left| \\frac{A}{B} - \\frac{x_n}{y_n} \\right| \u003c \\varepsilon. 本节使用等式：\n设 x = \\tilde{x} + \\alpha, y = \\tilde{y} + \\beta ，则\n\\Delta(\\tilde{x} + \\tilde{y}) = |(x + y) - (\\tilde{x} + \\tilde{y})| = |\\alpha + \\beta| \\leq |\\alpha| + |\\beta| = \\Delta(\\tilde{x}) + \\Delta(\\tilde{y}), \\Delta(\\tilde{x} \\cdot \\tilde{y}) = |xy - \\tilde{x} \\tilde{y}| = |(\\tilde{x} + \\alpha)(\\tilde{y} + \\beta) - \\tilde{x} \\tilde{y}| = |\\tilde{x} \\beta + \\tilde{y} \\alpha + \\alpha \\beta| \\leq |\\tilde{x}||\\beta| + |\\tilde{y}||\\alpha| + |\\alpha \\beta| = |\\tilde{x}|\\Delta(\\tilde{y}) + |\\tilde{y}|\\Delta(\\tilde{x}) + \\Delta(\\tilde{x}) \\cdot \\Delta(\\tilde{y}), \\Delta \\left( \\frac{\\tilde{x}}{\\tilde{y}} \\right) = \\left| \\frac{x}{y} - \\frac{\\tilde{x}}{\\tilde{y}} \\right| = \\left| \\frac{x \\tilde{y} - y \\tilde{x}}{y \\tilde{y}} \\right| = \\left| \\frac{(\\tilde{x} + \\alpha)\\tilde{y} - (\\tilde{y} + \\beta)\\tilde{x}}{\\tilde{y}^2} \\right| \\cdot \\left| \\frac{1}{1 + \\beta / \\tilde{y}} \\right| \\leq \\frac{|\\tilde{x}||\\beta| + |\\tilde{y}||\\alpha|}{\\tilde{y}^2} \\cdot \\frac{1}{1 - \\delta(\\tilde{y})} = \\frac{|\\tilde{x}|\\Delta(\\tilde{y}) + |\\tilde{y}|\\Delta(\\tilde{x})}{\\tilde{y}^2} \\cdot \\frac{1}{1 - \\delta(\\tilde{y})}. c.极限过程与不等式 定理 3.\na) 设 \\{x_n\\}, \\{y_n\\} 是两个收敛数列，并且 \\lim_{n \\to \\infty} x_n = A, \\lim_{n \\to \\infty} y_n = B. 如果 A \u003c B ，就可以求出序号 N \\in \\mathbb{N} ，使得对于任何 n \u003e N ，不等式 x_n \u003c y_n 成立。\nb) 设数列 \\{x_n\\}, \\{y_n\\}, \\{z_n\\} 满足条件：对于任何 n \u003e N \\in \\mathbb{N} ，关系式 x_n \\leq y_n \\leq z_n 成立。如果数列 \\{x_n\\}, \\{z_n\\} 这时收敛于同一个极限，则数列 \\{y_n\\} 也收敛于该极限。(迫敛定理)\na) 取数 C ，使得 A \u003c C \u003c B 。根据极限的定义，可以求出序号 N' 和 N'' ，使得对任意 n \u003e N' 都有 |x_n - A| \u003c C - A ，并且对任意 n \u003e N'' 都有 |y_n - B| \u003c B - C 。\n于是，当 n \u003e N = \\max\\{N', N''\\} 时，就得到\nx_n \u003c A + (C - A) = C = B - (B - C) \u003c y_n. 详细展开：\n根据极限的定义：\n数列 x_n \\to A ，意味着： \\forall \\epsilon \u003e 0, \\, \\exists N' \\in \\mathbb{N}, \\, \\forall n \u003e N', \\, |x_n - A| \u003c \\epsilon. 同理， y_n \\to B ，意味着： \\forall \\epsilon \u003e 0, \\, \\exists N'' \\in \\mathbb{N}, \\, \\forall n \u003e N'', \\, |y_n - B| \u003c \\epsilon. 取中间值 C ，使得 A \u003c C \u003c B ：\n设 \\epsilon_1 = C - A 和 \\epsilon_2 = B - C 。显然有 \\epsilon_1 \u003e 0 且 \\epsilon_2 \u003e 0 。 由极限定义，存在： N' \\in \\mathbb{N}, \\, \\forall n \u003e N', \\, |x_n - A| \u003c \\epsilon_1. N'' \\in \\mathbb{N}, \\, \\forall n \u003e N'', \\, |y_n - B| \u003c \\epsilon_2. 将绝对值不等式转换为上下界形式：\n|x_n - A| \u003c \\epsilon_1 等价于： A - \\epsilon_1 \u003c x_n \u003c A + \\epsilon_1. 其中 \\epsilon_1 = C - A ，所以： A - (C - A) \u003c x_n \u003c A + (C - A). 进一步化简为： x_n \u003c C \\quad (\\text{因为 } A + (C - A) = C). 同理， |y_n - B| \u003c \\epsilon_2 等价于： B - \\epsilon_2 \u003c y_n \u003c B + \\epsilon_2. 其中 \\epsilon_2 = B - C ，所以： B - (B - C) \u003c y_n \u003c B + (B - C). 进一步化简为： y_n \u003e C \\quad (\\text{因为 } B - (B - C) = C). 合并两个结果：\n当 n \u003e N = \\max\\{N', N''\\} 时， x_n 和 y_n 同时满足： x_n \u003c C \\quad \\text{且} \\quad y_n \u003e C. 因此： x_n \u003c C \u003c y_n. 这就严格证明了对于充分大的 n ，必然有 x_n \u003c y_n 。\nb) 设 \\lim_{n \\to \\infty} x_n = \\lim_{n \\to \\infty} z_n = A 。由 \\varepsilon \u003e 0 求出序号 N' 和 N'' ，使得对于任意 n \u003e N' 都有 A - \\varepsilon \u003c x_n ，对于任意 n \u003e N'' 都有 z_n \u003c A + \\varepsilon 。\n于是，当 n \u003e N = \\max\\{N', N''\\} 时，我们得到\nA - \\varepsilon \u003c x_n \\leq y_n \\leq z_n \u003c A + \\varepsilon, 即 |y_n - A| \u003c \\varepsilon ，从而 A = \\lim_{n \\to \\infty} y_n 。\n详细展开：\n根据极限的定义：\n数列 x_n \\to A 意味着：\n\\forall \\epsilon \u003e 0, \\, \\exists N' \\in \\mathbb{N}, \\, \\forall n \u003e N', \\, |x_n - A| \u003c \\epsilon. 这等价于：\nA - \\epsilon \u003c x_n \u003c A + \\epsilon. 数列 z_n \\to A 意味着：\n\\forall \\epsilon \u003e 0, \\, \\exists N'' \\in \\mathbb{N}, \\, \\forall n \u003e N'', \\, |z_n - A| \u003c \\epsilon. 这等价于：\nA - \\epsilon \u003c z_n \u003c A + \\epsilon. 结合夹逼条件：\n由 x_n \\leq y_n \\leq z_n ，当 n \u003e N = \\max\\{N', N''\\} 时，有：\nA - \\epsilon \u003c x_n \\leq y_n \\leq z_n \u003c A + \\epsilon. 推出 y_n 的极限：\n由上述不等式可以看出：\nA - \\epsilon \u003c y_n \u003c A + \\epsilon. 这等价于：\n|y_n - A| \u003c \\epsilon. 由于 \\epsilon \u003e 0 是任意给定的，满足此条件的 y_n 必然收敛于 A ，即：\n\\lim_{n \\to \\infty} y_n = A. 推论\n设 \\lim_{n \\to \\infty} x_n = A ， \\lim_{n \\to \\infty} y_n = B 。如果存在序号 N ，使得对于任何 n \u003e N 都有\ny_n = B 时的特殊情况。\na) 若 x_n \u003e y_n ，则 A \\geq B ； b) 若 x_n \\geq y_n ，则 A \\geq B ； c) 若 x_n \u003e B ，则 A \\geq B ； d) 若 x_n \\geq B ，则 A \\geq B 。 说明： 用反证法，从定理 3 a) 立即得到推论 a) 和 b)。后两个推论是前两个推论在 y_n \\equiv B 时的特殊情况。\n注： 应当指出，严格不等式在求极限后可能变成等式。例如，对于任何 n \\in \\mathbb{N} 都有 1 / n \u003e 0 ，但 \\lim_{n \\to \\infty} 1 / n = 0. ","cover":null,"tags":["数学分析"],"title":"3.1.2  数列极限的性质","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/3.1.2/"},{"content":"1.1 单元泛函（即只有一个函数为变量的泛函）的欧拉拉格朗日方程常规求解 给定 f(t) 的泛函 S[f] ：\nS[f] = - \\int \\mathrm{d}t \\, e^{-\\Phi(f)} \\sqrt{1 - f'^2}, 其中 \\Phi 是 f 的任意函数。求 S[f] 取极值时， f(t) 的欧拉-拉格朗日方程。\n解：\n首先对 \\mathcal{L} 关于 f 的偏导数：\n\\mathcal{L}(f, f') = -e^{-\\Phi(f)} \\sqrt{1 - f'^2}. 注意 \\sqrt{1 - f'^2} 不显含 f ，而 e^{-\\Phi(f)} 对 f 的导数为：\n\\frac{d}{df} e^{-\\Phi(f)} = e^{-\\Phi(f)} (-\\Phi'(f)). 因此：\n\\frac{\\partial \\mathcal{L}}{\\partial f} = - \\left[ e^{-\\Phi(f)} (-\\Phi'(f)) \\sqrt{1 - f'^2} \\right] = e^{-\\Phi(f)} \\Phi'(f) \\sqrt{1 - f'^2}. 现在对 \\mathcal{L} 关于 f' 的偏导：\n\\mathcal{L}(f, f') = -e^{-\\Phi(f)} \\sqrt{1 - f'^2}. 对 f' 求导时，仅 \\sqrt{1 - f'^2} 部分相关：\n\\frac{d}{df'} \\sqrt{1 - f'^2} = \\frac{-f'}{\\sqrt{1 - f'^2}}. 因此：\n\\frac{\\partial \\mathcal{L}}{\\partial f'} = - e^{-\\Phi(f)} \\left( \\frac{-f'}{\\sqrt{1 - f'^2}} \\right) = e^{-\\Phi(f)} \\frac{f'}{\\sqrt{1 - f'^2}}. 2. 计算 \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{\\partial \\mathcal{L}}{\\partial f'}\\right) 对于 \\frac{\\partial \\mathcal{L}}{\\partial f'} = e^{-\\Phi(f)}\\frac{f'}{\\sqrt{1-f'^2}} ，对 t 求导：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f'} \\right) = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( e^{-\\Phi(f)} \\frac{f'}{\\sqrt{1-f'^2}} \\right). 使用乘法法则：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( e^{-\\Phi(f)} \\right) \\cdot \\frac{f'}{\\sqrt{1-f'^2}} + e^{-\\Phi(f)} \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{f'}{\\sqrt{1-f'^2}} \\right). 首先：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} e^{-\\Phi(f)} = e^{-\\Phi(f)} (-\\Phi'(f))f'. 因此：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( e^{-\\Phi(f)} \\frac{f'}{\\sqrt{1-f'^2}} \\right) = e^{-\\Phi(f)} (-\\Phi'(f))f' \\cdot \\frac{f'}{\\sqrt{1-f'^2}} + e^{-\\Phi(f)} \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{f'}{\\sqrt{1-f'^2}} \\right). 简化第一项：\ne^{-\\Phi(f)}(-\\Phi'(f))\\frac{f'^2}{\\sqrt{1-f'^2}}. 接着计算 \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{f'}{\\sqrt{1-f'^2}}\\right) 。\n令 g = \\frac{f'}{\\sqrt{1-f'^2}} ，则：\ng = \\frac{f'}{\\sqrt{1-f'^2}}. 对 t 求导：\ng' = \\frac{f''\\sqrt{1-f'^2} - f'\\frac{f'f''}{\\sqrt{1-f'^2}}}{1-f'^2} \\quad (\\text{经过仔细化简}). 实际上，一种更简便的方法是记 \\sqrt{1-f'^2} = h ，则 g = \\frac{f'}{h} 。\ng' = \\frac{f''h - f'(-f'f''/h)}{h^2}. 又有：\nh = \\sqrt{1-f'^2}, \\quad h' = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\sqrt{1-f'^2} = \\frac{-f'f''}{\\sqrt{1-f'^2}} = -\\frac{f'f''}{h}. 所以：\ng' = \\frac{f''h - f'(-f'f''/h)}{h^2} = \\frac{f''h + \\frac{f'^2f''}{h}}{h^2} = \\frac{f''h^2 + f'^2}{h^3}. 但 h^2 = 1-f'^2 ，所以 h^2 + f'^2 = 1 ：\ng' = \\frac{f''}{h^3} = \\frac{f''}{(1-f'^2)^{3/2}}. 因此：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{f'}{\\sqrt{1 - f'^2}} \\right) = \\frac{f''}{(1 - f'^2)^{3/2}}. 代回去：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f'} \\right) = e^{-\\Phi(f)} \\left( -\\Phi'(f) \\right) \\frac{f'^2}{\\sqrt{1 - f'^2}} + e^{-\\Phi(f)} \\frac{f''}{(1 - f'^2)^{3/2}}. 将其代入欧拉-拉格朗日方程：\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f'} \\right) - \\frac{\\partial \\mathcal{L}}{\\partial f} = 0. 即：\ne^{-\\Phi(f)} \\left( -\\Phi'(f) \\frac{f'^2}{\\sqrt{1 - f'^2}} + \\frac{f''}{(1 - f'^2)^{3/2}} \\right) - e^{-\\Phi(f)} \\Phi'(f) \\sqrt{1 - f'^2} = 0. 可提取公因子 e^{-\\Phi(f)} （其非零）：\n-\\Phi'(f) \\left( \\frac{f'^2}{\\sqrt{1 - f'^2}} + \\sqrt{1 - f'^2} \\right) + \\frac{f''}{(1 - f'^2)^{3/2}} = 0. 将与 \\Phi'(f) 有关的项合并：\n-\\Phi'(f) \\left( \\frac{f'^2}{\\sqrt{1 - f'^2}} + \\sqrt{1 - f'^2} \\right) + \\frac{f''}{(1 - f'^2)^{3/2}} = 0. 括号内项有公共分母 \\sqrt{1 - f'^2} ：\n\\frac{f'^2}{\\sqrt{1 - f'^2}} + \\sqrt{1 - f'^2} = \\frac{f'^2 + (1 - f'^2)}{\\sqrt{1 - f'^2}} = \\frac{1}{\\sqrt{1 - f'^2}}. 故：\n-\\Phi'(f) \\frac{1}{\\sqrt{1 - f'^2}} + \\frac{f''}{(1 - f'^2)^{3/2}} = 0. 将此方程乘上 (1 - f'^2)^{3/2} ：\nf'' - \\Phi'(f) (1 - f'^2) = 0. 故当 S[f] 取极值时，满足的欧拉-拉格朗日方程为：\n\\boxed{f''(t) = \\Phi'(f(t)) \\left[ 1 - (f'(t))^2 \\right]}. 1.2 单元泛函的高阶欧拉拉格朗日方程及其化简方法 给定 f(t) 的泛函 S[f] = \\int \\mathrm{d}t L ，其中 L = f'^2 + f^2 f'' + f f'^2 f'' 。\n求一阶泛函导数 \\frac{\\delta S}{\\delta f} ；\n将 L 改写成 L = \\tilde{L} + \\frac{\\mathrm{d}F}{\\mathrm{d}t} 的形式，其中 F 是 f 和 f' 的函数，使得 \\tilde{L} 中不包含 f'' ，求 \\tilde{L} 和 F ；\n求泛函 \\tilde{S}[f] = \\int \\mathrm{d}t \\tilde{L} 的一阶泛函导数 \\frac{\\delta \\tilde{S}}{\\delta f} ，并比较其和 \\frac{\\delta S}{\\delta f} 的异同。\n解：\n(1)求一阶泛函导数 \\frac{\\delta S}{\\delta f} 根据我们在 1.3 节泛函导数中得到的求一阶泛函导数的过程方法。对于形如\n\u003e S[f] = \\int_{t_1}^{t_2} dt L(t, f(t), f'(t), \\cdots) \u003e 的泛函，要计算其一阶泛函导数，我们需要将变分号作用于括号中的内容，对其中的每一项进行变分，\n\u003e \\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right) \u003e 最终将其化为\n\u003e \\delta S \\simeq \\int_{t_1}^{t_2} dt \\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots \\right] \\delta f \u003e 从中得到一阶泛函导数\n\u003e \\boxed{\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots} \u003e 因此，上述等式中右侧部分皆为一阶泛函导数。\n当我们得到欧拉拉格朗日方程之后，我们求一阶泛函导数的过程就简化为了直接求取泛函满足的欧拉拉格朗日方程。\n然而，我们在得到欧拉拉格朗日方程的时候，推演所说的是“泛函式 S[f] = \\int dt L(t, f(t), f'(t)) 在 f=f(t) 处取到极值的必要条件是 f(t) 满足欧拉拉格朗日方程。”\n\u003e \\boxed{- \\frac{\\delta S}{\\delta f} \\equiv \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) - \\frac{\\partial L}{\\partial f} = 0} \u003e 注意，推演使用的前提是泛函式 S[f] = \\int dt L(t, f(t), f'(t)) ，该式最高仅包含泛函式 f(t) 的一阶导数，因此，得到的欧拉拉格朗日方程自然就是一个二阶微分方程。\n而如果要分析的泛函式相当复杂，以至于高阶项不可忽略，那么，我们要求得的一阶泛函导数就需要满足高阶欧拉拉格朗日方程，即\n\u003e \\boxed{\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots} \u003e 对于题述泛函式： S[f] = \\int \\mathrm{d}t L ，其中 L = f'^2 + f^2 f'' + f f'^2 f'' ，其即为高阶项不可忽略的泛函，拉格朗日量最高包含 f(t) 的二阶导数，因此其一阶泛函导数即满足的欧拉拉格朗日方程将是一个三阶微分方程。\n给定拉格朗日量 L ：\nL = f'^2 + f^2 f'' + f f' f''. 欧拉-拉格朗日方程形式为：\n\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right). 计算各阶导数\n\\frac{\\partial L}{\\partial f}=2ff''+f'^2f'' \\frac{\\partial L}{\\partial f'}=2f'+2ff'f'' \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial f'}\\right)=2f''+2f'^2f''+2ff''^2+2ff'f''' \\frac{\\partial L}{\\partial f''}=f^2+ff'^2 \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial f''}\\right)=2ff'+f'f'^2+2ff'f'' \\frac{d^2}{dt^2}\\left(\\frac{\\partial L}{\\partial f''}\\right)=2f'^2+2ff''+f''f'^2+2f'^2f''+2f'^2f''+2ff''^2+2ff'f''' 将上述的各阶导数代入欧拉拉格朗日方程得到\n\\begin{align} \\frac{\\delta S}{\\delta f} \u0026= \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right)\\\\ \u0026=2f'^2-2f''+4ff''+4f'^2f'' \\end{align} 即得原泛函式一阶泛函导数。\n(2) 将 L 改写成 L = \\tilde{L} + \\frac{\\mathrm{d}F}{\\mathrm{d}t} 的形式 将 L 改写成 L = \\tilde{L} + \\frac{\\mathrm{d}F}{\\mathrm{d}t} 的形式，\n解题思路：\n要消去 L 中的二阶导数项 f'' ，典型方法是通过“全导数项”（ \\frac{\\mathrm{d} F}{\\mathrm{d} t} ）的添加实现。这类似于拉格朗日量中加入一个全导数不改变变分问题的欧拉-拉格朗日方程解，但可消去高阶导数项。\n给定： L = f'^2 + f^2 f'' + f (f')^2 f''. 将 L 中的 f'' 项分组： L = f'^2 + \\left( f^2 + f (f')^2 \\right) f''. 我们要找到一个函数 F(f, f') ，使得： \\frac{\\mathrm{d} F}{\\mathrm{d} t} = F_f f' + F_{f'} f'' \\quad \\text{（链式法则）}. 设 F = F(f, f') 是一个关于 f 和 f' 的函数，那么 F 对时间 t 的全导数 \\frac{\\mathrm{d} F}{\\mathrm{d} t} 可以通过链式法则展开为：\n\u003e \\frac{\\mathrm{d} F}{\\mathrm{d} t} = \\frac{\\partial F}{\\partial f} \\frac{\\mathrm{d} f}{\\mathrm{d} t} + \\frac{\\partial F}{\\partial f'} \\frac{\\mathrm{d} f'}{\\mathrm{d} t}. \u003e 可以产生与 L 中相同的 f'' 系数，从而通过 L - \\frac{\\mathrm{d} F}{\\mathrm{d} t} 消去 f'' 项。\n为使 \\frac{\\mathrm{d} F}{\\mathrm{d} t} 中的 f'' 系数与 L 中的相同，我们令： F_{f'} = f^2 + f (f')^2. 因为 \\frac{\\mathrm{d} F}{\\mathrm{d} t} 的 f'' 系数就是 F_{f'}. 求 F ：\n对 F_{f'} 关于 f' 积分： F_{f'} = f^2 + f (f')^2. 将 f 视为参数，对 f' 积分： F = \\int \\left( f^2 + f (f')^2 \\right) \\mathrm{d} f' = f^2 f' + f \\frac{(f')^3}{3} + g(f), 其中 g(f) 是关于 f 的任意函数。\n为了简便起见，我们可取 g(f) = 0 ，这样： F = f^2 f' + \\frac{f}{3} (f')^3. 检查 \\frac{\\mathrm{d} F}{\\mathrm{d} t} ：\n现在求 \\frac{\\mathrm{d} F}{\\mathrm{d} t} ： F_f = \\frac{\\partial F}{\\partial f} = 2f f' + \\frac{(f')^3}{3}, \\quad F_{f'} = f^2 + f (f')^2. 因此： \\frac{\\mathrm{d} F}{\\mathrm{d} t} = F_f f' + F_{f'} f'' = \\left( 2f f' + \\frac{(f')^3}{3} \\right) f' + \\left( f^2 + f (f')^2 \\right) f''. 展开： \\frac{\\mathrm{d} F}{\\mathrm{d} t} = 2f (f')^2 + \\frac{(f')^4}{3} + f^2 f'' + f (f')^2 f''. 构造 \\tilde{L} ：\n现在考虑： L - \\frac{\\mathrm{d} F}{\\mathrm{d} t} = \\left[ f'^2 + f^2 f'' + f (f')^2 f'' \\right] - \\left[ 2f (f')^2 + \\frac{(f')^4}{3} + f^2 f'' + f (f')^2 f'' \\right]. 对比每一项， f'' 相关项 f^2 f'' 与 f (f')^2 f'' 在相减后全部消去，因为完全匹配。剩下： L - \\frac{\\mathrm{d} F}{\\mathrm{d} t} = f'^2 - 2f (f')^2 - \\frac{(f')^4}{3}. 定义： \\tilde{L} := L - \\frac{\\mathrm{d} F}{\\mathrm{d} t} = f'^2 - 2f (f')^2 - \\frac{(f')^4}{3}. 最终结果：\n将 L 写成 \\tilde{L} + \\frac{\\mathrm{d} F}{\\mathrm{d} t} 的形式，我们得到： \\tilde{L} = f'^2 - 2f (f')^2 - \\frac{(f')^4}{3}, \\quad F = f^2 f' + \\frac{f}{3} (f')^3. 这就是所求的 \\tilde{L} 和 F 。\n解题思路简述：\n1. 问题背景：\n我们有一个泛函 S[f] = \\int L \\, dt, 其中的拉格朗日量 L 包含了关于 f 的二阶导数项 f''. 在变分原理或求解欧拉-拉格朗日方程时，高阶导数往往会使问题变得复杂。为了解化处理，我们希望在不改变问题解的前提下，把 L 写成一个不再显式包含 f'' 的部分（记为 \\tilde{L} ）加上一个关于 f 和 f' 的全导数项 \\frac{dF}{dt}. 因为对行为准则（变分条件）来说，加上一个全导数项不会影响最终的变分方程解。\n2. 关键思想：\n在变分问题中，如果我们把 L 替换为 L - \\frac{dF}{dt}, 由于 \\int \\frac{dF}{dt} dt = F 在变分过程中会涉及边界条件，对于 f 的变分方程不会造成本质影响。这就像在拉格朗日量中添加一个“全导数项”（total derivative term）：它改变不了最终的运动方程，却能改变拉格朗日量的形式，从而可能消除烦人的 f'' 项。\n3. 如何选择 F ？\n我们要消掉 L 中所有的 f'' 项。那么用链式法则，当我们写出 \\frac{dF}{dt} 时，必然会出现一项与 f'' 成正比的项（就是 F_{f'} f''. 即 F 对 f' 的导数乘以 f''. 如果我们能恰当选择 F 的形式，使得 dF/dt 中对应的 f'' 系数与 L 中现有的 f'' 系数完全相同，那么 L - \\frac{dF}{dt} 中的 f'' 项就会相互抵消，达到去掉 f'' 导数的目的。\n4. 步骤简介：\n首先，把 L 中的 f'' 项抽取出来，看看它的前面系数是多少。 接着，假设 \\frac{dF}{dt} 的 f'' 部分是提供与该系数相同的数量，使它们恰好相消。 为了达到这个目的，我们将 \\frac{dF}{dt} 按链式法则展开为 F_f f' + F_{f'} f'', 其中 F_f 和 F_{f'} 分别是 F 关于 f 和 f' 的偏导。 我们根据想要的 f'' 系数来选择 F_{f'}. 一旦确定了 F_{f'}, 通过对 f' 积分，就能求出 F 的具体形式。 5. 得到结果后检查：\n一旦 F 找到之后，我们计算 \\frac{dF}{dt} 并与 L 作差。理想情况下，所有的 f'' 项应全部消失，这就能得到一个新的拉格朗日量 \\tilde{L}, 里面只含有 f 和 f' 的项，而不包含 f''. (3) 上小题即为通过全导数项可忽略的原理，对高阶方程实现化简 对于一个泛函 S[f] = \\int \\tilde{L} \\, dt ，其中 \\tilde{L} 是关于 f 和 f' 的函数，其一阶泛函导数定义为： \\frac{\\delta S}{\\delta f} = \\frac{\\partial \\tilde{L}}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial \\tilde{L}}{\\partial f'} \\right). 这里 \\frac{\\partial \\tilde{L}}{\\partial f} 表示对 f 的偏导， \\frac{\\partial \\tilde{L}}{\\partial f'} 表示对 f' 的偏导。\n\\tilde{L} 中只存在一项显含 f ，即 -2f(f')^2 。因此： \\frac{\\partial \\tilde{L}}{\\partial f} = -2(f')^2. 对 \\tilde{L} 中的所有关于 f' 的项分别求偏导数：\nf^2 对 f' 的偏导是 2f' ； -2f(f')^2 对 f' 的偏导是 -4ff' ； -\\frac{(f')^4}{3} 对 f' 的偏导是 -\\frac{4}{3}(f')^3 。 因此： \\frac{\\partial \\tilde{L}}{\\partial f'} = 2f' - 4f f' - \\frac{4}{3}(f')^3. 为了得到 \\frac{d}{dt} \\left( \\frac{\\partial \\tilde{L}}{\\partial f'} \\right) ，对上述结果关于 t 求导，注意使用链式法则：\n\\frac{d}{dt} (2f') = 2f'' ； \\frac{d}{dt} (-4f f') = -4(f')^2 - 4f f'' ； \\frac{d}{dt} \\left( -\\frac{4}{3}(f')^3 \\right) = -4(f')^2 f'' 。 因此： \\frac{d}{dt} \\left( \\frac{\\partial \\tilde{L}}{\\partial f'} \\right) = 2f'' - 4(f')^2 - 4f f'' - 4(f')^2 f''. 将之前的结果代入：\n\\frac{\\partial \\tilde{L}}{\\partial f} = -2(f')^2 ； \\frac{d}{dt} \\left( \\frac{\\partial \\tilde{L}}{\\partial f'} \\right) = 2f'' - 4(f')^2 - 4f f'' - 4(f')^2 f'' 。 因此： \\frac{\\delta \\tilde{L}}{\\delta f} = -2(f')^2 - \\left[ 2f'' - 4(f')^2 - 4f f'' - 4(f')^2 f'' \\right]. 化简括号中的项： \\frac{\\delta \\tilde{L}}{\\delta f} = -2(f')^2 - 2f'' + 4(f')^2 + 4f f'' + 4(f')^2 f''. 合并同类项，得到： \\frac{\\delta \\tilde{S}}{\\delta f} = 2(f')^2 - 2f'' + 4f f'' + 4(f')^2 f''. 对比一阶泛函导数 \\frac{\\delta \\tilde{S}}{\\delta f} 和 \\frac{\\delta S}{\\delta f} \\begin{align} \\frac{\\delta S}{\\delta f} \u0026= \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right)\\\\ \u0026=2f'^2-2f''+4ff''+4f'^2f'' \\end{align} \\frac{\\delta \\tilde{S}}{\\delta f} = 2(f')^2 - 2f'' + 4f f'' + 4(f')^2 f''. 可见二者形式完全相同，这正如我们在题（2）开头所说，要消去 L 中的二阶导数项 f'' ，典型方法是通过“全导数项”（ \\frac{\\mathrm{d} F}{\\mathrm{d} t} ）的添加实现。这类似于拉格朗日量中加入一个全导数不改变变分问题的欧拉-拉格朗日方程解，但可消去高阶导数项。\n1.3 二元泛函的欧拉拉格朗日方程常规求解 给定两个函数 n(t) 和 a(t) 的泛函：\nS[n, a] = \\int dt \\, n a^3 \\left( A(n) + 3B(n) \\frac{a'^2}{n^2 a^2} \\right), 其中 A, B 是 n(t) 的任意函数。求泛函 S[n, a] 取极值时， n(t) 和 a(t) 的欧拉-拉格朗日方程。\n解：\n从定义出发，\nL = n a^3 \\left( A(n) + 3 B(n) \\frac{a'^2}{n^2 a^2} \\right). 对分数中的项稍加整理：\n\\frac{a'^2}{n^2 a^2} = \\frac{a'^2}{n^2} \\cdot \\frac{1}{a^2}. 因此\nL = n a^3 A(n) + n a^3 \\left( 3 B(n) \\frac{a'^2}{n^2 a^2} \\right) = n a^3 A(n) + \\frac{3 B(n)}{n^2} a a'^2. 这里使用了 a^3 \\cdot \\frac{1}{a^2} = a 。\n最终的简化形式为：\nL(n, a, a') = n a^3 A(n) + \\frac{3 B(n)}{n^2} a a'^2. 对 a(t) 的欧拉-拉格朗日方程\n欧拉–拉格朗日方程为： \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial a'} \\right) - \\frac{\\partial L}{\\partial a} = 0. 首先求 \\frac{\\partial L}{\\partial a'} ： \\frac{\\partial L}{\\partial a'} = \\frac{\\partial}{\\partial a'} \\left( n a^3 A(n) + \\frac{3 B(n)}{n^2} a a'^2 \\right). 第一项不依赖 a' ，为 0。第二项：\n\\frac{\\partial}{\\partial a'} \\left( \\frac{3 B(n)}{n^2} a a'^2 \\right) = \\frac{3 B(n)}{n^2} a \\cdot 2 a' = \\frac{6 B(n)}{n^2} a a'. 因此：\n\\frac{\\partial L}{\\partial a'} = \\frac{6 B(n)}{n^2} a a'. 对时间 t 求导： \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial a'} \\right) = \\frac{d}{dt} \\left( \\frac{6 B(n)}{n^2} a a' \\right). 这是一个复合函数的时间导数，需要用链式法则，最终会得到较为复杂的表达式，但在这里我们先保持符号形式。\n接着求 \\frac{\\partial L}{\\partial a} ： L = n a^3 A(n) + \\frac{3 B(n)}{n^2} a a'^2. 对 a 求偏导：\n第一项 n a^3 A(n) 对 a 求导时，因为 n 与 A(n) 不依赖 a ，得到 3 n a^2 A(n) 。\n第二项 \\frac{3 B(n)}{n^2} a a'^2 对 a 求导，即为 \\frac{3 B(n)}{n^2} a'^2 。\n于是欧拉–拉格朗日方程对于 a(t) 有：\n\\frac{d}{dt} \\left( \\frac{6 B(n)}{n^2} a a' \\right) - \\left( 3 n a^2 A(n) + \\frac{3 B(n)}{n^2} a'^2 \\right) = 0. 若简化化，可以先除以 3：\n\\frac{d}{dt} \\left( \\frac{2 B(n)}{n^2} a a' \\right) = n a^2 A(n) + \\frac{B(n)}{n^2} a'^2. 这是 a(t) 对应的欧拉–拉格朗日方程。\n对 n(t) 的欧拉-拉格朗日方程\n对 n(t) 的方程为： \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial n'} \\right) - \\frac{\\partial L}{\\partial n} = 0. 注意到 L 中没有 n'(t) 项，因此 \\frac{\\partial L}{\\partial n'} = 0 。故方程简化为： - \\frac{\\partial L}{\\partial n} = 0 \\implies \\frac{\\partial L}{\\partial n} = 0. 对 L(n, a, a') = n a^3 A(n) + \\frac{3 B(n)}{n^2} a a'^2 求 \\frac{\\partial L}{\\partial n} ：\n对第一项 n a^3 A(n) ： \\frac{\\partial}{\\partial n} \\left( n a^3 A(n) \\right) = a^3 \\left[ A(n) + n A'(n) \\right]. （先对 n 求导： A(n) 当函数用链式： \\partial (n A(n)) / \\partial n = A(n) + n A'(n) ）\n对第二项 \\frac{3 B(n)}{n^2} a a'^2 ： \\frac{\\partial}{\\partial n} \\left( \\frac{3 B(n)}{n^2} a a'^2 \\right) = a a'^2 \\frac{\\partial}{\\partial n} \\left( \\frac{3 B(n)}{n^2} \\right). 对 \\frac{3 B(n)}{n^2} 求导： \\frac{d}{dn} \\left( \\frac{3 B(n)}{n^2} \\right) = \\frac{3 B'(n)}{n^2} - \\frac{6 B(n)}{n^3}. 故第二项对 n 的偏导为： a a'^2 \\left( \\frac{3 B'(n)}{n^2} - \\frac{6 B(n)}{n^3} \\right). 将两部分相加： \\frac{\\partial L}{\\partial n} = a^3 \\left[ A(n) + n A'(n) \\right] + a a'^2 \\left( \\frac{3 B'(n)}{n^2} - \\frac{6 B(n)}{n^3} \\right). 设此为 0： a^3 \\left[ A(n) + n A'(n) \\right] + a a'^2 \\left( \\frac{3 B'(n)}{n^2} - \\frac{6 B(n)}{n^3} \\right) = 0. 这即为 n(t) 对应的欧拉-拉格朗日方程。\n最终结果\n通过以上步骤，我们得到两条方程：\na(t) 的方程： \\frac{d}{dt} \\left( \\frac{2 B(n)}{n^2} a a' \\right) = n a^2 A(n) + \\frac{B(n)}{n^2} a'^2. n(t) 的方程： a^3 \\left[ A(n) + n A'(n) \\right] + a a'^2 \\left( \\frac{3 B'(n)}{n^2} - \\frac{6 B(n)}{n^3} \\right) = 0. 这两条方程即为在给定泛函 S[n, a] 下， n(t) 和 a(t) 满足的欧拉-拉格朗日方程。\n1.4 一元泛函二元函数的欧拉拉格朗日方程求解 给定二元函数 f(t, x) 的泛函： S[f] = \\iint dt dx \\, \\frac{1}{2} \\left[ \\left( \\frac{\\partial f(t, x)}{\\partial t} \\right)^2 - \\left( \\frac{\\partial f(t, x)}{\\partial x} \\right)^2 - m^2 f^2(t, x) \\right], 其中 m 为常数。\n求泛函 S[f] 取极值时 f(t, x) 的欧拉-拉格朗日方程。\n解：\n下面给出详细的求解过程。此题给出的泛函具有二元函数 f(t, x) ，即场函数。在场论中，这种形式的作用量与 Klein-Gordon 场的作用量具有相同结构。我们的任务是对 f(t, x) 求取泛函的极值，从而得到欧拉-拉格朗日方程。\n给定泛函：\nS[f] = \\iint dt dx \\, \\frac{1}{2} \\left[ \\left( \\frac{\\partial f(t, x)}{\\partial t} \\right)^2 - \\left( \\frac{\\partial f(t, x)}{\\partial x} \\right)^2 - m^2 f(t, x)^2 \\right], 其中 m 为常数。\n步骤 1：将 integrand 看作拉格朗日密度\n定义拉格朗日密度（Lagrangian density）为\n\\mathcal{L}(f, f_t, f_x) = \\frac{1}{2} \\left( f_t^2 - f_x^2 - m^2 f^2 \\right), 其中\nf_t = \\frac{\\partial f}{\\partial t}, \\ f_x = \\frac{\\partial f}{\\partial x}. 步骤 2：求欧拉-拉格朗日方程\n场论的欧拉-拉格朗日方程为：\n\\frac{\\partial \\mathcal{L}}{\\partial f} - \\frac{\\partial}{\\partial t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_t} \\right) - \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_x} \\right) = 0. 我们需要对 \\mathcal{L} 分别求偏导：\n\\frac{\\partial \\mathcal{L}}{\\partial f} ： \\mathcal{L} = \\frac{1}{2} \\left( f_t^2 - f_x^2 - m^2 f^2 \\right), 对 f 求偏导时，只有最后一项 -\\frac{1}{2} m^2 f^2 与 f 直接相关：\n\\frac{\\partial \\mathcal{L}}{\\partial f} = \\frac{1}{2} \\left( -2 m^2 f \\right) = -m^2 f. \\frac{\\partial \\mathcal{L}}{\\partial f_t} ： \\frac{\\partial \\mathcal{L}}{\\partial f_t} = \\frac{1}{2} \\left( 2 f_t \\right) = f_t. \\frac{\\partial \\mathcal{L}}{\\partial f_x} ： \\frac{\\partial \\mathcal{L}}{\\partial f_x} = \\frac{1}{2} \\left( -2 f_x \\right) = -f_x. 接下来对时间与空间进行偏导：\n对时间求导：\n\\frac{\\partial}{\\partial t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_t} \\right) = \\frac{\\partial}{\\partial t} (f_t) = f_{tt}. 对空间求导：\n\\frac{\\partial}{\\partial x} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_x} \\right) = \\frac{\\partial}{\\partial x} (-f_x) = -f_{xx}. 将这些代回欧拉-拉格朗日方程中：\n\\frac{\\partial \\mathcal{L}}{\\partial f} - \\frac{\\partial}{\\partial t} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_t} \\right) - \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial \\mathcal{L}}{\\partial f_x} \\right) = 0. 代入结果：\n-m^2 f - f_{tt} + f_{xx} = 0. 稍作整理：\nf_{tt} - f_{xx} + m^2 f = 0. 这就是二元函数 f(t, x) 对应的欧拉-拉格朗日方程，也是 Klein-Gordon 方程在一维空间（加一维时间）下的形式。\n最终答案：\n当泛函 S[f] 取极值时， f(t, x) 满足以下欧拉-拉格朗日方程（Klein-Gordon 方程）：\n\\boxed{(f_{tt}(t, x) - f_{xx}(t, x) + m^2 f(t, x) = 0)}. 标准 Klein-Gordon 方程（含常量）：\n一般在量子场论或相对论量子力学中，Klein-Gordon 方程写为：\n\u003e \\left( \u003e \\frac{\\partial^2}{\\partial t^2} - c^2 \\nabla^2 + \\frac{m^2 c^4}{\\hbar^2} \u003e \\right) \\psi(t, \\mathbf{x}) = 0. \u003e 这里明确地保留了普朗克常数 \\hbar 、光速 c 等常量。\n自然单位制（ c = 1, \\hbar = 1 ）：\n在高能物理或场论中，常常采用自然单位制，将 c = 1 和 \\hbar = 1 。在这种单位制下，长度、时间和质量之间的尺度关系被简化。例如，在自然单位制下，Klein-Gordon 方程就变为：\n\u003e \\left( \u003e \\frac{\\partial^2}{\\partial t^2} - \\nabla^2 + m^2 \u003e \\right) \\psi(t, \\mathbf{x}) = 0. \u003e 可以看出，与本题的最终结果\n\u003e f_{tt}(t, x) - f_{xx}(t, x) + m^2 f(t, x) = 0 \u003e 非常类似，只是这里的空间维度是 1 维（所以 \\nabla^2 简化为 \\frac{\\partial^2}{\\partial x^2} ），函数和符号略有区别而已。\n维度简化：\n我们的结果是针对于一维空间中的场 f(t, x) 推导得到的。当将空间维数取为 1 时， \\nabla^2 简化为 \\frac{\\partial^2}{\\partial x^2} ，于是方程就变成：\n\u003e f_{tt}(t, x) - f_{xx}(t, x) + m^2 f(t, x) = 0, \u003e 完全对应 c = 1, \\hbar = 1 的 Klein-Gordon 方程在一时一空维下的简化形式。\n1.5 应用欧拉拉格朗日方程 考虑一条不可拉伸、质量均匀的柔软细绳，长为 l ，质量为 m 。细绳两端点悬挂于相同高度，水平距离为 a(a \u003c l) 。\n选择合适的坐标，求细绳总的重力势能 V 作为细绳形状的泛函； 求细绳重力势能取极值时，细绳形状所满足的欧拉–拉格朗日方程。 (1) 选择合适的坐标系，求总重力势能作为细绳形状的泛函：\n坐标系选择：\n为了对称与简化起见，可以选择直角坐标系 (x, y) ，令细绳的两端点位于相同的高度 y = 0 。为方便说明，不妨将两端点放置在 x = 0 与 x = a 处，即两端点为 (0, 0) 和 (a, 0) 。 整条绳以函数 y(x) 描述其垂度，即细绳中每一点的高度为 y(x) ，其中 x \\in [0, a] 。由于细绳是柔软不可拉伸的，其长度约束条件为：\n\\int_0^a \\sqrt{1 + \\left( y'(x) \\right)^2} dx = l. 在平面上，一条曲线可以用参数 x 来描述成 y = y(x) 。对于曲线上一小段长度 ds ，根据勾股定理，其长度可写为\n\u003e ds = \\sqrt{dx^2 + dy^2}. \u003e 因为 y 是 x 的函数，微小增量 dy 可以写成\n\u003e dy = y'(x) dx. \u003e 这里 y'(x) 表示 \\frac{dy}{dx} 。\n在 ds = \\sqrt{dx^2 + dy^2} 中用这个关系替代 dy ：\n\u003e ds = \\sqrt{dx^2 + (y'(x) dx)^2}. \u003e \u003e ds = \\sqrt{dx^2 + y'(x)^2 dx^2} = \\sqrt{dx^2 \\left( 1 + (y'(x))^2 \\right)}. \u003e \u003e ds = \\sqrt{1 + (y'(x))^2} |dx|. \u003e 由于我们一般选定 x 为坐标轴并按照 x 递增的方向计量长度， dx \u003e 0 ，所以 |dx| = dx 。\n因此\n\u003e ds = \\sqrt{1 + (y'(x))^2} dx. \u003e 细绳的线密度：\n细绳质量为 m ，长度为 l ，则线密度 \\lambda = \\frac{m}{l} （质量均匀分布）。\n重力势能表达式：\n在重力场中，若将势能零点取在 y = 0 的水平线上（即两端点的水平线上），则绳上的一小段 ds 的质量为 \\lambda ds ，其垂直坐标为 y(x) 。重力势能为\ndV = mgh = \\lambda ds g y(x), 其中 g 为重力加速度。\n微元长度 ds = \\sqrt{1 + \\left( y'(x) \\right)^2} dx 。因此绳的总重力势能：\nV[y] = \\int_0^a \\lambda g y(x) \\sqrt{1 + \\left( y'(x) \\right)^2} dx. 将 \\lambda = \\frac{m}{l} 带入：\nV[y] = \\frac{mg}{l} \\int_0^a y(x) \\sqrt{1 + \\left( y'(x) \\right)^2} dx. 这就是重力势能作为形状 y(x) 的泛函。\n(2) 当细绳重力势能取极值时的欧拉-拉格朗日方程：\n要找使 V[y] 取极值的 y(x) ，我们需要对上述泛函进行变分计算。这里的泛函形式为：\nV[y] = \\int_0^a F(y, y') dx, \\quad \\text{其中 } F(y, y') = \\frac{mg}{l} y \\sqrt{1 + \\left( y' \\right)^2}. 为简化符号，将常量因子记为 C = \\frac{mg}{l} ，则：\nF(y, y') = C y \\sqrt{1 + \\left( y' \\right)^2}. 欧拉-拉格朗日方程为：\n\\frac{\\partial F}{\\partial y} - \\frac{d}{dx} \\left( \\frac{\\partial F}{\\partial y'} \\right) = 0. 分别求偏导：\n对 y 的偏导：\n\\frac{\\partial F}{\\partial y} = C \\sqrt{1 + \\left( y' \\right)^2}. 对 y' 的偏导：\n\\frac{\\partial F}{\\partial y'} = C y \\frac{1}{2 \\sqrt{1 + \\left( y' \\right)^2}} \\cdot 2 y' = C \\frac{y y'}{\\sqrt{1 + \\left( y' \\right)^2}}. 对 x 求导：\n\\frac{d}{dx} \\left( \\frac{\\partial F}{\\partial y'} \\right) = C \\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{1 + \\left( y' \\right)^2}} \\right). 需要对该表达式使用商数和链式法则进行求导。\n设 Z = 1 + \\left( y' \\right)^2 ，则 \\sqrt{Z} = \\sqrt{1 + \\left( y' \\right)^2} 。\n\\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{Z}} \\right) = \\frac{\\left( y' y' + y y'' \\right) \\sqrt{Z} - y y' \\frac{1}{2 \\sqrt{Z}} 2 y' y'}{Z}. 为简化记号，可直接使用欧拉-拉格朗日方程标准过程。实际上，这个过程相当复杂，我们仅给出最终的微分方程结构。\n完整的欧拉-拉格朗日方程为：\nC \\sqrt{1 + \\left( y' \\right)^2} - C \\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{1 + \\left( y' \\right)^2}} \\right) = 0. 去除常数 C 后：\n\\boxed{\\sqrt{1 + \\left( y' \\right)^2} - \\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{1 + \\left( y' \\right)^2}} \\right) = 0}. 这就是问题的原始形式。若进一步化简，需要细心代数运算。但通常在给出欧拉-拉格朗日方程时，保留该形式已足够说明问题的可解性质。\n这就是最终的偏微分方程（事实上是常微分方程）形式。该方程表明，在平衡形状下，曲线必须满足这个非线性微分方程。与熟知的数学结果相比，这最终导致绳形类似悬链线（catenary）的形状。\n1.5.1 Beltrami identity 以及悬链线方程的推导 我们知道，我们所得到的，细绳重力势能取极值时，细绳形状所满足的欧拉拉格朗日方程最终一定可以导出细绳形状的描述方程\u0026mdash;即悬链线方程。\n而众所周知悬链线方程为\ny = a \\cosh\\left(\\frac{x}{a}\\right) 其中， \\cosh(x) 是双曲余弦函数，定义为：\n\\cosh(x) = \\frac{e^x + e^{-x}}{2}. 要从本题最终得到的欧拉拉格朗日方程形式导出悬链线方程，我们首先需要了解 Beltrami 恒等式的概念。\nBeltrami 恒等式\nBeltrami 恒等式是欧拉拉格朗日方程的一个特例\n对于以下形式的泛函\nI[u] = \\int_a^b L[x, u(x), u'(x)] \\, dx, 其中 a 和 b 都是常数，并且 u'(x) = \\frac{du}{dx} .\n如果 \\frac{\\partial L}{\\partial x} = 0 , 那么欧拉-拉格朗日方程就简化为 Beltrami 恒等式,\n\\boxed{L - u' \\frac{\\partial L}{\\partial u'} = C}, 其中 C 是一个常数.\nBeltrami 恒等式的导出过程\nL 的导数为\n\\frac{dL}{dx} = \\frac{\\partial L}{\\partial x} \\frac{dx}{dx} + \\frac{\\partial L}{\\partial u} \\frac{du}{dx} + \\frac{\\partial L}{\\partial u'} \\frac{du'}{dx}. 由于 \\frac{\\partial L}{\\partial x} = 0 , 于是上式化为\n\\frac{dL}{dx} = \\frac{\\partial L}{\\partial u} u' + \\frac{\\partial L}{\\partial u'} u''. 对于 \\frac{\\partial L}{\\partial u} 其满足欧拉拉格朗日方程,\n\\frac{\\partial L}{\\partial u} = \\frac{d}{dx} \\frac{\\partial L}{\\partial u'}, 将上述表达式代入 \\frac{dL}{dx} 获得\n\\frac{dL}{dx} = u' \\frac{d}{dx} \\frac{\\partial L}{\\partial u'} + u'' \\frac{\\partial L}{\\partial u'}. 这等价于 \\frac{dL}{dx} = \\frac{d}{dx} \\left( u' \\frac{\\partial L}{\\partial u'} \\right). 对两边同时积分，并且将所得结果项均置于左侧，我们就得到 Beltrami 恒等式 \\boxed{L - u' \\frac{\\partial L}{\\partial u'} = C}. 下面给出从本题最终的微分方程直接求解出悬链线方程 y = a \\cosh \\left( \\frac{x}{a} \\right) 的详细过程。为简化推导，我们去掉某些常数因子（如质量密度、重力加速度和拉格朗日乘子）对最终函数形态的影响，因为它们仅会改变最终参数如 a , x_0 的数值，而不影响解的函数形式为双曲余弦函数。\n给定的微分方程：\n原方程为\n\\sqrt{1 + (y')^2} - \\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{1 + (y')^2}} \\right) = 0. 将其改写为：\n\\frac{d}{dx} \\left( \\frac{y y'}{\\sqrt{1 + (y')^2}} \\right) = \\sqrt{1 + (y')^2}. 这是一个非线性二阶方程。我们需要通过引入合适的变量替换将其简化为可解的形式。\n步骤 1：第一次积分\n对 x 积分一次（假设边界条件允许，不失一般性引入一个积分常数 C_1 ）：\n\\frac{y y'}{\\sqrt{1 + (y')^2}} = \\int \\sqrt{1 + (y')^2} dx + C_1. 现在面临的困难是：右侧的被积函数 \\sqrt{1 + (y')^2} 仍然含有 y' 这个导数，且 y'(x) 是未知函数，因此无法直接对 x 积分。我们需要一个策略来分离变量或者找到一个更简单的中间变量。\n步骤 2：利用 Beltrami 恒等式\n原始问题来自于变分问题（最小势能、最小长度等）。当泛函的被积函数 F(y, y') 不显含 x 时，我们就可以利用 Beltrami 恒等式：\nF - y' \\frac{\\partial F}{\\partial y'} = \\text{常数}. 在本问题中，对应的泛函形式为：\nF(y, y') = \\frac{mg}{l} y \\sqrt{1 + (y')^2}. 略去不相关的常量为：\nF(y, y') = y \\sqrt{1 + (y')^2}. 计算偏导数：\n\\frac{\\partial F}{\\partial y'} = \\frac{y y'}{\\sqrt{1 + (y')^2}}. 套用 Beltrami 恒等式：\nF - y' \\frac{\\partial F}{\\partial y'} = y \\sqrt{1 + (y')^2} - y' \\left( \\frac{y y'}{\\sqrt{1 + (y')^2}} \\right). 化简第二项：\ny'\\frac{y y'}{\\sqrt{1 + (y')^2}} = \\frac{y (y')^2}{\\sqrt{1 + (y')^2}}. 所以：\nF - y' \\frac{\\partial F}{\\partial y'} = y \\sqrt{1 + (y')^2} - \\frac{y (y')^2}{\\sqrt{1 + (y')^2}}. 将 y\\sqrt{1 + (y')^2} 作为公因子提取：\ny \\sqrt{1+\\left(y^{\\prime}\\right)^{2}}\\left(1-\\frac{\\left(y^{\\prime}\\right)^{2}}{1+\\left(y^{\\prime}\\right)^{2}}\\right)=y \\sqrt{1+\\left(y^{\\prime}\\right)^{2}} \\frac{1+\\left(y^{\\prime}\\right)^{2}-\\left(y^{\\prime}\\right)^{2}}{1+\\left(y^{\\prime}\\right)^{2}}=\\frac{y}{\\sqrt{1+\\left(y^{\\prime}\\right)^{2}}} 于是 Beltrami 恒等式简化为：\n\\frac{y}{\\sqrt{1 + (y')^2}} = \\text{常数} = A. 步骤 3：得到一阶微分方程\n我们得到了一个非常关键的简化：\n\\frac{y}{\\sqrt{1 + (y')^2}} = A. 解出 \\sqrt{1 + (y')^2} ：\n\\sqrt{1 + (y')^2} = \\frac{y}{A}. 平方两边：\n1 + (y')^2 = \\frac{y^2}{A^2}. 由此：\n(y')^2 = \\frac{y^2}{A^2} - 1. 开平方：\ny' = \\frac{dy}{dx} = \\sqrt{\\frac{y^2}{A^2} - 1} = \\frac{\\sqrt{y^2 - A^2}}{A}. 为方便起见，我们令 a = A （只是更名，不影响形式）。此时：\ny' = \\frac{\\sqrt{y^2 - a^2}}{a}. 步骤 4：分离变量求解\n将方程改写为：\n\\frac{dy}{\\sqrt{y^2 - a^2}} = \\frac{dx}{a}. 现在可以对 y 分离变量积分：\n\\int \\frac{dy}{\\sqrt{y^2 - a^2}} = \\frac{1}{a} \\int dx. 左侧积分是标准积分公式，其结果是：\n\\int \\frac{dy}{\\sqrt{y^2 - a^2}} = \\cosh^{-1} \\left( \\frac{y}{a} \\right) = \\ln \\left( \\frac{y}{a} + \\sqrt{\\frac{y^2}{a^2} - 1} \\right). 步骤 5：整理通解\n为简洁使用双曲函数反函数记号：\n\\cosh^{-1} \\left( \\frac{y}{a} \\right) = \\frac{x}{a} + C_2, 上式由 \\int \\frac{dy}{\\sqrt{y^2 - a^2}} = \\frac{1}{a} \\int dx. 得到，其中 C_2 是积分常数。\n于是：\n\\frac{y}{a} = \\cosh \\left( \\frac{x}{a} + C_2 \\right). 为方便起见，将 \\frac{x}{a} + C_2 用 \\frac{x - x_0}{a} 表示，并将 cosh 内部平移吸收为 cosh 函数的参数平移：\ny = a \\cosh \\left( \\frac{x - x_0}{a} \\right). 如果还需要竖直平移，可加上一个 y_0 ，即最终解的最通用形式为：\ny(x) = a \\cosh \\left( \\frac{x - x_0}{a} \\right) + y_0. 从数学上讲，当泛函的“拉格朗日量”不显含自变量（在这里是不显含 x 时），欧拉-拉格朗日方程可以简化。当我们的拉格朗日量 F(y,y') 没有显式依赖 x 时，就存在一个积分不变量（类似于“能量守恒”的量）。这是数学上较一般的结果。\n而从物理上论，如果系统的势能泛函对横坐标 x 没有“特定的依赖”，那么系统不存在优先的 x -位置，即在水平方向上是均匀的。这种均匀性（平移对称性）意味着存在类似于“守恒量”的东西。在变分法对应的物理问题中，这个“守恒量”就通过 Beltrami 恒等式体现出来。这类似于力学中：如果系统不显含时间，则能量守恒；在这里不显含 x 则有一个类似的守恒量。\nBeltrami 恒等式比原先的欧拉-拉格朗日方程简单，因为它减少了方程的阶数和复杂度。通过 Beltrami 恒等式，我们可以更直接地找到满足极值条件的曲线：即悬链线。所以 Beltrami 恒等式其实就是一种化简欧拉拉格朗日方程的方案，不过更重要的是，这种简化方案蕴含了（或者说其基于）系统在泛函的不显含变量方向上的守恒性。\n而这就是我们在上文中求解问题的整体逻辑：找到绳子平衡形状（最低势能） → 写出势能泛函 → 用变分法和极值条件（欧拉-拉格朗日方程） → 利用问题不显含 x 的对称性（均匀性） → 得到Beltrami恒等式 → 更容易地求解，得到悬链线。\n相比于一般的微元法 假设链条的形状为 y(x) ，则切线斜率 \\theta = \\frac{dy}{dx} 。\n由几何关系，链条的张力可以分解为：\n\u003e\\begin{align} \u003e T_x \u0026= T_0 = T \\cos \\theta \\\\ \u003e T_y \u0026= T \\sin \\theta \\end{align} \u003e 由竖直方向的平衡条件：\n\u003e \\frac{dT_y}{dx} = \\lambda g \u003e \u003e \\frac{d}{dx} \\left( T \\sin \\theta \\right) = \\lambda g \u003e \u003e T \\frac{d \\sin \\theta}{dx} = \\lambda g \u003e 由于 \\theta = \\frac{dy}{dx} ，\n\u003e \\frac{d \\sin \\theta}{dx} = \\frac{d}{dx} \\left( \\frac{dy}{ds} \\right) = \\frac{d^2 y}{dx^2} \\cdot \\frac{1}{\\sqrt{1 + \\left( \\frac{dy}{dx} \\right)^2}} = \\frac{y''}{\\sqrt{1 + y'^2}} \u003e 因此，\n\u003e T \\frac{y''}{\\sqrt{1 + y'^2}} = \\lambda g \u003e 整理微分方程：\n\u003e \\frac{y''}{\\sqrt{1 + y'^2}} = \\frac{\\lambda g}{T} \u003e 设常数 \\frac{\\lambda g}{T} = \\frac{1}{a} ，则方程变为：\n\u003e \\frac{y''}{\\sqrt{1 + y'^2}} = \\frac{1}{a} \u003e 这是一个非线性二阶微分方程。通过积分可以简化：\n先令 y' = \\sinh \\left( \\frac{x}{a} \\right) ，满足上述方程。最终解得：\n\u003e y(x) = a \\cosh \\left( \\frac{x}{a} \\right) + C \u003e 其中 C 是积分常数，通过边界条件确定。\n对比两种方法的简洁性\n泛函变分法（从势能极值出发） 写出势能表达式： \u003e V = \\int_{-a/2}^{a/2} y \\sqrt{1 + \\left( \\frac{dy}{dx} \\right)^2} dx \u003e 对 V 变分，得到欧拉-拉格朗日方程： \u003e \\frac{\\partial f}{\\partial y} - \\frac{d}{dx} \\left( \\frac{\\partial f}{\\partial y'} \\right) = 0 \u003e 其中 f = y \\sqrt{1 + y'^2} 。\n解出微分方程后直接得到悬链线的形状： \u003e y(x) = a \\cosh \\left( \\frac{x}{a} \\right) \u003e 微元分析法（从受力平衡出发） 假设细绳上任意微元的张力分解为水平和垂直分量 T_x, T_y ，同时重力为 \\lambda g ds ；\n利用力平衡条件，建立两个方向上的受力平衡方程：\n水平方向： T_x = T_0 ； 垂直方向： \\frac{dT_y}{dx} = \\lambda g ； 利用弧长关系 ds = \\sqrt{1 + y'^2} dx ，建立微分方程；\n将微分方程整合，得到形状方程。\n泛函变分法的优越性：\n更适合直接从能量（全局极值）出发的问题； 数学过程严谨且简洁，避免繁琐的受力分解步骤； 适用范围广，尤其是非平衡力场或复杂约束条件下。 微元分析法的适用场景：\n更适合经典力学中明确的受力平衡问题； 当能量无法直接写为泛函形式时，微元法更具实用性。 1.6 考虑 3 维空间中的任意 2 维曲面，取直角坐标，曲面方程为 z = z(x, y) 。曲面上任意两固定点，由曲面上的任一曲线连接。曲线方程为 x = x(\\lambda), y = y(\\lambda) ，这里 \\lambda 是曲线的参数。\n求曲线的长度 S 作为 x(\\lambda) 和 y(\\lambda) 的泛函 S[x, y] ；\n求曲线长度 S 取极值时， x(\\lambda) 和 y(\\lambda) 的欧拉-拉格朗日方程；\n当曲面为以下情况时，求解 x(\\lambda) 和 y(\\lambda) ：\n平面 z = ax + by + c ( a, b, c 为常数)； 球面 z = \\sqrt{R^2 - x^2 - y^2} ( R 为常数)； 链面 z = H \\left( 1 - \\frac{1}{R} \\sqrt{x^2 + y^2} \\right) ( H, R 为常数)。 解答：\n1.6.1. 求曲线的长度 S 作为 x(\\lambda) 和 y(\\lambda) 的泛函 S[x, y] 曲线长度 S 可以表示为参数化形式：\nS = \\int_{\\lambda_1}^{\\lambda_2} \\sqrt{\\left( \\frac{dx}{d\\lambda} \\right)^2 + \\left( \\frac{dy}{d\\lambda} \\right)^2 + \\left( \\frac{dz}{d\\lambda} \\right)^2} \\, d\\lambda. 由于曲面方程为 z = z(x, y) ，可以将 z 的变化用 x 和 y 表达，即：\n\\frac{dz}{d\\lambda} = \\frac{\\partial z}{\\partial x} \\frac{dx}{d\\lambda} + \\frac{\\partial z}{\\partial y} \\frac{dy}{d\\lambda}. 代入曲线长度公式，得到：\nS = \\int_{\\lambda_1}^{\\lambda_2} \\sqrt{\\left( \\frac{dx}{d\\lambda} \\right)^2 + \\left( \\frac{dy}{d\\lambda} \\right)^2 + \\left( \\frac{\\partial z}{\\partial x} \\frac{dx}{d\\lambda} + \\frac{\\partial z}{\\partial y} \\frac{dy}{d\\lambda} \\right)^2} \\, d\\lambda. 1.6.2. 求曲线长度 S 取极值时， x(\\lambda) 和 y(\\lambda) 的欧拉-拉格朗日方程 记 \\frac{dx}{d\\lambda} = \\dot{x}, \\frac{dy}{d\\lambda} = \\dot{y} ，并将拉格朗日函数 \\mathcal{L} 定义为：\n\\mathcal{L} = \\sqrt{\\dot{x}^2 + \\dot{y}^2 + \\left( \\frac{\\partial z}{\\partial x} \\dot{x} + \\frac{\\partial z}{\\partial y} \\dot{y} \\right)^2}. 令 q_1 = x, q_2 = y ，欧拉-拉格朗日方程为：\n\\frac{d}{d\\lambda} \\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}_i} - \\frac{\\partial \\mathcal{L}}{\\partial q_i} = 0, \\quad (i = 1, 2). 分别对 q_1 = x 和 q_2 = y 写出对应的方程。\n对 x 的欧拉-拉格朗日方程\n计算 \\frac{\\partial \\mathcal{L}}{\\partial \\dot{x}} ：\n\\frac{\\partial \\mathcal{L}}{\\partial \\dot{x}} = \\dot{x} + \\left( \\frac{\\partial z}{\\partial x} \\dot{x} + \\frac{\\partial z}{\\partial y} \\dot{y} \\right) \\frac{\\partial z}{\\partial x} \\frac{1}{\\mathcal{L}}. 再计算 \\frac{\\partial \\mathcal{L}}{\\partial x} ：\n\\frac{\\partial \\mathcal{L}}{\\partial x} = \\frac{1}{\\mathcal{L}} \\cdot \\left[ \\left( \\frac{\\partial z}{\\partial x} + \\frac{\\partial z}{\\partial y} \\right) \\frac{\\partial^2 z}{\\partial x^2} \\dot{x} + \\frac{\\partial z}{\\partial x} \\frac{\\partial^2 z}{\\partial x \\partial y} \\dot{y} \\right]. 代入欧拉-拉格朗日方程，整理后可得：\n\\frac{d}{d\\lambda} \\left[ \\frac{\\dot{x} + \\left( \\frac{\\partial z}{\\partial x} \\dot{x} + \\frac{\\partial z}{\\partial y} \\dot{y} \\right) \\frac{\\partial z}{\\partial x}}{\\mathcal{L}} \\right] - \\frac{1}{\\mathcal{L}} \\cdot \\left[ \\left( \\frac{\\partial z}{\\partial x} + \\frac{\\partial z}{\\partial y} \\right) \\frac{\\partial^2 z}{\\partial x^2} \\dot{x} + \\frac{\\partial z}{\\partial x} \\frac{\\partial^2 z}{\\partial x \\partial y} \\dot{y} \\right] = 0. 对 y 的欧拉-拉格朗日方程\n类似地，对 q_2 = y 的情况，可以得到类似的表达式：\n\\frac{d}{d\\lambda} \\left[ \\frac{\\dot{y} + \\left( \\frac{\\partial z}{\\partial x} \\dot{x} + \\frac{\\partial z}{\\partial y} \\dot{y} \\right) \\frac{\\partial z}{\\partial y}}{\\mathcal{L}} \\right] - \\frac{1}{\\mathcal{L}} \\cdot \\left[ \\left( \\frac{\\partial z}{\\partial x} + \\frac{\\partial z}{\\partial y} \\right) \\frac{\\partial^2 z}{\\partial y^2} \\dot{y} + \\frac{\\partial z}{\\partial y} \\frac{\\partial^2 z}{\\partial x \\partial y} \\dot{x} \\right] = 0. 1.6.3. 求三种曲面方程下，满足极值曲线的 x(\\lambda) 和 y(\\lambda) 3.1 平面 z = ax + by + c 给定曲面方程 z = ax + by + c ，曲线的参数方程为 x = x(\\lambda), y = y(\\lambda) 。曲线的长度泛函为：\nS = \\int \\sqrt{\\left( \\frac{dx}{d\\lambda} \\right)^2 + \\left( \\frac{dy}{d\\lambda} \\right)^2 + \\left( \\frac{dz}{d\\lambda} \\right)^2} \\, d\\lambda 由于 z = ax + by + c ，有：\n\\frac{dz}{d\\lambda} = a \\frac{dx}{d\\lambda} + b \\frac{dy}{d\\lambda}. 代入长度泛函：\nS = \\int \\sqrt{\\left( 1 + a^2 \\right) \\left( \\frac{dx}{d\\lambda} \\right)^2 + 2ab \\frac{dx}{d\\lambda} \\frac{dy}{d\\lambda} + \\left( 1 + b^2 \\right) \\left( \\frac{dy}{d\\lambda} \\right)^2} \\, d\\lambda. 由于平面是欧几里得空间中的平坦曲面，极值曲线应为平面内的直线。为了验证这一点，我们可以选择参数化方式，例如 令 \\lambda = x ，则 y = y(x) 。 ** 令 \\lambda = x ，则 \\dot{y} = \\frac{dy}{dx} 。长度泛函变为：\nS = \\int \\sqrt{\\left( 1 + a^2 \\right) + 2ab \\frac{dy}{dx} + \\left( 1 + b^2 \\right) \\left( \\frac{dy}{dx} \\right)^2} \\, dx. 定义拉格朗日量：\nL = \\sqrt{\\left( 1 + a^2 \\right) + 2ab y' + \\left( 1 + b^2 \\right) \\left( y' \\right)^2}. 由于 L 不显式依赖于 y ，应用贝尔特拉米恒等式（Beltrami identity），得：\nL - y' \\frac{\\partial L}{\\partial y'} = \\text{常数}. 计算：\n\\frac{\\partial L}{\\partial y'} = \\frac{2ab + 2\\left(1 + b^2\\right)y'}{2L} = \\frac{ab + \\left(1 + b^2\\right)y'}{L}. 代入恒等式：\nL - y' \\cdot \\frac{ab + \\left(1 + b^2\\right)y'}{L} = \\frac{\\left(1 + a^2\\right) + 2aby' + \\left(1 + b^2\\right)y'^2 - \\left(ab y' + \\left(1 + b^2\\right)y'^2\\right)}{L} = \\frac{1 + a^2 + ab y'}{L} = \\text{常数}. 因此我们导出斜率 y' 为常数。故，极值曲线满足：\ny = mx + c, 其中 m 和 c 为常数。\n接下来，通过引入一个固定点 (x_0, y_0) ，我们可以参数化任何一条直线，而不受限于是否经过原点。例如：\n\\begin{cases} x(\\lambda) = x_0 + \\alpha \\lambda, \\\\ y(\\lambda) = y_0 + \\beta \\lambda, \\end{cases} 这里， (x_0, y_0) 可以是直线上的任意一点，借助该点，我们可以根据上面的参数化方程来得到另一个点，两点可确定一条直线，于是我们就可以参数化任意一条直线。其中， \\alpha 和 \\beta 定义了直线的方向（满足 \\frac{\\beta}{\\alpha} = m=\\tan(\\theta) ）。\n","cover":null,"tags":["经典力学"],"title":"第一章习题","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/"},{"content":"本章将介绍几个基本概念，包括预处理指令、函数、变量和语句，这些概念是编写即使是最简单程序所必需的。后续章节将对这些主题进行更详细的讲解。\n首先，第2.1节展示了一个简单的C程序，并介绍了如何编译和链接它。接着，第2.2节讨论了如何将该程序进行泛化，第2.3节展示了如何添加解释性注释。第2.4节介绍了变量，它们存储在程序执行过程中可能会改变的数据，第2.5节展示了如何使用scanf函数将数据读入变量中。常量——在程序执行过程中不会改变的数据——可以被命名，第2.6节对此进行了说明。最后，第2.7节解释了C语言创建名称（标识符）的规则，第2.8节给出了程序布局的规则。\n2.1 写一个简单的程序 与某些编程语言编写的程序不同，C语言程序需要的“样板代码”很少——一个完整的程序可以短到只有几行。\n程序：打印一个双关语\nKernighan和Ritchie的经典著作《C程序设计语言》中的第一个程序非常简短：它什么也不做，只是输出信息“hello, world”。与其他C语言作者不同，我不会使用这个程序作为我的第一个例子。然而，我会遵循另一个C语言传统：一个坏的双关语。这里是这个双关语：\nTo C, or not to C: that is the question.\n以下程序，我们将其命名为 pun.c，每次运行时都会显示该消息：\n1 2 3 4 5 6 7 8 9 /* #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); return 0; } */ 第2.2节会详细解释这个程序的结构。现在，我将简要做几点观察。该行\n/* #include \u0026lt;stdio.h\u0026gt; */\n是为了“包含”有关 C语言标准I/O（输入/输出）库 的信息。程序的可执行代码放在 main 函数内，它代表了 “主”程序。main 函数内的唯一一行是一个显示所需消息的命令。printf 是标准I/O库中的一个函数，可以生成格式良好的输出。\\n 代码告诉 printf 在打印消息后跳到下一行。\n/* return 0; */\n表示当程序终止时，它将“返回”值 0 给操作系统。\n翻译和链接\n尽管程序很简短，但让 pun.c 运行比你想象的要复杂。首先，我们需要创建一个名为 pun.c 的文件，文件中包含程序代码（任何文本编辑器都可以使用）。文件的名称不重要，但 .c 扩展名通常是编译器所要求的。\n接下来，我们需要将程序转换为机器可以执行的形式。对于C程序，通常涉及三个步骤：\n预处理(Preprocessing) 程序首先交给 预处理器(preprocessor)，它执行以 # 开头的命令（称为 指令 directives）。预处理器有点像编辑器；它可以向程序中添加内容并进行修改。 编译(Compiling) 修改后的程序接着送入 编译器(compiler)，编译器将其转换为机器指令（目标代码 object code）。不过，程序此时还不能运行。 链接(Linking) 在最后一步，链接器(linker) 将编译器生成的目标代码与任何额外的代码组合，形成一个完整的可执行程序。这些额外的代码包括程序中使用的库函数（如 printf）。 幸运的是，这个过程通常是自动化的，因此你不会觉得它太繁琐。实际上，预处理器通常与编译器集成在一起，所以你可能甚至不会注意到它在工作。\n编译和链接所需的命令因编译器和操作系统而异。在UNIX系统下，C编译器通常命名为cc。要编译和链接pun.c程序，在终端或命令行窗口中输入以下命令：\n/* % cc pun.c */\n（%字符是UNIX的提示符，不是需要输入的内容。）在使用cc时，链接是自动进行的；无需单独的链接命令。\n编译和链接程序后，cc默认会将可执行程序保存在一个名为a.out的文件中。cc有很多选项，其中一个选项（-o选项）是一个编译器选项，用来指定生成的输出文件的文件名。它后面跟着的是输出文件的名称。例如，如果我们希望pun.c的可执行版本命名为pun，我们可以输入以下命令：\n/* % cc -o pun pun.c */\ncc：表示调用 C 编译器（通常是 gcc 或其他编译器）。 -o：指定输出文件的名称。 pun：这是编译后的输出文件的名称，即生成的可执行文件。 pun.c：这是输入的源代码文件，即将要编译的 C 文件。 最流行的C编译器之一是GCC编译器，它随Linux一起提供，但也可用于许多其他平台。使用这个编译器与使用传统的UNIX cc 编译器类似。例如，要编译 pun.c 程序，我们可以使用以下命令：\n/* % gcc -o pun pun.c */\n集成开发环境\n到目前为止，我们假设使用的是通过在操作系统提供的特殊窗口中输入命令来调用的“命令行”编译器。另一种选择是使用 集成开发环境（integrated development environment,IDE），这是一种软件包，允许我们在不离开环境的情况下编辑、编译、链接、执行甚至调试程序。IDE的各个组件旨在协同工作。例如，当编译器检测到程序中的错误时，它可以安排编辑器高亮显示包含错误的行。不同的IDE有很大的差异，因此我在本书中不会进一步讨论它们。然而，我建议检查一下适用于您的平台的IDE。\n","cover":null,"tags":["编程基础"],"title":"2.1  写一个简单的程序","url":"/notes/computer-science-and-technology/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/c/c++%E7%BC%96%E7%A8%8B/c-programming-a-modern-approach/2.1/"},{"content":"定义 1.（序列） 定义域为自然数集的函数 f : \\mathbb{N} \\to X 称为序列。\n函数 f(n) 的值 f(n) 称为 序列的项。通常用集合 X 的元素所对应的符号来表示序列的项，并让自变量对应的符号作为其下标： x_n := f(n) 。因此，我们用符号 \\{ x_n \\} 来表示序列本身，有时也把它写为 x_1, x_2, \\dots, x_n, \\dots 的形式，并称之为 集合 X 中的序列 或 集合 X 的元素序列。\n元素 x_n 称为序列的第 n 项。\n在下面几节中，我们只讨论实数列 f : \\mathbb{N} \\to \\mathbb{R} 。\n定义 2.（序列的极限） 数 A\\in \\mathbb{R} 数列 \\{ x_n \\} 的极限，如果对于点 A 的任何一个领域 V(A) ，都存在序号 N （其选取与 V(A) 有关），使得数列中所有序号大于 N 的项都包含在点 A 的上述邻域 V(A) 中。\n我们将在下面给出这个定义的形式逻辑写法，这里首先指出数列极限定义的另一种常见的表达。\n数列 A \\in \\mathbb{R} 称为数列 \\{ x_n \\} 的极限，如果对于任何 \\epsilon \u003e 0 ，都存在序号 N ，使得对于一切 n \u003e N ，都有 | x_n - A | \u003c \\epsilon 。\n如果注意到点 A 的任何一个领域 V(A) 都包含该点的某个 \\epsilon 邻域，就容易验证这两种表达的等价性。\n现在我们来验证以上两种说法的等价性：\n1.“领域”定义的极限和 \\varepsilon -\\delta 定义的极限的等价性证明\n这种定义的本质在于，实数系 \\mathbb{R} 上的拓扑是由度量诱导的，每个点 A 的邻域可以用适当的 \\epsilon 邻域来描述。这意味着“对于每个邻域 V(A) ”与“对于任意 \\epsilon \u003e 0 ”在实数轴上是等价的表达方式。证明的关键在于：\n任意给定的 \\epsilon -邻域 (A - \\epsilon, A + \\epsilon) 都是 A 的一个邻域。\n对于给定的任一邻域 V(A) ，都可以找到一个 \\epsilon -邻域 (A - \\epsilon, A + \\epsilon) 使得该 \\epsilon 邻域包含在所给的 V(A) 中。\n通过这两个事实，可以从“邻域”定义的极限转换为“ \\epsilon - \\delta ”定义的极限，反之亦然，从而证明三者等价。\n详细证明过程：\n(1) 从邻域定义推得 \\epsilon -定义：\n设 A 是数列 (x_n) 的极限，满足邻域版本的定义：\n对于点 A 的任意一个邻域 V(A) ，存在在 n \u003e N 时， x_n \\in V(A) 。\n现在取任意 \\epsilon \u003e 0 。考虑 \\epsilon -邻域 (A - \\epsilon, A + \\epsilon) 作为 V(A) 的一个具体选择。由邻域定义的极限性质可知，存在 N 使得当 n \u003e N 时， x_n \\in (A - \\epsilon, A + \\epsilon) 。\n这等价于 | x_n - A | \u003c \\epsilon 。这样就由邻域定义得到了标准的 \\epsilon - \\delta 定义。\n(2) 从 \\epsilon -定义推得邻域定义：\n现在假设 A 是数列 (x_n) 的极限，满足 \\epsilon -定义：\n对于任意 \\epsilon \u003e 0 ，存在在 n \u003e N 时 | x_n - A | \u003c \\epsilon 。\n给定任意邻域 V(A) ，由于在实数轴上邻域都可以用开区间描述，即对于点 A 存在 \\delta \u003e 0 使得 (A - \\delta, A + \\delta) \\subset V(A) 。\n依据于 \\epsilon -定义的极限定义，取 \\delta = \\epsilon ，便存在在 n \u003e N 时 | x_n - A | \u003c \\delta ，即 x_n \\in (A - \\delta, A + \\delta) \\subset V(A) 。这样就从 \\epsilon -定义的极限转换为邻域定义的极限。\n极限定义的后一种表达的意思是，在用数列 (x_n) 去逼近数 A 时，无论我们给出怎样的精度 \\epsilon \u003e 0 ，总能够找到序号 N ，使得绝对误差在 n \u003e N 时小于 \\epsilon 。\n现在用逻辑符号写出极限定义的以上表达，并约定用符号 \\lim_{n \\to \\infty} x_n = A 表示数列 (x_n) 的极限。于是，\n\\boxed{\\left( \\lim_{n \\to \\infty} x_n = A \\right) := \\forall V(A) \\exists N \\in \\mathbb{N} \\forall n \u003e N ( x_n \\in V(A) )} 相应地，\n\\boxed{\\left( \\lim_{n \\to \\infty} x_n = A \\right) := \\forall \\epsilon \u003e 0 \\exists N \\in \\mathbb{N} \\forall n \u003e N ( | x_n - A | \u003c \\epsilon )}. 定义 3.（收敛、发散数列） 如果 \\lim_{n \\to \\infty} x_n = A ，我们就说数列 \\{ x_n \\} 收敛于 A 或趋近于 A ，并记作：\n当 n \\to \\infty 时 x_n \\to A 。\n有极限的数列称为收敛数列，没有极限的数列称为发散数列。\n讨论一些例子。\n例 1. \\lim_{n \\to \\infty} \\frac{1}{n} = 0 ，因为当 n \u003e N=\\left[\\frac{1}{\\varepsilon}\\right] 1 时：\n\\left| \\frac{1}{n} - 0 \\right| = \\frac{1}{n} \u003c \\epsilon 。\n例 2. \\lim_{n \\to \\infty} \\frac{n + 1}{n} = 1 ，因为当 n \u003e N=\\left[\\frac{1}{\\varepsilon}\\right] 时：\n\\left| \\frac{n + 1}{n} - 1 \\right| = \\frac{1}{n} \u003c \\epsilon 。\n例 3. \\lim_{n \\to \\infty} \\left( 1 + \\frac{(-1)^n}{n} \\right) = 1 ，因为当 n \u003e N=\\left[\\frac{1}{\\varepsilon}\\right] 时，\n\\left| \\left( 1 + \\frac{(-1)^n}{n} \\right) - 1 \\right| = \\frac{1}{n} \u003c \\epsilon 。\n例 4. \\lim_{n \\to \\infty} \\frac{\\sin n}{n} = 0 ，因为当 n \u003e N=\\left[\\frac{1}{\\varepsilon}\\right] 时，\n\\left| \\frac{\\sin n}{n} - 0 \\right| \\leq \\frac{1}{n} \u003c \\epsilon 。\n例 5. \\lim_{n \\to \\infty} \\frac{1}{q^n} = 0 ，如果 |q| \u003e 1 。\n我们根据极限的定义进行验证。对于任意 \\epsilon \u003e 0 ，可以找到一个数 N \\in \\mathbb{N} ，使得 \\frac{1}{|q|^N} \u003c \\epsilon 。因为 |q| \u003e 1 ，所以对于任意 n \u003e N 都有：\n\\left| \\frac{1}{q^n} - 0 \\right| = \\frac{1}{|q|^n} \u003c \\frac{1}{|q|^N} \u003c \\epsilon 。\n从而使极限的定义得到满足。\n例 6. 第 n 项为 x_n = n^{(-1)^n} （ n \\in \\mathbb{N} ）的数列 1, 2, \\frac{1}{3}, 4, \\frac{1}{5}, 6, \\frac{1}{7}, \\dots 是发散的。\n其实，如果 A 是数列的极限，则根据极限的定义，在 A 的任何一个邻域以外只可能有有限的项。\n数列 A \\neq 0 不可能是该数列的极限，因为当 \\epsilon = \\frac{|A|}{2} 时，数列中形如 \\frac{1}{2k + 1} 的项在 \\frac{1}{2k + 1} \u003c \\frac{|A|}{2} 时位于 A 的 \\varepsilon 邻域之外。\n数列 0 也不可能是这个数列的极限，因为，例如，在以 0 为中心的单位邻域之外，显然也有该数列的无穷多项。\n例 7. 可以类比地验证，数列 1, -1, 1, -1, \\dots （ x_n = (-1)^n ）没有极限。\n[x] 表示数 x 的整数部分。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":["数学分析"],"title":"3.1  序列的极限","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/3.1/"},{"content":"1.4.1 泛函极值的必要条件 为什么两点之间直线最短？如何使得平面上固定长度曲线所围区域面积最大？什么循环过程效率最高？轨道形状如何小球下落时间最短？\n有了泛函的概念，这些问题可以归结为当函数（输入）取什么形式时，泛函的值（输出）取极值。在变分法中，这被称为泛函极值问题。在实际问题中，我们关心的并不是泛函的全部信息，而往往是泛函的极值。\n假设泛函 S[f] 在 f(t) = \\bar{f}(t) 时取到极大（小）值，这意味着，任何对 \\bar{f} 的小偏离 \\bar{f} + \\epsilon \\delta f ，都会使得 S[\\bar{f} + \\epsilon \\delta f] 的值比 S[\\bar{f}] 小（大）。只有当不发生偏离，即 \\delta f = 0 时取到极值。从另一个角度，这等价于 S[\\bar{f} + \\epsilon \\delta f] 作为 \\epsilon 参量的普通函数，在 \\epsilon = 0 时取到极值。\n这样就将泛函极值问题转化为普通函数的极值问题。而我们已经知道，普通函数的极值即要求其一阶导数为零。结合泛函导数的定义，我们有\n\\delta S[\\bar{f}] = \\int dt \\left. \\frac{\\delta S[f]}{\\delta f} \\right|_{\\bar{f}} \\delta f(t) = \\left. \\frac{d S[\\bar{f} + \\epsilon \\delta f]}{d \\epsilon} \\right|_{\\epsilon=0} = 0 由此得到，泛函在 f(t) = \\bar{f}(t) 时取到极值，即要求泛函的一阶变分*为零\n\\delta S[\\bar{f}] = 0 其意义是在函数（输入）发生小变化时，泛函的值（输出）不变。等价的，这意味着泛函在 \\bar{f}(t) 处的一阶泛函导数为零\n\\left. \\frac{\\delta S[f]}{\\delta f} \\right|_{\\bar{f}} = 0 需要说明的是，正如一阶导数为零只是函数取到极值的必要而非充分条件，一阶泛函导数为零也只是泛函取到极值的必要而非充分条件。严格来说， \\delta S=0 并非对于泛函一定取到极值，但是一定是 恒稳（stationary） 的。\n作为变分法到目前的小结，可将多元函数与泛函做一个对比：\n1.4.2 欧拉—拉格朗日方程 一类常见的泛函具有如下的形式\nS[f]=\\int dt L(t,f(t),f'(t)) 其特点是，泛函的被积函数 L 最高包含 f 的一阶导数。物理中大多数感兴趣的系统都是类似这样的形式。根据上一节的讨论，泛函取极值的必要条件是\n\\begin{aligned} \\delta S[q(t)] \u0026 =\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q} \\delta q+\\frac{\\partial L}{\\partial \\dot{q}} \\delta \\dot{q}\\right) \\\\ \u0026 =\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q} \\delta q+\\frac{\\partial L}{\\partial \\dot{q}} \\frac{\\mathrm{d}}{\\mathrm{d} t} \\delta q\\right) \\\\ \u0026 =\\left.\\frac{\\partial L}{\\partial \\dot{q}} \\delta q\\right|_{t_{1}} ^{t_{2}}+\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q}-\\frac{\\mathrm{d}}{\\mathrm{d} t} \\frac{\\partial L}{\\partial \\dot{q}}\\right) \\delta q\\\\ \u0026\\simeq \\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q}-\\frac{\\mathrm{d}}{\\mathrm{d} t} \\frac{\\partial L}{\\partial \\dot{q}}\\right) \\delta q\\\\ \\end{aligned}\\\\ \\boxed{- \\frac{\\delta S}{\\delta f} \\equiv \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) - \\frac{\\partial L}{\\partial f} = 0} 上式是关于 f(t) 的二阶微分方程，被称为变分问题的 欧拉—拉格朗日方程（Euler-Lagrange equation） 。其意义是，泛函式\nS[f] = \\int dt L(t, f(t), f'(t)) 在 f=f(t) 处取到极值的必要条件是 f(t) 满足欧拉拉格朗日方程。\n并不是所有的微分方程都是欧拉拉格朗日方程，即都对应某个泛函的极值。\n对 L 直接求全导数\n\\begin{aligned} \\frac{dL}{dt} \u0026= \\frac{\\partial L}{\\partial t} + \\frac{\\partial L}{\\partial f} f' + \\frac{\\partial L}{\\partial f'} f'' \\\\ \u0026= \\frac{\\partial L}{\\partial t} + \\frac{\\partial L}{\\partial f} f' + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) f' \\\\ \u0026= \\frac{\\partial L}{\\partial t} + \\underbrace{\\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) \\right] f'}_{=0} + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) \\end{aligned} \\frac{dL}{dt} = \\frac{\\partial L}{\\partial t} + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right). \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{dL}{dt} = - \\frac{\\partial L}{\\partial t}. 注意到 \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) = \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{dL}{dt} ，因此有\n\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) = - \\frac{\\partial L}{\\partial t}. 将 - \\frac{\\partial L}{\\partial t} 移到左侧，就得到\n\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) + \\frac{\\partial L}{\\partial t} = 0. 因此，当欧拉—拉格朗日方程*满足时，下式也成立\n\\boxed{\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) + \\frac{\\partial L}{\\partial t} = 0} 一个立即的推论是，若 L 不显含变量 t \\frac{\\partial L}{\\partial t} = 0 \\quad \\Rightarrow \\quad \\frac{\\partial L}{\\partial f'} f' - L = \\text{常数} 对于更一般的泛函式，其取极值的必要条件是\n\\frac{\\delta S}{\\delta f} \\equiv \\sum_{n=0} (-1)^n \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) = 0 如果泛函式中的被积函数 L 包含 f(t) 的最高到 n 阶导数，即 L = L(t, f, f', \\cdots, f^{(n)}) 则上面的求和展开为\n\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\cdots + (-1)^n \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) \\frac{\\delta S}{\\delta f} 中 f(t) 的最高阶导数来自最后一项。如果 \\frac{\\partial L}{\\partial f^{(n)}} 仍然包含 f^{(n)} ，即\n\\frac{\\partial}{\\partial f^{(n)}} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) = \\frac{\\partial^2 L}{\\partial f^{(n)} \\partial f^{(n)}} \\neq 0 则 \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) 包含最高至 f(t) 的 2N 阶导数，满足上式的 L 也被称为是 非退化的（non-degenerate）。总之，如果泛函导数* \\frac{\\delta S}{\\delta f} 包含 f(t) 最高至 2N 阶导数，相应的泛函极值的欧拉—拉格朗日方程为 2N 阶微分方程。\n1.4.3 多个变量和多元函数 到目前为止，我们只讨论了只依赖单个函数 f(t) 的泛函，即 S = S[f] 。以上所有讨论对于多个独立函数 f_1(t), f_2(t), \\cdots 的泛函的推广是直接的。考虑泛函\nS = S[f_1, f_2, \\cdots] = \\int \\mathrm{d}x L(t, f_1, f_2, \\cdots, f_1', f_2', \\cdots). 其极值同样要求\n\\delta S \\simeq \\int \\mathrm{d}x \\left( \\frac{\\delta S}{\\delta f_1} \\delta f_1 + \\frac{\\delta S}{\\delta f_2} \\delta f_2 + \\cdots \\right) = 0. 因为函数 f_1, f_2, \\cdots 是独立的，其变分 \\delta f_1, \\delta f_2, \\cdots 也是互相独立的，因此上式成立必然要求每一项的系数都为零，于是泛函取极值即要求\n\\frac{\\delta S}{\\delta f_1} = 0, \\quad \\frac{\\delta S}{\\delta f_2} = 0, \\quad \\cdots. 泛函中的函数也可以是多元函数。以单个函数 f 的泛函 S[f] 为例，设 f 是 t 和 x 的二元函数 f = f(t,x) 。简单起见，我们只考虑 L 含有 f 的一阶导数，泛函具有形式\nS[f] = \\iint \\mathrm{d}t \\mathrm{d}x L \\left( t, x, f, \\frac{\\partial f}{\\partial t}, \\frac{\\partial f}{\\partial x} \\right). 同样按照 1.3.3 节中的步骤，泛函的一阶变分为\n\\delta S = \\iint \\mathrm{d}t \\mathrm{d}x \\delta L \\left( t, x, f, \\frac{\\partial f}{\\partial t}, \\frac{\\partial f}{\\partial x} \\right) = \\iint \\mathrm{d}t \\mathrm{d}x \\left[ \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial t} \\right)} \\delta \\left( \\frac{\\partial f}{\\partial t} \\right) + \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial x} \\right)} \\delta \\left( \\frac{\\partial f}{\\partial x} \\right) \\right]. \\approx \\iint \\mathrm{d}t \\mathrm{d}x \\left[ \\frac{\\partial L}{\\partial f} - \\frac{\\partial}{\\partial t} \\left( \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial t} \\right)} \\right) - \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial x} \\right)} \\right) \\right] \\delta f, 所以泛函取极值的必要条件即\n\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{\\partial}{\\partial t} \\left( \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial t} \\right)} \\right) - \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial L}{\\partial \\left( \\frac{\\partial f}{\\partial x} \\right)} \\right) = 0, \\tag{1.51} 其是 f(t,x) 的偏微分方程。以上讨论对多个多元函数的泛函的推广是直接的。\n","cover":null,"tags":["经典力学"],"title":"1.4 泛函极值","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.4/"},{"content":"2.3.1 速度相空间 人类只能了解一时一地的信息，却要预测无穷无限的世界.一个问题是，我们需要知道多少信息，才能完全预测系统的演化?这个问题可以进一步在数学上表述为，我们需要知道一个函数在某一点的多少信息，才能完全决定其函数形式?答案己经由泰勒公式告诉我们了：\nf(t) = f(t_0) + f'(t_0)(t - t_0) + \\frac{1}{2}f''(t_0)(t - t_0)^2 + \\frac{1}{3!}f'''(t_0)(t - t_0)^3 + \\cdots. 亦即，完全决定一个函数的形式（至少在某点附近），需要知道函数在某点的无穷阶导数。换句话说，如果我们要预测一个粒子未来的运动，我们需要测量“此时此刻”粒子的位置、速度、加速度、加加速度、加加加速度……即无穷多的信息！幸运的是，对于自然界中绝大部分物理系统，我们只需要测量“位置”和“速度”就可以了。要做到这一点，唯一的可能就是二阶及以上的导数都由函数在某点的值及其一阶导数完全决定，亦即存在如下的关系：\nf''(t) = F\\big(f(t), f'(t)\\big). \\tag{2.8} 可以验证，对式 (2.8) 再求导，即有\nf'''(t) = \\frac{\\partial F}{\\partial f} f' + \\frac{\\partial F}{\\partial f'} f'' = \\frac{\\partial F}{\\partial f} f' + \\frac{\\partial F}{\\partial f'} F\\big(f, f'\\big). 可见三阶导数也可以由函数及其一阶导数决定。更高阶的导数，依此类推。式 (2.8) 不是别的，正是 f(t) 所满足的二阶微分方程。而数学家早已告诉我们，确定二阶微分方程的一个定解需要两个初始条件——位置和速度。于是，虽然“觉宇宙之无穷”，也可以做到“识盈虚之有数”了。\n对于一般的物理系统，从广义坐标 \\{\\boldsymbol{q}\\} 出发，广义速度（generalized velocity）定义为广义坐标的时间导数：\nv^a := \\frac{dq^a(t)}{dt} = \\dot{q}^a, \\quad a = 1, \\cdots, s. \\tag{2.9} 所以，只要系统位形的演化满足二阶微分方程，那么知道此时此刻的广义坐标及其一阶导数——广义速度，就可以完全确定此后任意时刻系统的演化。从这个意义上说，“坐标”与“速度”即包含系统演化的全部信息。“坐标”与“速度”合在一起，构成系统的状态（state）。知道某一时刻的状态，原则上就知道了此前或此后任一时刻的状态。\n物理系统所有可能状态的集合，即状态空间，也被称作 相空间(phase space).相空间的概念在现代物理学中几乎无处不在，被誉为\u0026quot;现代科学中最强大的发明之一\u0026quot;。\n这里的“相”指的就是系统的状态。具体到“坐标”和“速度”构成的状态空间，被称为速度相空间（velocity phase space）。速度相空间中的一点 \\{\\boldsymbol{q}, \\dot{\\boldsymbol{q}}\\} ，代表系统的一种可能的状态。因此，\n\\text{相空间的维数} = \\text{唯一确定系统演化的独立参数的个数}。 \\tag{2.10} 对于点粒子系统，相空间的维数总是偶数维的。这是因为点粒子系统的运动方程总是需要偶数个初始条件。\n将时间轴加入进来，相空间中的点也随时间演化扫出一条条的曲线，如图 2.8 所示。但是因为给定一个时刻的状态，就唯一决定了此前和此后所有时刻的状态，所以，相空间中的点随时间扫出的曲线是永不相交的。\n给定系统状态的初始值，就可以得到唯一一条相流曲线.因此，系统运动方程的通解就是一族曲线.这族曲线在相空间的投影即所谓\u0026quot;相轨迹\u0026quot;或者\u0026quot;相流\u0026quot;，相应的图被称作\u0026quot;相图\u0026quot;，我们将在第13 章对此进行讨论.\n2.3.2 广义坐标的变换所诱导的广义速度的变换 在式 (2.4) 的坐标变换下，广义速度的变换为\n\\dot{\\tilde{q}}^a \\equiv \\frac{d \\tilde{q}^a}{dt} = \\sum_{b=1}^s \\frac{\\partial \\tilde{q}^a}{\\partial q^b} \\dot{q}^b, \\tag{2.11} 其中 \\frac{\\partial \\tilde{q}^a}{\\partial q^b} 即坐标变换的雅可比矩阵，逆变换即\n\\dot{q}^a \\equiv \\frac{d q^a}{dt} = \\sum_{b=1}^s \\frac{\\partial q^a}{\\partial \\tilde{q}^b} \\dot{\\tilde{q}}^b, \\tag{2.12} 其中 \\frac{\\partial q^a}{\\partial \\tilde{q}^b} 即 \\frac{\\partial \\tilde{q}^a}{\\partial q^b} 的逆（见式 (2.7)）。雅可比矩阵 \\frac{\\partial \\tilde{q}^a}{\\partial q^b} 和 \\frac{\\partial q^a}{\\partial \\tilde{q}^b} 都只是广义坐标的函数，因此还可得到\n\\frac{\\partial \\dot{\\tilde{q}}^a}{\\partial \\dot{q}^b} = \\frac{\\partial \\tilde{q}^a}{\\partial q^b}, \\quad \\frac{\\partial \\dot{q}^a}{\\partial \\dot{\\tilde{q}}^b} = \\frac{\\partial q^a}{\\partial \\tilde{q}^b} \\tag{2.13}\n即广义速度之间的偏导数关系等于广义坐标之间的偏导数关系。数学上，这正是广义速度作为逆变矢量（见 3.2.5 节）在广义坐标变换下的变换关系。\n2.3.3 相空间和位形空间的联系和区别 1. 位形空间 (Configuration Space)\n位形空间描述的是一个系统的所有可能位置配置，而不考虑动量或速度。它通常用于描述一个系统在某一时刻的静态配置。在经典力学中，位形空间是系统的所有粒子坐标的集合。例如：\n对于一个质点，位形空间只是它的一个位置向量 \\boldsymbol{r} 。 对于多粒子系统，位形空间是所有粒子位置坐标的集合： \\{\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\ldots, \\boldsymbol{r}_n\\} ，其中 n 是粒子的数量。 位形空间的维度通常与系统中粒子的数量及其自由度（如每个粒子的空间维度）有关。对于 N 个粒子的系统，在三维空间中，位形空间的维度为 3N 。\n2. 相空间 (Phase Space)\n相空间是一个更全面的描述，考虑了系统中所有粒子的位置和动量。相空间是一个包含系统中粒子的位置信息和动量的空间。对于每个粒子，动量是与其位置相对应的量。每一个点在相空间中都代表系统的一个可能状态，既包括粒子的位置，也包括它的动量。\n对于一个质点，系统的状态在相空间中由其位置和动量描述，即 (\\boldsymbol{r}, \\boldsymbol{p}) ，其中 \\boldsymbol{p} 是质点的动量。 对于多粒子系统，相空间是所有粒子的位置信息和动量坐标的集合，维度为 6N （每个粒子有 3 个位置坐标和 3 个动量坐标）。 3. 关系\n相空间和位形空间的联系体现在它们都用于描述系统的状态。位形空间是描述系统静态状态（仅考虑位置），而相空间则进一步扩展了这种描述，涵盖了系统的动态行为（包括动量或速度）。\n相空间的轨迹描述了系统状态的演变，即随时间的变化，系统从一个状态（位置和动量的特定组合）移动到另一个状态。而位形空间则只能描述系统的静止或不变配置。\n4. 区别\n维度差异：位形空间仅涉及位置坐标，因此其维度通常较低。而相空间不仅考虑位置，还包括动量，维度通常是位形空间的两倍。例如，单粒子的相空间维度是 2（位置和动量），而位形空间的维度是 1（位置）。\n物理信息：位形空间只提供系统在某一时刻的配置，缺少对系统动力学的全面描述；相空间则提供了系统的完整描述，不仅包括位置，还包含粒子的动量或速度，能够完整地捕捉系统的动态行为。\n应用：位形空间常用于静力学分析或几何学分析（如研究系统的对称性），而相空间在动力学分析中具有更广泛的应用，特别是在描述系统的演化、热力学性质（如在统计物理中）等方面。\n2.3.4 相空间世界线和决定论 2.3.4.1 相空间世界线 在位形和时间演化一节中，我们讨论了位形空间的世界线所可能发生的情况。当时的结论是，位形空间的世界线是可以相交的。\n对于左图位形空间世界线的相交，其含义可解释为：在同一时间，物体处于同一位置。\n在经典力学中，如果没有对物体本质上的排斥作用进行限制（比如物体的不可穿透性或体积的约束），两个物体占据同一位置是可以发生的，尤其是在理论分析中。以下是一些例子：\n点粒子模型 如果我们假设两个物体是理想化的点粒子（没有体积和扩展性），它们的世界线可以在位形空间中相交，这意味着在某一时刻它们占据相同的位置。 两颗理想点粒子可以在某一时刻通过同一空间点，而它们的速度（动量）不同。 不考虑斥力的情况 在经典模型中，如果没有考虑物体间的排斥作用或相互作用，那么两个物体在同一位置的“重合”并不违反任何物理定律。例如，一个上抛的物体和一个自由下落的物体可以在某一瞬间在同一高度相遇。 在实际物理系统中，物体是否能够占据相同的空间位置通常受到物理限制：\n(1) 不可穿透性\n实际物体具有有限的空间扩展性和体积（即不是点粒子）。因此，两个物体在同一时刻占据完全相同的坐标会引发碰撞，因为它们会由于不可穿透性而排斥开来。 这种情形会触发物理相互作用，例如弹性碰撞或塑性变形。这时，两个物体会暂时接触，而不是在数学意义上的“完全重合”。 (2) 量子力学效应\n在量子力学中，粒子并非经典的点粒子，而是具有波动性的实体。在这种情况下，“重合”更有可能被解释为两粒子的波函数在某处发生重叠，而不是经典意义上的经典粒子重合。\n例如，对于玻色子，它们可以在同一位置完全重叠（玻色-爱因斯坦凝聚现象）。 对于费米子，由于泡利不相容原理，两个费米子（如电子）不可能在同一时刻占据完全相同的量子态，即使位置相同，其动量自旋等量子数字也必须不同。 1. 量子态的概念 在量子力学中，粒子的状态由波函数 \\psi(\\boldsymbol{r}) 描述，波函数的模平方 |\\psi(\\boldsymbol{r})|^2 表示粒子在某一位置 \\boldsymbol{r} 的概率密度。量子态是由波函数确定的，包括以下信息：\n空间位置（如位置分布函数）； 动量（或速度）； 内禀量子数（如自旋、角动量）。 对于玻色子，它们可以同时占据完全相同的量子态，意味着它们的波函数不仅可以共享相同的动量、自旋等，还可以在相同的位置出现。\n2. 玻色子的对称性 玻色子的核心性质来源于量子力学的对称化原理，具体来说，系统的多粒子波函数必须对玻色子交换是对称的。假设有两个玻色子 A 和 B ，它们的波函数分别是 \\psi_A(\\boldsymbol{r}) 和 \\psi_B(\\boldsymbol{r}) ，总波函数可以写作：\n\u003e \\Psi(\\boldsymbol{r}_1, \\boldsymbol{r}_2) = \\psi_A(\\boldsymbol{r}_1)\\psi_B(\\boldsymbol{r}_2) + \\psi_B(\\boldsymbol{r}_1)\\psi_A(\\boldsymbol{r}_2). \u003e 这里，对称性意味着交换粒子后波函数保持不变：\n\u003e \\Psi(\\boldsymbol{r}_1, \\boldsymbol{r}_2) = \\Psi(\\boldsymbol{r}_2, \\boldsymbol{r}_1). \u003e 这一对称性直接导致玻色子允许占据同一量子态。例如，当 \\psi_A = \\psi_B = \\psi 时，所有玻色子共享相同的波函数，波函数写为：\n\u003e \\Psi(\\boldsymbol{r}_1, \\boldsymbol{r}_2) = \\psi(\\boldsymbol{r}_1)\\psi(\\boldsymbol{r}_2). \u003e 结果：多个玻色子可以完全“堆积”在一个量子态中\n这种对称化特性使得玻色子不像费米子那样受到泡利不相容原理限制，因此它们可以同时占据相同的量子态，包括在空间中重叠于同一位置。\n3. 多个玻色子占据相同的位置 (1) 单粒子位置波函数的叠加\n当多个玻色子占据同一量子态 \\psi(\\boldsymbol{r}) ，它们的波函数在空间中表现为相同的概率分布。例如，对于 N 个玻色子，系统波函数为：\n\u003e \\Psi(\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\ldots, \\boldsymbol{r}_N) = \\prod_{i=1}^N \\psi(\\boldsymbol{r}_i). \u003e 如果 \\psi(\\boldsymbol{r}) 是局域化的（比如集中在某一点 \\boldsymbol{r}_0 附近的高斯分布），那么这些玻色子就可以“全部集中”到相同的位置。\n(2) 玻色-爱因斯坦凝聚中的体现\n在玻色-爱因斯坦凝聚（BEC）中，玻色子会自发地凝聚到系统的基态（最低能量态）。如果基态的波函数分布主要集中在某个位置（如势阱的最低点），则所有玻色子会倾向于占据该位置，从而表现为多个粒子“堆积”在同一空间点。这种集中度甚至可以观测到，例如超冷原子气体的密度分布在 BEC 态下形成明显的峰值。\n4. 与费米子的对比 与玻色子相比，费米子由于遵循泡利不相容原理，禁止两个费米子占据完全相同的量子态。这种限制直接导致：\n费米子不会在同一时刻占据完全相同的位置，即使它们处于相同的势场中； 在费米气体中，粒子会填充不同的量子态，表现出非重叠的分布（例如，费米能级和费米表面）。 这一区别使得玻色子在空间分布上可以高度重叠，而费米子则不可能。 不过需要注意的上，这种玻色子的空间位置重叠的意思是“它们在同一位置出现的概率是相同的”，而不是经典意义上的位置重叠。在这点上，量子理论和经典理论存在不可调和的矛盾。\n在位形空间中，“重合”只反映了物体在某时刻的位置坐标相同，而并没有描述物体的其他状态信息（如速度或动量）。因此，这种“重合”并不能完全描述物理系统的实际状态。\n碰撞现象：如果在物理系统中，两个物体的世界线在位形空间中相交，这往往意味着物体在发生碰撞。例如：\n两个行星在运行轨道中交汇； 两辆车在道路上相撞。在这些情况下，世界线交点意味着两物体在同一位置，但它们的后续运动可能因碰撞过程而改变。 动态信息的缺失：位形空间无法区分“两个物体在某时刻位置相同但速度不同”与“同一个物体回到原位”这两种情况。因此，理解这一现象需要引入相空间。\n那么，为什么相空间的世界线是不可相交的呢？\n相空间不仅描述了系统的位置信息，还包括了动量（或速度）。相空间的每个点代表系统在某一时刻的完整状态（位置和动量的 组合）。因此，相空间中的时间轨迹通常是时间的单值函数：也就是说，给定一个初始状态（位置和动量），系统的时间演化是唯一确定的，不能有多条轨迹经过相同的点。\n具体来说，系统的演化受到哈密顿方程或牛顿方程的约束，这些方程规定了在给定初始条件下，系统随时间的演化是唯一且确定的。在相空间中，如果两个轨迹在某个时刻相交，那么这意味着它们在同一时刻具有相同的位置和动量，然而这会违反动力学演化的唯一性。也就是说，如果两条轨迹在相空间中交叉，它们就会有相同的初始条件，而根据物理法则，它们应该在未来的每个时刻都保持相同的演化路径，这显然是矛盾的。因此，相空间上的轨迹不能相交。\n这种唯一性可以通过 李亚普诺夫稳定性（Lyapunov Stability）的概念来理解：在经典动力学中，给定初始条件（位置和动量），系统的演化是唯一的且确定的，不能有两个不同的轨迹从相同的状态出发并沿不同路径演化。因此，相空间上的时间轨迹不可能交叉。\n2.3.4.2 决定论 只要系统位形的演化满足二阶微分方程，那么知道此时此刻的广义坐标及其一阶导数——广义速度，就可以完全确定此后任意时刻系统的演化。从这个意义上说，“坐标”与“速度”即包含系统演化的全部信息。“坐标”与“速度”合在一起，构成系统的状态（state）。知道某一时刻的状态，原则上就知道了此前或此后任一时刻的状态。\n这是我们在上文中得到的结论。再加上刚才提到的 Lyapunov Stability：如果一个系统从平衡点附近的初始状态出发，并且该状态偏离平衡点后的行为是有限的，即它不会无限制地偏离平衡点，系统称为李亚普诺夫稳定的。\n这使得我们得出经典决定论的观点。\n而基于以上的经典决定论，我们指出，在以上这些前提下，我们对于系统的计算是全局的，这种全局包括时间，即过去与未来我们都可以进行计算。\n为什么物理里面使用导数而不是左导数？ - Triborg的回答 - 知乎\n","cover":null,"tags":["经典力学"],"title":"2.3 速度、速度相空间","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/2.3/"},{"content":"在上一节中，我们已经证明了所知道的所有关于加法和序的基本事实。为了节省篇幅以及避免赘述那些显然的事情，接下来我们将允许使用所熟悉的关于加法和序的代数法则，而不加进一步的说明。于是我们可以写出 a+b+c=c+b+a 这样的内容，不需要进一步解释说明。现在我们引入乘法。正如加法是重复的增量运算一样，乘法是重复的加法运算。\n定义 2.3.1（自然数的乘法）\n令 m 表示任意一个自然数，\n我们定义 0\\times m:= 0 来表示将 0 乘到 m 上。现在归纳假设我们已经定义了 n\\times m （即把 n 乘到 m 上）。\n那么，我们可以定义\n(n++)\\times m:= (n\\times m)+m 以上，我们就定义好了自然数的乘法规则。\n引理 2.3.2 （乘法是可交换的） 令 n 和 m 表示任意两个自然数，那么有 n\\times m=m\\times n 成立。\n证明： 使用数学归纳法。\n首先我们需要证明 m\\times 0= 0 。当 m=0 时，我们有\n0\\times 0:= 0 归纳假设当 m=m 时 m\\times 0= 0 是成立的，那么现在我们来证明 m=m++ 时等式成立。\n\\begin{align} (m++)\\times 0\u0026=(m\\times 0)+0[(n++)\\times m:= (n\\times m)+m]\\\\ \u0026=0 \\end{align} 以上，我们就得到了基础情况 0\\times m=m\\times 0 。\n接下来，我们需要证明\nn\\times (m++)=(n\\times m)+n 当 n=0 时， 0\\times (m++)=0=0\\times m+0 （第一个等号来源于定义，第二个等号是为了交换形式而拼凑出来的）。假设当 n=n 时结论已经成立，即有 n\\times (m++)=(n\\times m)+n ，需证 (n++)\\times (m++)=(n++)\\times m+(n++) \\begin{align} (n++)\\times (m++)\u0026=[n\\times(m++)]+(m++)\\\\ \u0026=n\\times m+n+(m++)\\\\ \u0026=n\\times m+m+(n++)\\\\ \u0026=(n++)\\times m+(n++) \\end{align} 其中第三个等号是因为\n\\begin{align} \u0026n+(m++)=n+(m+1)\\\\ \u0026(n++)+m=(n+1)+m\\\\ \u0026n+(m+1)=(n+1)+m\\\\ \u0026n+(m++)=(n++)+m \\end{align} 综上,引理得证。\n我们将把 n\\times m 简写为 nm ，而且按照惯例，乘法运算优先于加法运算。\n引理 2.3.3（正自然数没有零因子） 令 n 和 m 表示任意两个自然数，那么 n\\times m=0 当且仅当 n 和 m 中至少有一个为 0 .\n证明： 设 n、m 均为正自然数，并且满足 n=c++、m=d++ ，其中 c、d 均为自然数。\n\\begin{aligned} \u0026 (n \\text { is positive }) \\wedge(m \\text { is positive }) \\\\ \\Rightarrow \u0026 \\exists c, d \\in N, c++=n, d++=m \\\\ \\Rightarrow \u0026 n m=(c++) \\times(d++)=c \\times(d++)+(d++)=(c \\times(d++)+d)++ \\\\ \\Rightarrow \u0026 n m \\text { is positive } \\end{aligned} 命题 2.3.4（分配律）\n对于任意自然数 a,b,c \\begin{align} \u0026a(b+c)=ab+ac\\\\ \u0026(b+c)a=ba+ca \\end{align} 均成立\n证明： 由于乘法是可交换的，因此只需要证明第一个等式 a(b+c)=ab+ac 成立即可。\n对 c 进行数学归纳。当 c=0 时，\n\\begin{align} \u0026a(b+0)=ab\\\\ \u0026ab+a0=ab\\\\ \u0026a(b+0)=ab+a0 \\end{align} 现在我们归纳性地假设 a(b+c)=ab+ac 成立，接下来要证明的是 a(b+(c++))=ab+a(c++) 。\n\\begin{align} \u0026a(b+(c++))=a[(b+c)++]\\\\ \u0026a[(b+c)++]=a(b+c)+a\\\\ \u0026ab+a(c++)=ab+ac+a \\end{align} 根据 a(b+c)=ab+ac ，因此可知 c++ 的情况亦成立。，那么到这里归纳过程就结束了。\n命题 2.3.5（乘法是可结合的）\n对于任意自然数 a,b,c (a\\times b)\\times c=a\\times(b\\times c) 均成立。\n证明：\n对 b 进行数学归纳 : 对于 0: (a \\times 0) \\times c=0 \\times c=0=a 0=a(0 \\times c) 如果 b 是正确的，即 (a\\times b)\\times c=a\\times(b\\times c) , 那么\n\\begin{array}{l} (a(b++)) c=(a b+a) c=(a b) c+a c \\\\ =a(b c)+a c=a(b c+c)=a((b++) c) \\end{array} 命题 2.3.6（乘法保持序不变）\n如果 a,b 是满足 a","cover":null,"tags":["数学分析"],"title":"2.3  乘法","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.3/"},{"content":"1.摘要 本文公理一览：\n公理 3.1（集合是对象） 相等公理、替换公理 公理 3.2 (空集) 公理 3.3（单元素集与双元素集） 公理 3.4（两集合并集） 公理 3.5（分类公理） 公理 3.6 (替代) 公理 3.7 (无穷大) 2.正文 定义 3.1.1（非正式的）（集合）\n我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \\{3,8,5,2\\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\\in A ，否则，记作 x\\notin A 。\n这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。\n首先阐明一个观点：我们把集合本身看作一类对象。\n公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。\n到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \\in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \\in A 是无定义的。例如， 3 \\in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。）\n接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合 \\{3, 8, 5, 2\\} 与 \\{2, 3, 5, 8\\} 看作同一个集合。另外， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5, 2, 1\\} 是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素 1 。基于类似的原因， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5\\} 也是不同的集合。我们把这部分内容作为一个定义。\n定义 3.1.4（集合的相等） 称两个集合 A 和 B 是相等的，即 A = B ，当且仅当 A 中的每个元素都是 B 中的元素并且 B 中的每一个元素也都是 A 中的元素。也就是说， A = B ，当且仅当 A 中的任一元素 x 属于 B ，同时 B 中的任一元素 y 也属于 A ，这记为 (\\forall x \\in A, x \\in B),(\\forall y \\in B, y \\in A) 相等是如何定义的取决于所考察对象的类型，而且从某种程度上来说，这只不过是一个关于下定义的问题而已。然而，从逻辑学的角度来说，我们要求相等遵守下面四条 相等公理 ：\n（自反公理） 给定任意的对象 x ，我们有 x = x 。 （对称公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么 y = x 。 （传递公理） 给定任意三个同类型的对象 x 、 y 和 z ，若 x = y 且 y = z ，则 x = z 。 （替换公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么对任意一个函数或者运算 f 都有 f(x) = f(y) 。类似地，对任意一个关于 x 的性质 P(x) ，如果 x = y ，那么 P(x) 和 P(y) 就是等价的命题。 容易验证，定义3.1.4满足自反、对称、传递三个性质。\n自反性（Reflexive）: (\\forall x \\in A, x \\in A) \\Rightarrow A = A 对称性（Symmetric）: (A = B) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in A) \\Rightarrow B = A 传递性（Transitive）: (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in C) \\Rightarrow (\\forall x \\in A, x \\in C) (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in B, x \\in A) \\land (\\forall x \\in C, x \\in B) \\Rightarrow (\\forall x \\in C, x \\in A) \\text{以上两种情况同时成立，这意味着 } A = C 根据定义 3.1.4 观察可知，如果 x \\in A 并且 A = B ，那么 x \\in B 。于是 “是……的元素” 这种 \\in 关系遵守替换公理。正因如此，只要我们能够把定义在集合上的新运算仅用 \\in 的语言来描述，这个新运算就会遵守替换公理。例如，对于本节中剩下的定义，情况就是这样。（另外，在良好的定义方式中，我们不能使用集合中 “第一个” 或者 “最后一个” 元素这样的概念，因为这将违背替换公理。例如，虽然集合 \\{1, 2, 3, 4, 5\\} 与 \\{3, 4, 2, 1, 5\\} 表示同一个集合，但是它们的第一个元素是不一样的。）\n面我们来讨论到底什么样的对象是集合，什么样的对象不是集合。\n这与上一章中我们如何定义自然数相类似。我们从单个的自然数 0 开始，利用增量运算从 0 中构造出更多的数。\n这里我们将尝试做类似的事情，从单个集合（空集）开始，利用各种运算从空集中构造出更多的集合。我们首先假定空集的存在性。\n公理 3.2 (空集) 存在一个集合 \\varnothing ，被称为空集，它不包含任何元素。也就是说，对于任意的对象 x 均有 x\\notin\\varnothing 。\n空集也记作 {} 。注意只能有一个空集，如果存在两个集合 \\varnothing 和 \\varnothing' 都是空集，那么根据定义3.1.4 （集合的相等）可知，它们必定相等。\n如果一个集合不等于空集，那么称该集合是非空的。下面这个命题非常简单，却值得叙述。\n引理 3.1.6（单个选取） 设 A 是一个非空集合，那么存在一个对象 x 使得 x \\in A 。\n证明： 我们用反证法来证明。假设不存在任何对象 x 使得 x \\in A ，那么对任意一个对象 x 而言，有 x \\notin A 。另外根据公理 3.2 (空集)可知： x \\notin \\varnothing 。于是 x \\in A \\iff x \\in \\varnothing （这两个命题均为假），进而根据定义 3.1.4 (集合的相等)有 A = \\varnothing ，显然这与已知条件“ A 是一个非空集合”相矛盾。\n注 3.1.7 上述引理断言，给定任意一个非空集合 A ，我们可以“选取” A 中的一个元素 x ，以此来证实 A 的非空性。\n后面（在引理 3.5.12 中）我们将证明对于给定的任意有限多个非空集合 A_1, \\cdots, A_n ，能够从每个集合 A_1, \\cdots, A_n 中分别选取一个元素 x_1, \\cdots, x_n ，这称作“有限选取”。**但是如果想要从无穷多个集合中选取元素，我们就需要另一个公理，即选择公理。**关于选择公理的讨论将留到 8.4 节。\n如果公理 3.2 （空集）是集合论中唯一一个公理，那么集合论必然相当乏味，因为在这种情况下，只有唯一一个集合存在，那就是空集。现在我们给出更深层次的公理来丰富可用集合的种类。\n公理 3.3（单元素集与双元素集）\n如果 a 是一个对象，那么存在一个集合 \\{a\\} 并且该集合中唯一的一个元素就是 a 。也就是说，对于任意一个对象 y ，我们有 y \\in \\{a\\} ，当且仅当 y=a ；我们称 \\{a\\} 是元素为 a 的 单元素集。\n更进一步地，如果 a 和 b 都是对象，那么存在一个集合 \\{a, b\\} ，并且该集合的元素只有 a 和 b 。换言之，对于任何一个对象 y ，有 y \\in \\{a,b\\} ，当且仅当， y=a 或者 y=b ，我们称该集合是由 a 和 b 所组成的双元素集。\n注 3.1.9 正如只存在唯一一个空集那样，根据定义 3.1.4 （集合的相等）可知，元素为 a 的单元素集也只有一个。类似地，给定任意两个对象 a 和 b ，那么只存在唯一一个由 a 和 b 构成的双元素集。同样，定义 3.1.4 （集合的相等）也能确保 \\{a, b\\} = \\{b, a\\} 以及 \\{a, a\\} = \\{a\\} 。于是，单元素集公理事实上是多余的，因为它是从双元素集公理中推导出的一个结论。反过来，双元素集公理可以由单元素集公理以及后面的两集合并集公理推出（参见引理 3.1.13）。人们可能会问为什么我们不继续构造三元素集公理、四元素集公理等；然而，一旦我们引入下面的两集合并集公理，就没有必要再去构造这些公理了。\n目前为止，我们构造的每一个集合所包含的元素个数都不超过两个。接下来这个公理将让我们能够构造出比之前稍大一些的集合。\n公理 3.4（两集合并集） 给定任意两个集合 A 和 B ，存在一个集合 A \\cup B 被称为 A 和 B 的 并集，该集合的元素由属于 A 的或者属于 B 的或者同时属于 A 和 B 的所有元素共同构成。换言之，对任意的对象 x ，\nx \\in A \\cup B \\iff (x \\in A \\text{ 或 } x \\in B) 回忆一下，“或”在数学中默认表示 包含，也可以说，“ X 或 Y 为真” 是指 “要么 X 为真，要么 Y 为真，要么 X 和 Y 都为真”。 参见 A.1 节。\n例 3.1.11 集合 \\{1,2\\} \\cup \\{2,3\\} 中的元素是由属于 \\{1,2\\} 的或者属于 \\{2,3\\} 的或者同时属于这两个集合的一切元素共同构成的；换言之，这个集合的元素就是 1、2 和 3。因此，我们把该集合记作 \\{1,2\\} \\cup \\{2,3\\} = \\{1,2,3\\} 。\n注 3.1.12 如果 A 、 B 和 A' 都是集合并且 A 等于 A' ，那么 A \\cup B 等于 A' \\cup B 。\n证明：\n步骤 1: 证明 A \\cup B \\subseteq A' \\cup B 假设 x \\in A \\cup B 。根据并集的定义， x \\in A \\cup B 意味着 x \\in A 或者 x \\in B 。\n如果 x \\in A ，由于 A = A' ，因此 x \\in A' ，所以 x \\in A' \\cup B 。 如果 x \\in B ，显然 x \\in A' \\cup B （因为 x \\in B ）。 因此， x \\in A' \\cup B 。从而，我们得出 A \\cup B \\subseteq A' \\cup B 。\n步骤 2: 证明 A' \\cup B \\subseteq A \\cup B 假设 x \\in A' \\cup B 。根据并集的定义， x \\in A' \\cup B 意味着 x \\in A' 或者 x \\in B 。\n如果 x \\in A' ，由于 A = A' ，因此 x \\in A ，所以 x \\in A \\cup B 。 如果 x \\in B ，显然 x \\in A \\cup B （因为 x \\in B ）。 因此， x \\in A \\cup B 。从而，我们得出 A' \\cup B \\subseteq A \\cup B 。\n结论:\n由步骤 1 和步骤 2，我们得出 A \\cup B = A' \\cup B 。 \\square 虽然以上证明显式的写出了尚未定义的集合之间的属于关系，但实际上，我们完全可以删掉这些属于号，而只使用 (\\forall x \\in A, x \\in B),(\\forall y \\in B, y \\in A) 这种写法，上述证明过程仍然成立，因此，该证明过程使用到的只有集合相等定义和并集公理。\n类似地，如果 B' 是与 B 相等的集合，那么 A \\cup B 等于 A \\cup B' 。因此，求并运算遵守替换公理，从而该运算在集合上是定义明确的。\n现在我们给出并集的一些基本性质。\n引理 3.1.13 如果 a 和 b 都是对象，那么 \\{a, b\\} = \\{a\\} \\cup \\{b\\} 。如果 A 、 B 和 C 都是集合，那么求并运算是可交换的（即 A \\cup B = B \\cup A ），而且也是可结合的（即 (A \\cup B) \\cup C = A \\cup (B \\cup C) ）。另外，我们有 A \\cup A = A \\cup \\emptyset = \\emptyset \\cup A = A 。\n证明： 首先证明 结合律 (A \\cup B) \\cup C = A \\cup (B \\cup C) 。\n根据定义 3.1.4 （集合的相等）可知，我们需要证明 (A \\cup B) \\cup C 中的任意一个元素 x 都是集合 A \\cup (B \\cup C) 中的元素，反之亦然。\n于是，首先假设 x 是 (A \\cup B) \\cup C 中的一个元素，那么根据公理 3.4 （两集合并集）可知，这意味着 x \\in A \\cup B 和 x \\in C 中至少有一个为真。现在我们分两种情况来讨论。\n如果 x \\in C ，则根据公理 3.4 可知 x \\in B \\cup C ，进而再次利用公理 3.4 可得， x \\in A \\cup (B \\cup C) 。\n现在假设 x \\in A \\cup B ，那么由公理 3.4 可知 x \\in A 或 x \\in B 。一方面，如果 x \\in A ，从公理 3.4 中可得 x \\in A \\cup (B \\cup C) ；另一方面，如果 x \\in B ，通过连续应用公理 3.4 可得 x \\in B \\cup C ，进而有 x \\in A \\cup (B \\cup C) 。\n因此我们得到，在所有可能的情况中， (A \\cup B) \\cup C 中的每一个元素均包含在 A \\cup (B \\cup C) 中。同理可以推出 A \\cup (B \\cup C) 中的每一个元素也都包含在 (A \\cup B) \\cup C 中，于是我们证明了 (A \\cup B) \\cup C = A \\cup (B \\cup C) 。□\n第二，对于求并运算的可交换性， A \\cup B=B \\cup A .\n证明 A \\cup B \\subseteq B \\cup A : 假设 x \\in A \\cup B 。根据并集的定义，此时存在两种可能：\nx \\in A x \\in B 无论是上述哪种情况，都意味着 x \\in B \\cup A （因为 B \\cup A 定义与 A \\cup B 相同，只是 A 和 B 的位置对调，不影响“或”的逻辑关系）。\n因此，当 x \\in A \\cup B 时，必有 x \\in B \\cup A 。由此得到 A \\cup B \\subseteq B \\cup A 。\n证明 B \\cup A \\subseteq A \\cup B : 该部分的证明与上面完全对称。\n假设 x \\in B \\cup A 。根据并集的定义，这意味着：\nx \\in B 或者 x \\in A 无论是哪种情况，都必然有 x \\in A \\cup B 。\n因此，当 x \\in B \\cup A 时，必有 x \\in A \\cup B 。由此得到 B \\cup A \\subseteq A \\cup B 。\n合并结果： 综合上述两个包含关系，我们有：\nA \\cup B \\subseteq B \\cup A \\quad \\text{且} \\quad B \\cup A \\subseteq A \\cup B 根据集合相等的判定标准（互相包含），得到：\nA \\cup B = B \\cup A 第三，对于 A \\cup A = A \\cup \\emptyset = \\emptyset \\cup A = A. ，使用与上两式同样的证明思路易得。\n因为有了上面这个引理，我们就不需要利用括号来表示多个并集运算了。例如，我们可以用 A \\cup B \\cup C 来代替 (A \\cup B) \\cup C 和 A \\cup (B \\cup C) 。类似地，对于四个集合求并，我们可以写成 A \\cup B \\cup C \\cup D ，等等。\n这个公理使得我们可以定义三元素集、四元素集，以此类推。如果 a, b, c 是三个对象，那么定义 \\{a, b, c\\} := \\{a\\} \\cup \\{b\\} \\cup \\{c\\} ；如果 a, b, c, d 是四个对象，那么定义 \\{a, b, c, d\\} := \\{a\\} \\cup \\{b\\} \\cup \\{c\\} \\cup \\{d\\} ，以此类推。另外，对任意给定的自然数 n ，我们目前尚无法定义由 n 个对象构成的集合；这需要把上述结构迭代 “ n 次”，然而 n 次迭代的概念还没有被严格定义。基于类似的原因，我们还无法定义由无穷多个对象所构成的集合概念，因为这需要对两集合并集公理迭代无穷多次，而且目前能否确保整个过程的严谨性尚不清楚。后面我们会介绍集合论的一些其他公理，这些公理将使我们能够构造出任意大甚至是无穷大的集合。\n显然，某些集合看起来比其他集合要大。正式建立这种概念的一种方法是引入子集的概念。\n定义 3.1.15（子集） 设 A 和 B 都是集合，我们称 A 是 B 的子集，并记作 A \\subseteq B ，当且仅当 A 的每一个元素都是 B 中的元素，即\n\\text{对任意的对象} x，x \\in A \\implies x \\in B 如果 A \\subseteq B 并且 A \\neq B ，那么我们称 A 是 B 的真子集，记作 A \\subsetneq B 。\n注 3.1.16 因为上面的定义中只包含了相等的概念以及“是……的元素”的关系，而这两者都遵守替换公理，所以子集的概念也自动地遵守替换公理。于是，譬如若 A \\subseteq B 并且 A = A' ，那么 A' \\subseteq B 。\n例 3.1.17 我们有 \\{1, 2, 4\\} \\subseteq \\{1, 2, 3, 4, 5\\} ，这是因为 \\{1, 2, 4\\} 中的每一个元素都是 \\{1, 2, 3, 4, 5\\} 中的元素。事实上，我们也可以得到 \\{1, 2, 4\\} \\subsetneq \\{1, 2, 3, 4, 5\\} ，因为集合 \\{1, 2, 4\\} 与 \\{1, 2, 3, 4, 5\\} 不相等。给定任意一个集合 A ，我们总有 A \\subseteq A 和 \\varnothing \\subseteq A 。\n正如下面这个命题所描述的那样，集合论中的子集概念类似于数系中“小于或等于”的概念（更精确的表述参见定义 8.5.1）。\n命题 3.1.18（集合的包含关系使集合是偏序的） 设 A 、 B 、 C 是集合。如果 A \\subseteq B 并且 B \\subseteq C ，那么 A \\subseteq C 。如果 A \\subseteq B 并且 B \\subseteq A ，那么 A = B 。最后，如果 A \\subsetneq B 并且 B \\subsetneq C ，那么 A \\subsetneq C 。\n证明：\n第一个结论。假设 A \\subseteq B 并且 B \\subseteq C 。为了证明 A \\subseteq C ，我们必须证明 A 中的每一个元素都是 C 中的元素。那么取 A 中任意一个元素 x ，因为 A \\subseteq B ，所以 x 一定是 B 中的元素。又因为 B \\subseteq C ，所以 x 是 C 中的元素。因此 A 中的每一个元素实际上都是 C 中的元素，结论得证。\n第二结论 证明显然。\n第三结论 其证明过程和第一结论的证明是完全相同的。\n习题： 设 A , B , C 都是集合，\n证明 A \\cap B \\subseteq A 和 A \\cap B \\subseteq B 。 更进一步地，证明 C \\subseteq A 且 C \\subseteq B ，当且仅当 C \\subseteq A \\cap B 。 类似地，证明 A \\subseteq A \\cup B 和 B \\subseteq A \\cup B ， 且进一步证明 A \\subseteq C 且 B \\subseteq C ，当且仅当 A \\cup B \\subseteq C 。 证明：\n证明 A \\cap B \\subseteq A 和 A \\cap B \\subseteq B (1) A \\cap B \\subseteq A 证明：设任意 x \\in A \\cap B 。则根据交集的定义， x \\in A 且 x \\in B 。由此可见， x \\in A ，故 A \\cap B \\subseteq A 。\n(2) A \\cap B \\subseteq B 证明与上面类似：设 x \\in A \\cap B ，则 x \\in A 且 x \\in B ，因此 x \\in B ，故 A \\cap B \\subseteq B 。\n当且仅当条件： C \\subseteq A \\cap B \\iff C \\subseteq A \\text{ 且 } C \\subseteq B (1) 若 C \\subseteq A \\cap B ，则对任意 x \\in C ，有 x \\in A \\cap B 。由交集定义， x \\in A 且 x \\in B 。由于 x 是 C 的任意元素，这意味着 C \\subseteq A 且 C \\subseteq B 。\n(2) 反之，若 C \\subseteq A 且 C \\subseteq B ，则对于任意 x \\in C ，有 x \\in A 且 x \\in B 。由此可得 x \\in A \\cap B 。因为 x 是 C 的任意元素，所以 C \\subseteq A \\cap B 。\n结合(1)和(2)，可得\nC \\subseteq A \\cap B \\iff C \\subseteq A \\text{ 且 } C \\subseteq B .\n证明 A \\subseteq A \\cup B 和 B \\subseteq A \\cup B (1) A \\subseteq A \\cup B 证明：若任意 x \\in A ，则根据并集定义 x \\in A \\cup B （因为 x \\in A 即满足“或”条件）。由此 A \\subseteq A \\cup B 。\n(2) B \\subseteq A \\cup B 证明与上类似：若 x \\in B ，则 x \\in A \\cup B ，故 B \\subseteq A \\cup B 。\n当且仅当条件： A \\cup B \\subseteq C \\iff A \\subseteq C \\text{ 且 } B \\subseteq C (1) 若 A \\cup B \\subseteq C ，则对任意 x \\in A ，因为 A \\subseteq A \\cup B ，所以 x \\in A \\cup B \\subseteq C ，故 A \\subseteq C 。同理，对任意 x \\in B ，有 x \\in A \\cup B \\subseteq C ，故 B \\subseteq C 。综合得到 A \\subseteq C \\text{ 且 } B \\subseteq C 。\n(2) 反之，若 A \\subseteq C \\text{ 且 } B \\subseteq C ，则对任意 x \\in A \\cup B ，必然 x \\in A \\text{ 或 } x \\in B ，进而 x \\in C ，因此 A \\cup B \\subseteq C 。\n综上，\nA \\cup B \\subseteq C \\iff A \\subseteq C \\text{ 且 } B \\subseteq C .\n注 3.1.20 子集关系 \\subsetneq 和小于关系 \u003c 之间存在一个重要的区别。给定任意两个不同的自然数 n 和 m ，我们知道其中一个会比另外一个小（命题2.2.13 自然数的序的三歧性）；但是给定两个不同的集合，说其中一个是另外一个集合的子集这种命题通常不为真。例如，令 A := \\{2n : n \\in \\mathbb{N}\\} 是由所有偶自然数构成的集合，令 B := \\{2n + 1 : n \\in \\mathbb{N}\\} 是由所有奇自然数构成的集合，那么 A 和 B 彼此互不为对方的子集。这就是我们为什么说集合仅仅是 偏序 的，而自然数却是 全序 的（参见定义8.5.1和定义8.5.3）。\n注 3.1.21 我们也应该注意到子集关系 \\subseteq 与元素的属于关系 \\in 是不一样的。数字 2 是集合 \\{1, 2, 3\\} 中的一个元素，而不是它的一个子集，因此 2 \\in \\{1, 2, 3\\} ，但是 2 \\nsubseteq \\{1, 2, 3\\} 。事实上， 2 本身就不是一个集合。反过来， \\{2\\} 是集合 \\{1, 2, 3\\} 的一个子集，而不是元素，所以 \\{2\\} \\subseteq \\{1, 2, 3\\} ，但是 \\{2\\} \\notin \\{1, 2, 3\\} 。这里的关键在于数字 2 和集合 \\{2\\} 是不同的对象。\n把集合与集合中的元素区分开来非常重要，因为 集合和元素具有不同的性质。譬如，能够找到一个含有无穷多个元素的集合，其中每一个元素都是有穷数字（自然数集 \\mathbb{N} 就是这样的例子），也能够找到这样一个集合，它的元素个数是有限的，但是每个元素都是由无穷多个元素构成的集合（例如，考虑集合 \\{\\mathbb{N}, \\mathbb{Z}, \\mathbb{Q}, \\mathbb{R}\\} ，该集合共有四个元素且每一个元素都是由无穷多个元素构成的集合）。\n现在我们给出一个公理，它能够让我们轻松地构造出一个较大集合的子集。\n公理 3.5（分类公理） 设 A 是一个集合，对任意的 x \\in A ，令 P(x) 表示关于 x 的一个性质（即 P(x) 要么是真命题，要么是假命题）。那么存在一个集合，记作 \\{x \\in A : P(x) \\text{ 为真}\\} （或者简记为 \\{x \\in A : P(x)\\} ），该集合恰好是由 A 中那些使得 P(x) 为真的元素 x 构成的。换言之，对任意的对象 y ，\ny \\in \\{x \\in A : P(x) \\text{ 为真}\\} \\iff (y \\in A \\text{ 并且 } P(y) \\text{ 为真}) 这个公理也被称为 分离公理。注意， \\{x \\in A : P(x) \\text{ 为真}\\} 一定是集合 A 的一个子集，尽管它可能与 A 一样大，也可能与空集一样小。我们能够证明替换公理适用于分类，所以如果 A = A' ，则有 \\{x \\in A : P(x)\\} = \\{x \\in A' : P(x)\\} 。（因为，替换公理保证若 A = A' ，则我们可以在任意公式中将 A 替换为 A' 而不改变命题的真值，因此分离公理满足替换公理）\n另外，我们在此处所述的替换公理，实际上是一阶逻辑中的替换性。\n逻辑中的替换原则（等式替代性）：\n在一阶逻辑中，如果我们知道 x = y ，那么无论在什么性质 P(x) 或函数 f(x) 中，都可以把 x 换成 y 而不会改变陈述的真值或函数的值。这是逻辑本身的一个基本定律，也常被翻译为“替换规则”或“替代律”。有时，有些教材或笔记中也会将其称为“替换公理”或“替换规律”，这是在逻辑层面上的用法。这种替换不涉及集合的构造，只是逻辑上允许你将相等的对象互相替代。\n而在 ZF1 公理系统中也存在一个替换公理，其表述为\n替换公理模式（Replacement Schema） 是 ZF 集合论的一组 公理模式，用以保证由函数式定义的类从集合中“替换”元素形成的新类依然是集合。其一般形式如下：\n给定一个公式 \\phi(x, y, \\vec{p}) ，其中 \\vec{p} 是若干参数， \\phi 在集合论语言中构成一个谓词。如果满足下列条件：\n对任意集合 x 和 x' ，如果对某个 \\vec{p} 有 \\phi(x, y, \\vec{p}) 且 \\phi(x', y', \\vec{p}) 成立，那么若 x = x' 则必定 y = y' 。也就是说，对于固定的参数 \\vec{p} 和每个集合 x ， \\phi 充当一个定义良好的“类函数”——从 x 唯一确定一个 y 。\n对任意集合 A ，定义 B = \\{y : \\exists x \\in A, \\phi(x, y, \\vec{p})\\} 。那么替换公理断言： B 也是一个集合。\n简而言之，替换公理模式可以表述为：\n如果 \\phi 定义了从任意集合 A 到集合的一个类函数（即对 A 中每个元素 x 唯一定义一个 y 使 \\phi(x, y) 成立），那么 \\{y : \\exists x \\in A, \\phi(x, y)\\} 也是一个集合。\n两者的根本区别在于：替换性保证在逻辑推理中，可自由地在公式中用相等的对象互代，以维持公式的真值不变。这是一种语义上的逻辑规则，用来 确保逻辑推理的正确性和一致性。替换公理保证给定某种定义良好的类函数，可以“替换”集合中的每个元素为其对应像值，从而产生新集合的存在性。这是关于 从集合理论中已有的集合构造出新集合的存在性命题。因此，在平常的使用中，我们必须区别两者。\n有时我们用 \\{x \\in A | P(x)\\} 来代替 \\{x \\in A : P(x)\\} ，当用冒号 “:” 表示其他含义时，这种新写法就有用了。例如，用冒号来表示一个函数 f : X \\to Y 的值域和定义域。\n我们可以利用分类公理去进一步定义集合上的一些运算，即求交集和差集。\n定义 3.1.23（交集） 两个集合的交集 S_1 \\cap S_2 被定义为下面这样一个集合：\nS_1 \\cap S_2 := \\{x \\in S_1 : x \\in S_2\\} 即 S_1 \\cap S_2 是由所有同时属于 S_1 和 S_2 的元素构成的。于是对任意的对象 x ，\nx \\in S_1 \\cap S_2 \\iff x \\in S_1 \\text{ 且 } x \\in S_2 注 3.1.24 注意，这个定义是明确的（也就是说，该定义遵守替换公理）因为定义中仅仅使用到了属于关系以及更为原始的“满足..的性质”这一概念，因此它是遵循替换公理（替换性）的。\n注 3.1.26 顺便提一下，对于词语中的“和”我们要小心使用。根据上下文，它有时候表示并集，而有时候表示交集，非常容易混淆。例如，如果有人谈到“男孩和女孩”的集合，那么他的意思是男孩组成的集合与女孩组成的集合的并集，但是如果有人提到同时满足单身和男性这两个条件的人组成的集合，那么他的意思就是单身人士组成的集合与男性组成的集合的交集。另一个问题是“和”也表示相加，例如，我们可以说“2 与 3 的和是 5”，也可以说“集合 {2} 的元素和集合 {3} 的元素构成了集合 {2, 3}”，还有“在 {2} 和 {3} 中的元素构成了集合 ∅”。这确实容易混淆！原因之一在于我们用数学符号来代替像“和”这样的词语。数学符号总是能够准确清晰地表述意思，而想要真正了解某个词语所表达的涵义，我们必须非常仔细地阅读上下文才行。\n定义 3.1.27（差集） 给定两个集合 A 和 B ，我们定义集合 A - B 或 A \\setminus B 是由 A 中所有不属于 B 的元素组成的集合。\nA \\setminus B := \\{ x \\in A : x \\notin B \\} 例如， \\{1, 2, 3, 4\\} \\setminus \\{2, 4, 6\\} = \\{1, 3\\} 。在很多情况下， B 是 A 的一个子集，但并非必须如此。\n现在我们给出并集、交集和差集的一些基本性质。\n命题 3.1.28（集合构成布尔代数） 设 A 、 B 、 C 都是集合，令 X 表示包含 A 、 B 、 C 作为其子集的集合。\n(a)（最小元）我们有 A \\cup \\emptyset = A 和 A \\cap \\emptyset = \\emptyset 。\n(b)（最大元）我们有 A \\cup X = X 和 A \\cap X = A 。\n(c)（恒等式）我们有 A \\cap A = A 和 A \\cup A = A 。\n(d)（交换律）我们有 A \\cup B = B \\cup A 和 A \\cap B = B \\cap A 。\n(e)（结合律）我们有 (A \\cup B) \\cup C = A \\cup (B \\cup C) 和 (A \\cap B) \\cap C = A \\cap (B \\cap C) 。\n(f)（分配律）我们有 A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C) 和 A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C) 。\n(g)（分拆法）我们有 A \\cup (X \\setminus A) = X 和 A \\cap (X \\setminus A) = \\emptyset 。\n(h)（德摩根定律）我们有 X \\setminus (A \\cup B) = (X \\setminus A) \\cap (X \\setminus B) 和 X \\setminus (A \\cap B) = (X \\setminus A) \\cup (X \\setminus B) 。\n注 3.1.29 德摩根定律是以逻辑学家奥古斯塔斯·德摩根（1806—1871）的名字来命名的，他把这些定律确定为集合论的基本定律之一。\n什么是布尔代数 (Boolean Algebra)? 布尔代数是一种抽象代数结构，用来刻画经典逻辑以及集合运算的代数性质。它由一个带有两个二元运算（通常记为 \\land 和 \\lor 或者 \\cap 和 \\cup ）、一个一元运算（补操作），以及特定恒等元所组成的代数系统。满足布尔代数的结构必须符合以下公理特性：\n交换律 (Commutativity)：\na \\land b = b \\land a a \\lor b = b \\lor a 结合律 (Associativity)：\n(a \\land b) \\land c = a \\land (b \\land c) (a \\lor b) \\lor c = a \\lor (b \\lor c) 分配律 (Distributivity)：\na \\land (b \\lor c) = (a \\land b) \\lor (a \\land c) a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c) 恒等元存在 (Identity Elements)： 存在两个特殊元素：\n单位元 1 以及零元 0，满足： a \\land 1 = a a \\lor 0 = a 补元存在 (Complements)： 对每个 a 存在补元 a\u0026rsquo; 使：\na \\land a' = 0 a \\lor a' = 1 典型的布尔代数例子包括：\n真值代数：{true, false} 构成的代数结构 任一集合的幂集（其子集组成的集合），在并集、交集和补集下形成的结构 为什么“集合构成布尔代数”这个命题重要到成为集合论的基本定律？ 集合论在很大程度上被视为现代数学的基础框架。当我们发现任意集合的幂集在并、交和补这三种操作下构成了一个布尔代数时，这意味着经典命题逻辑的代数结构（逻辑运算：与、或、非）有了一个精确而自然的集合论刻画。换言之，逻辑命题间的真值结构与集合之间的包含关系及运算结构完全同构。这种对应为数学基础的统一提供了坚实的理论支撑，让我们能够在集合论基础上讨论逻辑系统的性质，从而使得集合论不仅仅是“描述数学对象的语言”，还是“描述逻辑结构和推理过程的语言”。\n虽然现在我们已经积累了有关集合的大量公理和结果，但是还有许多事情没办法做到。关于集合，我们想要做的一件最基本的事就是取出集合中的每一个元素，并按照某种方式把每一个元素都转换成另外的新对象。例如，我们希望从一个数集 \\{3, 5, 9\\} 开始，把该集合中的每个元素进行增长，从而构造出一个新集合 \\{4, 6, 10\\} 。直接利用之前学过的公理是无法做到这件事的，因此我们需要一个新公理。\n公理 3.6 (替代) 设 A 是一个集合，对任意的 x\\in A 和任意的一个对象 y ，假设存在一个关于 x 和 y 的命题 P(x,y) 使得对任意的 x\\in A ，最多能够找到一个 y 使得 P(x,y) 为真。那么存在一个集合 \\{y:P(x,y)对某x\\in A为真\\} 使得对任意的对象 z ，\nz\\in\\{y:P(x,y)对某x\\in A为真\\}\\iff 对某x\\in A,P(x,z)为真 例 3.1.31 令 A:=\\{3,5,9\\} ，并且设 P(x,y) 表示命题 y=x++ ，即 y 是紧跟在 x 之后的那个数。观察可知，对任意一个 x\\in A ，只有一个 y 使得 P(x,y) 为真。具体地，就是紧跟在 x 之后的那个数。于是，上面的公理断定集合 \\{y:y=x++对某x\\in\\{3,5,9\\}为真\\} 是存在的。此时，上述集合显然就是 \\{4,6,10\\} 。\n例 3.1.32 令 A:=\\{3,5,9\\} ，设 P(x,y) 表示命题 y=1 。那么同样，对任意的 x\\in A ，只有一个 y 使得 P(x,y) 为真。具体地，就是数字1。此时， \\{y:y=1对某x\\in\\{3,5,9\\}为真\\} 就是单元素集 \\{1\\} ，我们已经把原始集合 A 中的每一个元素3、5、9都用同一个元素1来代替。因此，这个相当无聊的例子告诉我们，通过上述公理得到的集合可以比原始集合更\u0026quot;小\u0026quot;。\n我们经常把形式如\n\\{ y : \\text{ 对某些 } x \\in A \\text{ 有 } y = f(x) \\} 的集合简写为 \\{ f(x) : x \\in A \\} 或者 \\{ f(x) | x \\in A \\} 。例如，若 A = \\{3, 5, 9\\} ，那么\n\\{ x++ : x \\in A \\} 就是集合 \\{4, 6, 10\\} 。我们当然可以把代数和分类公理合并在一起使用。例如，按照下面的过程构造类似\n\\{ f(x) : x \\in A \\text{ 且 } P(x) \\text{ 为真} \\} 的集合。\n从集合 A 开始，利用分类公理构造集合 \\{ x \\in A : P(x) \\text{ 为真} \\} ，然后使用替代公理构造集合\n\\{ f(x) : x \\in A \\text{ 且 } P(x) \\text{ 为真} \\} 。于是可以有\n\\{ n++ : n \\in \\{3, 5, 9\\} \\text{ 且 } n \u003c 6\\}=\\{4,6\\} 。\n在我们的许多例子中，都隐含地假设了自然数实际上就是对象。对此我们给出下面的正式叙述。\n公理 3.7 (无穷大) 存在一个集合 \\mathbb{N} ，它的元素被称为自然数。对象 0 在 \\mathbb{N} 中，且每一个自然数 n \\in \\mathbb{N} 所指定的满足皮亚诺公理（公理 2.1～2.5）的对象 n++ 也在 \\mathbb{N} 中。\n这是假设 2.6 更加正式的表达。它被称为无穷大公理，因为它引入了无穷大集合一个最基本的例子，也就是自然数集 \\mathbb{N} （我们将在 3.6 节正式阐述有穷大和无穷大的意思）。我们从无穷大公理中能够看到，像 3, 5, 7 等这样的数确实是集合论中的对象，从而（根据双元素集合公理和两集合并集公理）我们的确可以合法构造如 \\{ 3, 5, 9 \\} 这样的集合，就像在之前的例子中我们做过的那样。\n我们必须区分清楚“集合”的概念以及“集合中元素”的概念。例如，集合 \\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} 与表达式或函数 n + 3 并不相同。我们通过下面的例子来强调这一点。\n例 3.1.33 （非正式的）这个例子需要用到减法的概念，但是目前我们还没有正式介绍减法。下面两个命题\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} \\tag{3.1} 成立（见下文），尽管对任意的自然数 n ，表达式 n + 3 和 8 - n 都绝对不可能相等。\n所以当你谈论集合时，记得要使用大括号 \\{ \\} ，这样可以避免你偶然地把集合与其元素混淆。\n这种看似简单的原因之一是字符 n 在式 (3.1) 的两端是以两种不同的方式使用的。为了阐明这种情况，我们把字符 n 替换成字母 m 来重新书写集合\n\\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} ，于是我们得到\n\\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\} 。它与之前的集合完全相等。因此我们能够把式 (3.1) 重新写成：\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\} 现在很容易看出（利用定义 3.1.4）为什么该等式为真：每一个形式如 n + 3 的数（其中 n 表示 0 与 5 之间的自然数）也可以写成 8 - m 的形式，其中 m := 5 - n （注意 m 也是 0 到 5 之间的自然数）。反过来，每一个形式 8 - m 的数（其中 m 表示 0 到 5 之间的自然数）也可以写成 n + 3 的形式，其中 n := 5 - m （注意 n 也是 0 到 5 之间的自然数）。观察一下，如果我们没有事先把 n 替换成 m ，那么上面对式 (3.1) 的解释将会让人困惑！\n原因与分析：\n在最初的写法中，集合通通过类似的表达式构造，例如\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} 。\n这里两边都使用了相同的记号 n ，但在左侧和右侧实际上是两次独立引入的【哑变量】（dummy variable）。从逻辑上讲，这些变量在各自的集合构造中是局部的，不应该相互混淆。然而，当两侧同时使用同一个字母 n 时，该符号可能会被误认为是一个全局的变量，从而产生误解，以为这两个定义式右边一层正用同一个值描述元素。因此会让人困惑：为什么 n+3 的元素集会等于 8-n 的元素集，难道左边两个表达式中 n 是同一回事吗？\n如何解决混淆：\n通过将右侧的 n 改成 m ，得到\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\} 。\n现在，这看一眼就能看出：左边用 n 来构造集合，右边用 m 来构造集合，它们是两个独立的参数，各自有独立定义的集合。这样就可以清晰地观察到，左边集合里的每个元素都能通过一个适当的 m （或在集合里的元素都能通过一个合适的 n ）来匹配上。换句话说，改变了字母作为变量之后，变量不会误地将两侧的集合混为一谈，而能顺利理解两个集合事实上是不同的参数化得到的元集合。\n3.习题 设 A 和 B 是集合，证明 吸收率 A \\cap (A \\cup B) = A \\quad \\text{和} \\quad A \\cup (A \\cap B) = A. 证明 A \\cap (A \\cup B) = A 证明 A \\cap (A \\cup B) \\subseteq A : 设 x \\in A \\cap (A \\cup B) 。\n根据集合定义： x \\in A 且 x \\in A \\cup B 。\n由于 x \\in A ，故有 x \\in A \\cap (A \\cup B) \\subseteq A 。\n证明 A \\subseteq (A \\cap (A \\cup B)) : 设 x \\in A 。\n因为 x \\in A 所以显然 x \\in A \\cup B （因为 x \\in A 即满足“或”条件）。\n因此 x \\in A \\cap (A \\cup B) 。\n综上，两方面的包涵都得证，故有 A \\cap (A \\cup B) = A 。\n证明 A \\cup (A \\cap B) = A 证明 A \\cup (A \\cap B) \\subseteq A :\n设 x \\in A \\cup (A \\cap B) 。\n根据并集定义， x \\in A 或 x \\in A \\cap B 。\n若 x \\in A ，则显然 x \\in A 成立。\n若 x \\in A \\cap B ，根据交集定义， x \\in A 且 x \\in B 。此时依然有 x \\in A 。\n故 A \\cup (A \\cap B) \\subseteq A 。\n证明 A \\subseteq (A \\cup (A \\cap B)) :\n设 x \\in A 。\n由于 x \\in A ，显然有 x \\in A \\cup (A \\cap B) 。\n故 A \\subseteq (A \\cup (A \\cap B)) 。\n综上，两方面的包涵都得证，故有 A \\cup (A \\cap B) = A 。\n令 A, B, X 表示集合，并且它们满足 A \\cup B = X 和 A \\cap B = \\emptyset 。证明 A = X \\setminus B 和 B = X \\setminus A 证明 A = X \\setminus B 证明 A \\subseteq X \\setminus B : 任取 x \\in A ，因为 A \\subseteq A \\cup B = X ，可知 x \\in X 。\n又因为 A \\cap B = \\emptyset ，所以 x \\notin B 。\n因此 x \\in X \\setminus B ，故 A \\subseteq X \\setminus B 。\n证明 X \\setminus B \\subseteq A : 任取 x \\in X \\setminus B ，则 x \\in X 且 x \\notin B 。\n已知 X = A \\cup B ，且 x \\in A \\cup B ，则 x \\in A 或 x \\in B 。\n由于 x \\notin B ，则只能有 x \\in A ，故 X \\setminus B \\subseteq A 。\n综上，两方面的包涵都得证，故有 A = X \\setminus B 。\n证明 B = X \\setminus A 的过程与上完全相同，只需将 A 和 B 的角色对调：\nx \\in B \\Rightarrow x \\in X \\text{ 且 } x \\notin A, \\text{ 故 } B \\subseteq X \\setminus A. x \\in X \\setminus A \\Rightarrow x \\in X \\text{ 且 } x \\notin A, \\text{ 由 } X = A \\cup B \\text{ 且 } x \\notin A, \\text{ 得 } x \\in B, \\text{ 故 } X \\setminus A \\subseteq B. 综上可得 B = X \\setminus A 。\n其余习题已于正文中给出。\n策梅洛-弗兰克尔集合论（英语：Zermelo-Fraenkel Set Theory），是数学基础中最常用的一阶公理化集合论。含选择公理时常简写为ZFC，不含选择公理的则简写为ZF。它是二十世纪早期为了建构一个不会导致类似罗素悖论的矛盾的集合理论所提出的一个公理系统。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":["数学分析"],"title":"3.1  基础知识","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/"},{"content":"1.3.1 泛函导数的概念 对于普通函数的导数，函数的微分是由自变量的微分引起的：\n\\begin{align} f(t) \\xrightarrow{t \\to t+\\epsilon} f(\\tilde{t}) \u0026= f(t+ \\epsilon) \\\\ \u0026= f(t) + \\epsilon df(t) + \\frac{\\epsilon^2}{2!} d^2 f(t) + \\frac{\\epsilon^3}{3!} d^3 f(t) + \\cdots \\end{align} 其中 \\epsilon 是无穷小参数， \\epsilon^n 项即为函数的 n 阶微分，函数的 n 阶导数则由函数的 n 阶微分与 dt 的关系给出。对于一阶导数：\ndf(t) = \\frac{df(t)}{dt} dt 高阶导数则为：\nd^{(n)} f(t) = \\frac{d^{(n)}f(t)}{dt^n} dt 只要计算出函数的各阶微分，就可以给出相应的各阶导数。\n泛函导数从形式上完全是对普通函数导数的类比。对于泛函 S[f] ，其变分是由函数的变分引起的：\n\\begin{align} S[f] \\xrightarrow{f \\to \\tilde{f}} S[\\tilde{f}] \u0026= S[f + \\epsilon f] \\\\ \u0026= S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots \\end{align} 这里 \\epsilon^n 项即被称为是泛函的 n 阶变分 \\delta^n S[f] 。仿照函数的 n 阶导数即可定义 n 阶泛函导数。\n定义 1 阶泛函导数\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 其中：\n\\delta f(t) = \\tilde{f}(t) - f(t) 这里 \\delta S 是泛函的一阶变分， \\frac{\\delta S}{\\delta f(t)} 即为一阶泛函导数（the first order functional derivative）。可以看出，一阶泛函导数的作用，是将函数的变分 \\delta f(t) （无穷小函数）映射到泛函的一阶变分 \\delta S （无穷小的数）。这也解释了为什么定义式中出了 dt 的积分。\n为了更好的理解泛函导数，可以将泛函与多元函数进行类比，例如：\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 可以和多元函数 F = F(x_1, x_2, \\cdots, x_n) 的一阶微分\ndF = \\sum_n \\frac{\\partial F}{\\partial x_n} dx_n 相类比。\n类比函数的高阶导数，高阶泛函导数定义为：\n\\delta^2 S[f] := \\int dt_1 \\int dt_2 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} \\delta f(t_1) \\delta f(t_2) \\delta^3 S[f] := \\int dt_1 \\int dt_2 \\int dt_3 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} \\delta f(t_1) \\delta f(t_2) \\delta f(t_3) 这里的 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} 和 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} 即分别代表 S[f] 对 f 的二阶泛函导数和三阶泛函导数。\n例如，二阶泛函导数的作用，是将函数的变分 \\delta f(t) 映射为泛函的二阶变分 \\delta^2 S （二阶无穷小数）。在经典力学中，我们大多只关注一阶泛函导数。\n","cover":null,"tags":["经典力学"],"title":"1.3 泛函导数","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3/"},{"content":"1.3.2 泛函导数的操作定义 根据上面的讨论，泛函导数归结于计算泛函 S[f] 的变分。\n换个角度，在泛函 S[f + \\epsilon \\delta f] 中， \\epsilon 是一个参数，而泛函 S 是一个数，其值依赖于 \\epsilon 。所以，泛函 S[f + \\epsilon \\delta f] 可以被看作是 \\epsilon 的普通函数，于是公式：\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots 可以视为 S[f + \\epsilon \\delta f] 相对于 \\epsilon 的普通泰勒展开。\n一般函数在 x_0 处以及 x_0 = 0 的泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^2 + R_n R_n=o[(x-x_0)^n] f(x) = f(0) + \\frac{f'(0)}{1!}(x) + \\frac{f''(0)}{2!}(x)^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}(x)^2 + R_n R_n=o[(x)^n] 通过比较\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots S[f + \\epsilon \\delta f] = S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots 即可得到一阶泛函导数的形式：\n\\delta S=\\left.\\frac{d}{d\\epsilon}S[f+\\epsilon \\delta f]\\right|_{\\epsilon=0}=\\int\\limits dt\\frac{\\delta S}{\\delta f(t)}\\delta f(t) \\delta S^2=\\left.\\frac{d^2}{d\\epsilon^2}S[f+\\epsilon\\delta f]\\right|_{\\epsilon=0}=\\int dt_1\\int dt_2\\frac{\\delta ^2S}{\\delta f(t_1)\\delta f(t_2)}\\delta f(t_1)\\delta f(t_2) 高阶泛函导数的形式可以类似的写出。\n对于下述形式的泛函\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots) 可以联系一阶泛函导数的形式可以得到\n\\begin{align} \\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026\\text{其中} f+\\epsilon\\delta f \\text{是关于} \\epsilon \\text{的函数} f(\\epsilon)，f' \\text{同理}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align} 上式的被积函数就是 L 的一阶变分 \\delta L ，与其微分形式 dL 全同。只是微分换成了变分。\n这意味着\n\\delta S\\equiv\\delta(\\int\\limits_{t_1}^{t_2}dtL)=\\int\\limits_{t_1}^{t_2}dt\\delta L 即是说，变分符号可以移到积分内。\n观察一阶泛函导数的形式\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f 右边只出现了函数的变分 \\delta f 。但是在\n\\begin{align} \\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align}\\\\ 中却出现了函数的导数的变分 \\delta f',\\delta f'',\\cdots ，在处理这个情况时，我们就需要使用变分法中非常重要的技巧——分部积分（integration by parts）。\n分部积分的基本思路是：利用变分和求导可以交换顺序的性质，将作用于 \\delta f 的导数移除，代价是产生额外的“全导数”项，然后设定全导数为边界项，并且忽略边界项，使得泛函的变分式中各项的共有项为 \\delta f ，提出 \\delta f 后即得一阶泛函导数。\n例如，对于正比于 \\delta f' 的项。\n\\frac{\\partial L}{\\partial f'}\\delta f'\\xlongequal{\\text{变分与求导交换顺序}}\\frac{\\partial L}{\\partial f'}\\frac{d}{dt}\\delta f=\\underbrace{\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'}\\delta f)}_{\\text{全导数}}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f 第二个等号是因为\n\\begin{align} \u0026(uv)'=u'v+uv'\\\\ \u0026uv'=(uv)'-u'v \\end{align} 类似的，\n\\begin{align} \\frac{\\partial L}{\\partial f''}\\delta f''\u0026=\\frac{\\partial L}{\\partial f''}\\frac{d^2}{dt^2}\\delta f={\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''}\\frac{d}{dt}\\delta f)}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\frac{d}{dt}\\delta f\\\\ \u0026=\\underbrace{\\frac{d}{dt}\\bigg(\\frac{\\partial L}{\\partial f''}\\delta f'-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\delta f\\bigg)}_{\\text{全导数}}+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f \\end{align} 由此类推，有\n\\begin{align} \\delta S\u0026=\\int\\limits_{t_1}^{t_2}dt\\bigg[\\frac{\\partial L}{\\partial f}\\delta f-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f+\\cdots+\\frac{d\\mathcal{B}}{dt}\\bigg]\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt[\\frac{\\partial L}{\\partial f}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})+\\cdots]\\delta f+\\left.\\mathcal{B}\\right|_{t_1}^{t_2} \\end{align} 这里 \\frac{d\\mathcal{B}}{dt} 代表全导数项。积分后得到的 \\left.\\mathcal{B}\\right|_{t_1}^{t_2} 被称为边界项（boundary term）,在积分的端点（边界）处取值。对比\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f \\delta S 在上式中的积分已经具有泛函导数的形式，主要的阻碍来自于边界项。由上面的推导可知，如果泛函的被积函数 L 包含 f(t) 的最高 n 阶导数，则边界项 \\mathcal{B} 就包含 \\delta f(t) 的最高 n-1 阶导数。\n因此，变分法的一个基本假设就是： 如果泛函的被积函数包含函数的最高 n 阶导数，那么在积分的边界处，函数及其直到 n-1 阶导数的变分为零。 即\n\\left.\\delta f\\right|_{t_1}=\\left.\\delta f\\right|_{t_2}=0 \\left.\\delta f'\\right|_{t_1}=\\left.\\delta f'\\right|_{t_2}=0 \\vdots \\left.\\delta f^{(n-1)}\\right|_{t_1}=\\left.\\delta f^{(n-1)}\\right|_{t_2}=0 在这样的假设下，边界项 \\left.\\mathcal{B}\\right|_{t_1}=\\left.\\mathcal{B}\\right|_{t_2}=0 恒为零。这也意味着，被积函数可以加上函数 f(t) 及其直到 n-1 阶导数的任意函数 F=F(t,f,f',\\cdots,f^{(n-1)}) 的全导数，而不影响泛函导数。\n两个被积函数相差全导数，或者两个积分相差边界项，这件事在变分法中非常重要。因此通常使用专门的符号\u0026quot; \\simeq \u0026quot;来表示：\nL_1\\simeq L_2\\Leftrightarrow L_1=L_2+\\frac{dF(t,f,f',\\cdots)}{dt} 之所以全导数项是 \\frac{dF(t,f,f',\\cdots)}{dt} 是因为上文中的所有函数 f(t) 都是关于 t 的函数，而所有的泛函 s[f+\\epsilon \\delta f] ，则可被视为是 \\epsilon 的函数。\n以及\nS_1\\simeq S_2\\Leftrightarrow S_1=S_2+\\left.L\\right|_{t_1}^{t_2} 基于以上假设，对于泛函导数的计算来说，边界项不重要。在实际计算中，都是直接丢掉边界项，而无需写出其具体形式的。例如\n\\frac{\\partial L}{\\partial f^{\\prime}} \\delta f^{\\prime} \\simeq-\\frac{\\mathrm{d}}{\\mathrm{d} t}\\left(\\frac{\\partial L}{\\partial f^{\\prime}}\\right) \\delta f, \\quad \\frac{\\partial L}{\\partial f^{\\prime \\prime}} \\delta f^{\\prime \\prime} \\simeq \\frac{\\mathrm{d}^{2}}{\\mathrm{d} t^{2}}\\left(\\frac{\\partial L}{\\partial f^{\\prime \\prime}}\\right) \\delta f 基于同样的理由，泛函积分的上下限也经常被省略，即\nS=\\int\\limits dtL 1.3.3 计算一阶泛函的标准手续 变分原理是整个分析力学的第一原理，而变分法的核心就是计算一阶泛函导数。\n对于\nS[f] = \\int_{t_1}^{t_2} dt L(t, f(t), f'(t), \\cdots) 这种形式的泛函，可以总结一下关于一阶泛函导数的计算手续。\n(1) 将变分符号 “ \\delta ” 移到积分号内\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\delta L(t, f(t), f'(t), \\cdots) (2) 按照类似复合函数求导的规则来计算 \\delta L \\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right) 这里变分和微分的形式全同，只是微分被换成了变分。\n(3) 做分部积分，将 \\delta f 的导数移除，这是计算一阶泛函导数的最关键的一步。 在实际操作中，只需要不断地将 \\delta f 的导数移除，并不需要关注全导数项的具体形式。\n(4) 提取 \\delta f 前的系数，即为一阶泛函导数。\n根据以上的手续，经过分部积分，式子\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right) 成为\n\\delta S \\simeq \\int_{t_1}^{t_2} dt \\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots \\right] \\delta f 从中得到一阶泛函导数\n\\boxed{\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots} 需要强调的是，虽然上式在形式上绝对正确， 但是最好不要将偏导数 \\frac{\\partial L}{\\partial f} 、 \\frac{\\partial L}{\\partial f'} 、 \\frac{\\partial L}{\\partial f''} ……先计算出来再代入式子中，而应该按照上面的“变分—分部积分”操作步骤。\n例 1.1 一阶泛函导数\n考虑泛函 S[f] = \\int dt \\left[ (f'(t))^2 - (f(t))^2 \\right] ，有\n\\begin{align} \\delta S[f] \u0026= \\int dt \\, \\delta \\left( f'^2 - f^2 \\right) \\\\ \u0026= \\int dt \\left( 2 f' \\delta f' - 2 f \\delta f \\right) \\\\ \u0026= \\int dt \\left( 2 f' \\delta f' \\right) - \\int dt \\left( 2 f \\delta f \\right) \\\\ \\int dt \\, f' \\delta f' \u0026= \\left[ f' \\delta f \\right] - \\int dt \\, f'' \\delta f \\\\ \\Rightarrow\\int dt \\, f' \\delta f' \u0026= - \\int dt \\, f'' \\delta f \\\\ \\delta S[f] \u0026= - \\int dt \\, 2 f'' \\delta f - \\int dt \\, 2 f \\delta f \\\\ \\delta S[f] \u0026\\approx \\int dt \\left( - 2 f'' - 2 f \\right) \\delta f(t) \\end{align} 因此一阶泛函导数为\n\\frac{\\delta S}{\\delta f(t)} = -2 f''(t) - 2 f(t). 例 1.2 一阶泛函导数与全导数\n考虑泛函 S[f] = \\int dt \\left[ f(t) f'(t) + f'(t) f''(t) \\right] ，有\n\\begin{align} \\delta S[f] \u0026= \\int dt \\, \\delta \\left( f f' + f' f'' \\right) \\\\ \u0026= \\int dt \\left( \\delta f f' + f \\delta f' + \\delta f' f'' + f' \\delta f'' \\right) \\\\ \u0026= \\int dt \\left( \\delta f f' \\right) + \\int dt \\left( f \\delta f' \\right) + \\int dt \\left( \\delta f' f'' \\right) + \\int dt \\left( f' \\delta f'' \\right) \\\\ \\end{align} \\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f \\int dt \\, \\delta f' f'' = \\left[ \\delta f' f' \\right] - \\int dt \\, f' \\delta f'' = - \\int dt \\, f' \\delta f'' \\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f \\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f 最终 \\begin{align} \\delta S[f] \u0026= \\int dt \\left( f' \\delta f - f' \\delta f - f''' \\delta f + f''' \\delta f \\right) \\\\ \u0026= 0 \\end{align} 其中，在此例的推导过程中，第一项\n\\int dt \\delta f f' 这一项可以选择直接处理，不需要分部积分，主要是因为 \\delta f 只是一个变分项，而 f' 是一个普通的导数函数，这里没有更高阶的导数存在，所以我们没有对其进行分部积分。\n第二项\n\\int dt f\\delta f' 这一项需要分部积分，目的是将 \\delta f' 变分项中的导数和变分分离开来，通过分部积分后得到\n\\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f 这里我们将 \\delta 和 f' 分离，避免处理变分的导数项。同时丢弃了边界项。 \\left[ f \\delta f \\right] 。\n基于同样的理由，第三项和第四项都进行了分部积分丢弃全导数项的过程。因此一阶泛函导数为零。\n在这个例子中，出现了泛函导数为零的情况。实际上，观察泛函中的被积函数， f f' + f' f'' = \\frac{d}{dt} \\left( \\frac{1}{2} f^2 + \\frac{1}{2} f'^2 \\right) \\equiv \\frac{dF}{dt} ，其自身就是个全导数。而根据上面的讨论，被积函数中的全导数可以自然舍去，所以 f f' + f' f'' \\approx 0 ，难怪其对应的泛函导数为零了。\n另外，通过以上两个例子的分析我们可以发现：\n我们分部积分的根本目的就是为了分离变分号 \\delta 和导数 f' ，因此，对于任何被变分和求导同时操作的函数项 f ，我们都需要对它进行分部积分。 由于分部积分的性质 (uv)'=u'v+uv' \\int u'v=[uv]-\\int uv' 因此，我们可以注意要有这样一种便捷的记忆方式，例如对于\nf\\delta f' 变分和求导同时作用于 f ，因此我们需要对此项进行分部积分。而我们可以将该项视为 u'v 或者 uv' 中的任意一项（它们的区别仅仅只是两个乘数互换一下位置而已），一旦确定好了，那么最终的 \\simeq 结果就是另外一项。\n而事实上，不管我们选择哪个形式，根据两者的形式差异，我们就可以断定， \\simeq 结果一定是\nf'\\delta f 利用这种视角我们来看，\nf''\\delta f' 另一项的形式一定是两个乘数的导数次数一赠一减，并且由于我们是分离变分和求导，因此变分号里的导数次数一定是减少的，所以最终的结果就是\nf'''\\delta f 事实上，这相对于是我们将 f''\\delta f' 看成是 uv' ，实际上，我们我们将之看成 u‘v 的话，我们就需要经历以下的过程：\nf''\\delta f'\\Rightarrow f'\\delta f'' 很显然它是需要继续分部积分的，因此\nf''\\delta f'\\Rightarrow f'\\delta f''\\Rightarrow f''\\delta f' 最后再进行一次分部积分得到，\nf''\\delta f'\\Rightarrow f'\\delta f''\\Rightarrow f''\\delta f'\\Rightarrow f'''\\delta f' 这也就是我们在上面的做法，很显然结果是一样的，而且这样是多此一举。\n以及最后，很显然的我们可以发现，每次分部积分的结果都是负的，因此进行奇数次分部积分的结果是负的，偶数次是正的。 ","cover":null,"tags":["经典力学"],"title":"1.3.2 泛函导数的操作定义","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3.2/"},{"content":"目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。\n具体做法如下：\n5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。\n定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：\n0+m:=m 现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为\n(n++)+m:=(n+m)++ 于是， 0+m 就是 m， 1+m 就是 (0++)+m=(0+m)++=m++ ， 2+m 就是 (1++)+m=(1+m)++=(m++)++ ，以此类推。例如：\n2+m=(1++)+m=(1+m)++=(m++)++\\\\ 2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\\\ 根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。\n现在，我们将之前一般化的讨论特殊化为， a_n=n+m 和 f_n(a_n)=a_n++ 的情景。\n注意：我们以上定义的自然数加法是不对称的： 3+5 表明将 3 增长了 5 次，而 5+3 表明将 5 增加了 3 次。不过，它们生成的值是一样的。更一般，对于任意自然数 m、n。有\nm+n=n+m 均成立。（我们将稍后给出其证明）\n引理 2.2.2 对任意自然数 n， n+0=n 恒成立。\n注意，我们的定义是 0+m:=m ，由于我们尚未证明 m+n=n+m 对于任意自然数 n、m 均成立，因此我们不可以直接通过交换律得到 n+0=n 。\n证明:\n采用归纳法来证明。因为 0 + m = m 对任意自然数 m 均成立并且 0 是一个自然数，所以我们能得到最基本的情况 0 + 0 = 0 。\n现在归纳性地假设 n + 0 = n 成立。我们希望证明 (n++) + 0 = n++ 。\n根据加法的定义， (n++) + 0 = (n + 0)++ ；\n又根据 n + 0 = n 可以推导出 (n + 0)++ = n++ 。\n至此整个归纳过程就结束了。 \\Box 引理 2.2.3 对任意的自然数 n 和 m ，有\nn + (m++) = (n + m)++ 成立。\n同样，因为目前我们还不知道有 a + b = b + a ，所以不能从 (n++) + m = (n + m)++ 中推导出本结论。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先考虑最基本的情况， n = 0 。此时我们必须证明\n0 + (m++) = (0 + m)++ 根据加法定义，左侧等于 m++ ，再次根据加法定义，显然右侧也为 m++ ，因此等式成立。\n现在归纳性地假定 n + (m++) = (n + m)++ 成立，那么我们必须证明\n(n++) + (m++) = ((n++) + m)++ 根据加法的定义，上式左端等于 (n + (m++))++ 又由归纳假设可得 (n+(m++))++ = ((n + m)++)++ 。 类似地，根据加法的定义可得， (n++) + m = (n + m)++ ，从而等式的右端也等于 ((n + m)++)++ 。\n因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。 \\Box 作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到\nn++ = n + 1。 因为 n+1=n+(0++)=(n+0)++=n++ 。\n如之前承诺的，现在，我们来证明 a + b = b + a 。\n命题 2.2.4 （加法是可交换的）\n对任意的自然数 n 和 m ，有\nn + m = m + n 成立。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先证明当 n = 0 时结论成立，也就是说证明 0 + m = m + 0 。\n一方面，根据加法的定义可以推出 0 + m = m ；\n另一方面，根据引理 2.2.2 可得 m + 0 = m 。\n于是 n = 0 时结论成立。\n现在归纳性地假设 n + m = m + n 成立，那么我们要证明\n(n++) + m = m + (n++) 来完成归纳。\n根据加法的定义， (n++) + m = (n + m)++ ；\n根据引理 2.2.3， m + (n++) = (m + n)++ ；\n但由归纳假设 n + m = m + n 可知 (m + n)++ = (n + m)++ 。\n因此 (n++) + m = m + (n++) ，进而归纳过程结束。 \\Box 命题 2.2.5 （加法是可结合的）\n对任意三个自然数 a 、 b 、 c ，有\n(a + b) + c = a + (b + c) 成立。\n证明:\n固定 a, c \\in N , 对 b 进行归纳讨论.\n设定当 b = 0 :\n(a + 0) + c = a + c = a + (c + 0) = a + (0 + c) 现在归纳假设 b=n 时命题成立, 需要证明 b=n++ 时命题成立:\n\\begin{align} (a + (n++)) + c \u0026= ((a + n)++) + c \\\\ \u0026= c + ((a + n)++) \\\\ \u0026= (c + a + n)++ \\\\ \u0026= ((a + n) + c)++ \\\\ \u0026= (a + (n + c))++ \\\\ \u0026= a + (n + c)++ \\\\ \u0026= a + ((n++) + c) \\end{align} 根据数学归纳法，命题对所有自然数均成立。\n正是因为有了这条结合律，我们可以把 a, b, c 的和写成 a + b + c 的形式，而无需顾虑它们是按照什么样的次序加起来的。\n下面，我们给出消去律。\n命题 2.2.6 （消去律）\n令 a, b, c 为任意三个自然数并且满足\na + b = a + c, 那么 b = c 成立。\n注意:\n由于目前我们还没有给出减法和负数的概念，所以这里不能利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及了一种“虚拟减法”。\n证明:\n我们通过对 a 进行归纳来证明该命题。\n首先考虑最基本的情况 a = 0 ，我们有\n0 + b = 0 + c, 那么根据加法的定义，由 0 + b = 0 + c 可以得到 b = c ，故命题成立。\n现在归纳性假设关于 a 的消去律成立（进而从 a + b = a + c 中可以得到 b = c ），接下来我们要证明关于 a++ 的消去律也成立。换言之，就是在假设\n(a++) + b = (a++) + c 成立时，去证明 b = c 成立。根据加法的定义，我们有\n(a++) + b = (a + b)++ 和\n(a++) + c = (a + c)++, 从而可以得到\n(a + b)++ = (a + c)++. 根据公理 2.4（任意两个不同的自然数的后继也是不同的），我们进一步得到\na + b = a + c. 显然上式为待证情况的充要条件。因为我们已知关于 a 的消去律成立，所以有 b = c 成立，结论得证。至此归纳法结束。\n\\Box 现在我们讨论加法与正性是如何相互作用的。\n定义 2.2.7 （正自然数） 称一个自然数 n 是正的，当且仅当它不等于 0 。\n命题 2.2.8 如果 a 是正的并且 b 是自然数，那么 a + b 是正的（从而根据命题2.2.4可知， b + a 也是正的）。\n证明： 我们通过对 b 进行归纳来证明该命题。如果 b = 0 ，那么\na + b = a + 0 = a 显然是正的，从而 b = 0 时的结论得证。\n现在归纳性地假设 a + b 是正的。那么根据公理 2.3 (0 不是任何自然数的后继)可知，\na + (b++) = (a + b)++ 不等于零，从而 a + (b++) 是正的。至此归纳法结束。\n\\Box 推论 2.2.9\n如果 a 和 b 是自然数并且满足 a + b = 0 ，那么 a = 0 且 b = 0 。\n证明：\n假设结论的反面 a \\neq 0 或 b \\neq 0 成立。如果 a \\neq 0 ，那么 a 是正的，从而根据 命题 2.2.8 可知， a + b 是正的，这显然与已知条件 a + b = 0 相矛盾。类似地，如果 b \\neq 0 ，那么 b 是正的，同样根据 命题 2.2.8 可知， a + b 是正的，这与 a + b = 0 相矛盾。于是 a 和 b 必须同时为 0 。□\n引理 2.2.10 令 a 表示一个正自然数，那么恰存在一个自然数 b 使得 b++ = a 。\n证明： 根据皮亚诺公理 3 （0 不是任何自然数的后继）和 4（不同自然数的后继互不相同）有 \\forall m, n \\in \\mathbb{N}, S(m) = S(n) \\implies m = n. 则， \\begin{align} \u0026S(b)=a\\\\ \u0026\\forall n \\in \\mathbb{N},\\text{if} S(n)=S(b)=a \\implies n = b. \\end{align} 至此命题成立。\n定义 2.2.11 （自然数的序）\n令 n 和 m 表示任意两个自然数。我们称 n 大于等于 m ，并且记作 n \\geq m 或者 m \\leq n ，当且仅当存在自然数 a 使得 n = m + a 。我们称 n 大于 m ，并且记作 n \u003e m 或者 m \u003c n ，当且仅当 n \\geq m 且 n \\neq m 。\n于是，例如由于 8 = 5 + 3 并且 8 \\neq 5 ，所以 8 \u003e 5 。另外注意，对任意的 n 均有 n++ \u003e n ；因此不存在最大的自然数 n ，这是因为下一个数 n++ 总是更大。\n命题 2.2.12 （自然数的序的基本性质）\n令 a, b, c 为任意自然数，那么：\n(a) （序是自反的） a \\geq a 。\n(b) （序是可传递的）如果 a \\geq b 并且 b \\geq c ，那么 a \\geq c 。\n(c) （序是反对称的）如果 a \\geq b 并且 b \\geq a ，那么 a = b 。 (d) （加法保持序不变） a \\geq b ，当且仅当 a + c \\geq b + c 。\n(e) a \u003c b ，当且仅当 a++ \\leq b 。\n(f) a \u003c b ，当且仅当存在正自然数 d 使得 b = a + d 。\n证明:\n(a) a \\geq a a + 0 = a \\rightarrow a \\geq a (b) a \\geq b,b \\geq c ，那么 a \\geq c \\begin{align} a \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\ b \\geq c \\rightarrow b = c + m, m \\in \\mathbb{N}\\\\ \\end{align} 因此， a = b + n = c + m + n 显然就可得结论， a \\geq c (c) a \\geq b，b \\geq a ，则 a = b \\begin{align} a \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\ b \\geq a \\rightarrow b = a + m, m \\in \\mathbb{N}\\\\ \\end{align} 即 a = a + m + n 显然， m = 0，n = 0 ，则 a = b 。\n(d) a \\geq b if and only if a + c \\geq b + c . \\begin{align} (a \\geq b) \u0026\\iff a = b + m, \\, m \\in \\mathbb{N} \\\\ \u0026\\iff a + c = b + m + c = b + c + m, \\, m \\in \\mathbb{N} \\\\ \u0026\\iff a + c \\geq b + c. \\end{align} (e) a \u003c b if and only if a++ \\leq b .\nWe have\n\\begin{align} (a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\ \u0026\\iff ((a + m = b, \\, m \\in \\mathbb{N}) \\land (a \\neq b)) \\\\ \u0026\\iff m \\neq 0 \\\\ \u0026\\iff \\exists n \\in \\mathbb{N}, \\, n++ = m \\\\ \u0026\\iff a + (n++) = b, \\, n \\in \\mathbb{N} \\\\ \u0026\\iff (a++) + n = b, \\, n \\in \\mathbb{N} (引理 2.2.3)\\\\ \u0026\\iff a++ \\leq b. \\end{align} (f) a \u003c b if and only if b = a + d for some positive number d .\nWe have\n\\begin{align} (a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\ \u0026\\iff (a + d = b, \\, d \\in \\mathbb{N}) \\land (d \\neq 0) \\\\ \u0026\\iff a + d = b, \\, d \\text{ is positive.} \\end{align} 命题 2.2.13 （自然数的序的三歧性）\n令 a 和 b 表示任意两个自然数，那么在下面三种表述中恰有一种表述为真： a \u003c b ， a = b ， a \u003e b 。\n证明：\n首先我们证明 a \u003c b ， a = b 以及 a \u003e b 这三种表述中同时为真的表述个数不超过一个。如果 a \u003c b ，那么根据定义可知 a \\neq b ；同样，如果 a \u003e b ，根据定义可知 a \\neq b 。如果 a \u003e b 并且 a \u003c b ，那么根据命题 2.2.12 可知 a = b ，这显然与 a \\neq b 相矛盾。因此同时为真的表述个数不超过一个。\n现在我们证明至少有一个表述为真。\n保持 b 固定不变，对 a 进行归纳。当 a = 0 时，对所有的 b 均有 0 \\leq b （为什么？）因此我们得到 0 = b 或者 0 \u003c b ，从而 a = 0 时的结论得证。\n现在归纳性地假设关于 a 的命题已经被证明是成立的，下面我们要证明 a++ 也同样成立。\n从关于 a 的三歧性中可知，存在三种可能的情况： a \u003c b ， a = b 以及 a \u003e b 。如果 a \u003e b ，那么有 a++ \u003e b 。（为什么？）如果 a = b ，那么 a++ \u003e b 。（为什么？）现在假设 a \u003c b ，那么根据命题 2.2.12 可知 a++ \\leq b 。于是我们得到要么 a++ = b ，要么 a++ \u003c b ，其中任何一种情况都符合我们的要求。至此归纳法结束。\nWhy 1: When a = 0 , we have 0 \\leq b for all b .\n(0 + b = b, b \\in \\mathbb{N}) \\Rightarrow (0 \\leq b, b \\in \\mathbb{N}) Why 2: If a \u003e b , then a++ \u003e b .\n(a \u003e b) \\Rightarrow (a = b + m, m \\in \\mathbb{N}) \\land (a \\neq b) \\\\ \\Rightarrow a++ = b + (m++) \\Rightarrow a++ \u003e b Why 3: If a = b , then a++ \u003e b .\n(a = b) \\Rightarrow a++ = b++ = (b + 0)++ = b + (0++) = b + 1 \\\\ \\Rightarrow a++ \u003e b 命题 2.2.14 （强归纳法原理）\n令 m_0 表示一个自然数， P(m) 表示与任意自然数 m 有关的性质。假设对任意满足 m \\geq m_0 的自然数 m ，均有如下内容成立：若 P(m') 对任意满足 m_0 \\leq m' \u003c m 的自然数 m' 均为真，那么 P(m) 也为真。（特别地，这意味着 P(m_0) 为真，因为当 m = m_0 时，前提中的 m' 取值范围为空。）于是我们能够断定，对于任意满足 m \\geq m_0 的自然数 m ， P(m) 为真。\n注 2.2.15 在应用强归纳法原理的时候，我们通常令 m_0 = 0 或者 m_0 = 1 。\n证明： 设 P(m) 是一个与自然数 m 相关的命题。如果满足以下条件：\n基础情况：当 m = m_0 时， P(m_0) 为真。 归纳假设：对于任意 m \u003e m_0 ，如果 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 也为真。 则结论是： P(m) 对所有 m \\geq m_0 成立。\n证明过程\n1. 用普通归纳法重新定义问题\n设 Q(n) 表示如下命题：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ，命题 P(m) 都为真。\n我们的目标是证明：对于所有正整数 n ， Q(n) 成立。这等价于强归纳原理，因为 Q(n) 的结论覆盖了 P(m) 在 m \\geq m_0 的所有情况。\n2. 验证基础情况\n当 n = 1 时， Q(1) 的含义是：对于所有 m 满足 m_0 \\leq m \u003c m_0 + 1 ， P(m) 为真。\n因为能满足 m_0 \\leq m \u003c m_0 + 1 的自然数 m 只有 m_0 ，因此此情况下性质仅涉及 P(m_0) ，而强归纳原理假设， P(m_0) 为真，因此 Q(1) 为真。\n3. 验证归纳步骤\n假设 Q(n) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ， P(m) 为真。\n需要证明 Q(n+1) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n + 1 ， P(m) 为真。\n根据 Q(n) ，我们已经知道：\nP(m') 对于所有 m_0 \\leq m' \u003c m_0 + n 都成立。 我们现在需要证明 P(m_0 + n) 为真。这与基础情况的逻辑是相同的。\n因为 Q(n+1) 的定义是 Q(n+1) := \\forall m(m_0 \u003c m \u003c m_0 + n + 1 \\rightarrow P(m) \\text{为真}) 根据归纳假设， Q(n) 为真，即 P(m) \\text{对于所有的} m_0 \\le m \u003c m_0 + n \\text{都为真} 所以我们有待验证的范围还剩下 m_0 + n \\le m \u003c m_0 + n + 1 而满足上述范围的自然数 m 只有 m_0 + n 。\n综上，我们只需要证明 P(m_0 + n) 为真，即可得到 Q(n+1) 为真。\n根据强归纳原理假设，若 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 为真。\n将 m = m_0 + n 代入，这里 P(m') 对所有 m_0 \\leq m' \u003c m_0 + n 已经成立（由归纳假设 Q(n) ），因此 P(m_0 + n) 为真。\n结合归纳假设，我们得出 Q(n+1) 为真。\n4. 归纳完成\n通过普通数学归纳法，我们证明了 Q(n) 对所有正整数 n 都成立。这意味着：\n对于所有 m \\geq m_0 ， P(m) 为真。 逆向归纳法原理\n令 n 表示一个自然数， P(m) 是关于自然数的一个性质并且满足：只要 P(m++) 为真， P(m) 就为真。假设 P(n) 也为真，证明： P(m) 对任意满足 m \\leq n 的自然数 m 均为真；这被称为逆向归纳法原理。（提示：对变量 n 使用归纳法。）\n证明： Induction on n , let Q(n) represent:\nQ(n) := \\{ P(m) \\text{ is true, } \\forall m \\leq n \\} Case 0: Q(0) is true.\nIf Q(k) is true, then consider Q(k++) :\nQ(k++) = \\{ P(m) \\text{ is true, } \\forall m \\leq k++ \\} ,\nas P(k++) is true. Hence, Q(k++) is true.\nThe induction is valid.\n","cover":null,"tags":["数学分析"],"title":"2.2 加法和归纳原理的两个变体","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/"},{"content":"在学习实数分析之前，我们首先要回溯数的概念以及数的性质。\n我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?\n实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。\n现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。\n自然数集定义 定义 2.1.1 （非正式的）自然数是集合\nN := \\{ 0, 1, 2, 3, \\cdots \\} 的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。\n注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \\{1, 2, 3, \\cdots \\} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。\n从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：\nN 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？\n我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？\n我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：\na^3 = a \\cdot a \\cdot a 。\n乘法运算只不过是对加法运算的重复迭代：\n3 \\cdot a = a + a + a 。\n（由于减法和除法运算并不完全适用于自然数的运算，因此我们暂不讨论。我们在整数数和有理数对应的章节时，会对这些运算进行讨论。）\n加法和增量运算 那么加法又是怎么定义的呢？加法就是重复往前计数或者不断增加的运算。\n如果你把 5 加上 3 ，也就是使得 5 增长了三次。另外，增长看起来是一个基本的运算，它不能再被拆解为更加简单的运算。\n于是，为了定义自然数，我们将使用如下两个基本概念：数 0 和增量运算。我们使用 n++ 来表示 n 的增量或者紧跟在 n 后面的数字。例如： 3++ = 4, (3++)++ = 5 。\n注意，这与计算机的语言不同，在数学中，我们对一个变量只赋值一次。\n因此，这看起来就似乎说明 N 是由 0 以及所有能通过增量运算由 0 得到的数构成的。这就是 N 应该如下对象构成的：\n0, 0++, (0++)++, \\cdots 如果我们把自然数用上述对象来表示，那么得到了如下关于 0 和增量运算的公理。\n公理2.1 ~ 定义2.1.3 定义自然数集的具体元素 公理 2.1 0 是自然数。\n公理 2.2 如果 n 是自然数，那么 n++ 也是自然数。\n于是，举例来说，我们能通过公理2.1和公理2.2，可以推的 (0++)++ 是一个自然数。为了计数书写的方便，我们又有如下的定义。\n定义 2.1.3\n我们定义1为数 0++ ，2为数 (0++)++ 等等。\n于是，举例来说，我们有：\n命题 2.1.4 3 是一个自然数\nproof:\n根据公理2.1可知， 0 是一个自然数。根据公理2.2， 0++ = 1 是一个自然数。又根据公理2.2， 1++ = 2 也是自然数，那么再通过依序公理2.2， 2++ = 3 自然也是自然数。\n目前看来，我们对自然数已经有了充分的描述，但对于 N 的性质尚未彻底厘清。\n公理2.3 ~ 公理2.5 定义自然数系的具体性质 虽然我们定义了 0 和增量运算，并打算以此来构建自然数系，但是我们并没有对自然数系的性质做出规定。例如我们目前没有方法确定定义的自然数系会不会出现循环的情况，即\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 0 为了防止以上这种循环情况的产生，我们将引入另外的公理。\n公理 2.3\n0 不紧跟在任何自然数之后。换言之，对于任意一个自然数 n ， n++ \\neq 0 均成立。\n如此一来，我们就有防止循环情况出现的工具了。\n命题 2.1.6 4 \\neq 0 proof:\n根据定义 4 = 3++ ，根据公理2.1和公理2.2，可知 3 是一个自然数，故根据公理2.2， 4 也是一个自然数，再根据公理2.3，我们就有 3++ = 4 \\neq 0 。\n除此之外，我们还需要对其他的性质进行研究和规定，否则我们的数系仍然会存在很多病态的性质。\n例 2.1.7\n考虑由 0, 1, 2, 3, 4 构成的数系。在这个数系里，增量运算在遇到 4 时达到了运算的极限。换言之，在这个数系里\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 4, \\, 4++ = 4 （换言之，也就是 5 = 4++ = 4, 7 = 4++ = 4 ）。这种情况并不违背我们上面规定的任何公理或者定义，甚至，我们虽然防止了我们的自然数系出现绕回到 0 的情况，但它仍然可以绕回到 1, 2 等其他自然数。\n有许多的方法可以阻止这些情况发生，最简单的方法是设定下面的公理成立。\n公理 2.4\n对于不同的自然数而言，紧跟在它们之后的数字也必然不同。也就是说，如果 n 和 m 都是自然数，并且 n \\neq m ，那么 n++ \\neq m++ 。\n等价地说，如果 n++ = m++ ，则 n = m 。\n命题 2.1.8 6 不等于 2\nproof:\n使用反证法，假设 6 = 2 ，那么有 5++ = 1++ 。根据公理2.4，有 5 = 1 ，进而有 4++ = 0++ 。再次利用公理2.4，也就有 4 = 0 。在我们的数系中，只有 0 \\sim 4 这几个数是被定义好的，所有根据我们的规定， 4 = 0 与命题2.1.6矛盾，所有我们有结论 6 \\neq 2 。\n规定了上述的公理后，我们还需要考虑这样的自然数系的元素问题，目前来看，好像所有的自然数都是两两不同的，我们已经确定 0, 1, 2, 3, 4, \\cdots 是自然数系的不同对象，但是它们之间是否有其他形式的数字存在呢？\n例 2.1.9 （非正式的）\n假设我们的数系 N 是由如下的整数和半整数共同构成的：\nN := \\{0, 0.5, 1, 1.5, 2, 2.5, \\cdots\\} （该例之所以是非正式的是因为，我们提前使用了实数，但我们现在还没有定义实数。）容易验证，这个例子仍然满足公理2.1~公理2.4。\n为此我们希望有这样一个公理，它告诉我们自然数系的所有元素都可以通过对 0 进行增量运算来得到，从而能够从 N 中排除像 0.5 这种形式的元素。幸运的是，我们有一种巧妙的解决办法达到前述要求：\n公理 2.5 （数学归纳法）\n令 P(n) 表示自然数 n 满足的一种任意的性质，如果 P(0) 为真并且 P(n) 为真时 P(n++) 也为真，则对于任意的自然数 n ， P(n) 一定为真。\n隐藏在这个公理中的通俗的直观的说明如下：假设 P(n) 满足以下条件： P(0) 为真，且 P(n) 为真时 P(n++) 也为真，那么由于 P(0) 为真，所以 P(0++) = P(1) 也为真，进而 P(1++) = P(2) 也为真，以此类推我们可以得到 P(0), P(1), P(2), P(3), \\cdots 均为真。\n然而根据这样的规定，我们根本没有定义 0.5 这样的元素，因此公理2.5对 P(0.5) 是失效的，从而我们就避免了自然数系中出现附带的奇怪对象。\n在公理2.5之上，我们将在习题中给出关于它的其他形式，它们分别是：逆向归纳法、强化归纳法和超限归纳法*（这名字好酷对吧）。\n公理2.1 ~ 公理2.5被称为皮亚诺公理，这套公理系统就是定义自然数系的方法之一。为了定义自然数系，我们假设存在一个数系 N ，我们称 N 中的元素为自然数，而且公理2.1 ~ 公理2.5对 N 均成立。\n根据前面的所有规定，我们可以得到以下的这个结论：现在我们可以递归的定义序列。\n递归定义 假设我们通过以下方式来构造数列 a_0, a_1, a_2, \\cdots ：首先定义 a_0 的基值。例如，令 a_0 = c ，其中 c 是一个固定的数字。然后令 a_1 为关于 a_0 的某个函数： a_1 := f_0(a_0) ，令 a_2 为关于 a_1 的某个函数： a_2 := f_1(a_1) 。以此类推，一般地，我们记 a_{n++} := f_n(a_n) ，其中 f_n 是 N \\to N 的某个函数。利用前面的公理可以推出，对于任意给定的自然数 n ，上述过程将对应数列中的元素 a_n 给出唯一的值。\n更准确的说：\n命题 2.1.10 （递归定义）\n假设对于任何自然数 n ，都存在从自然数系到自然数系的函数 f_n: N \\to N ，令 c 为某个固定的自然数，那么对于任意的自然数 n ，都可以唯一确定自然数 a_n ，使得 a_0 = c 以及 a_{n++} = f_n(a_n) 恒成立。\nproof:\n利用归纳法。首先，根据题设，我们有 a_0 = c 。假设，题设的过程对 a_m 赋予了单一的值，由于公理2.3（ n++ \\neq 0 ）和公理2.4（ n++ \\neq m++ \\iff n \\neq m ），可知上述过程 a_{n++} := f_n(a_n) 对 a_n 来说是不会改变 a_n 的赋值的，因此可知上述过程也同样使得 a_{n++} 被唯一赋值了。那么根据数学归纳法，对于任意的自然数 n ， a_n 都被定义了，并且每个 a_n 都赋予了唯一的值。\n注意所有的公理在这个过程中是如何被应用的。在一个数系中，如果存在某种类型的绕回状况，那么递归定义就不适用于该数系。这是因为序列中的某些元素将会连续不断地被重新定义。例如，在例2.1.5中，因为 3++ = 0 ，所以 a_0 （至少）存在两种相矛盾的定义， c 或者 f_3(a_3) 。在一个含有多余元素（比如 0.5 ）的数系中，元素 a_{0.5} 将永远不会被定义。\n对于递归定义，我（笔记书写者）的理解是，我们首先固定了 a_0 = c ，然后递归的过程是\n\\begin{aligned} a_1 \u0026 := f_0(a_0), \\\\ a_2 \u0026 := f_1(a_1), \\\\ a_3 \u0026 := f_2(a_2), \\\\ \\text{也就是 } a_3 \u0026 := f_2(f_1(f_0(a_0))). \\end{aligned} 所以它就是固定一个对象，然后通过一系列函数的嵌套运算过程给出另一个对象的唯一赋值，通过对递归定义的重复应用，我们就可以定义出一系列对象，从而组成一个序列。\n一个简单的示例就是泰勒展开：\n我们知道导数的定义是\n\\frac{dy}{dx} = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} 从图像上讲，也就是说在曲线上的两点 (x_0, f(x_0)), (x_0 + \\Delta x, f(x_0 + \\Delta x)) 当横坐标无限靠近时，导数曲线上两点的点成也无限靠近，此时连接两点的直线成为曲线上的切线，两点成为一个切点。在这个切点上，切线与曲线的斜率就是导数的值。\n二阶导数是\n\\frac{d^2y}{dx^2} = \\lim_{\\Delta x \\to 0} \\frac{df(x_0 + \\Delta x) - df(x_0)}{\\Delta x}. 也就是说对于原函数曲线，一阶导组成的曲线在 (x_0, df(x_0)) , (x_0 + \\Delta x, df(x_0 + \\Delta x)) 切点处的导数， df(x_0) 就是原函数曲线在 x_0 和 x_0 + \\Delta x (\\Delta x \\to 0) 处的导数， df(x_0 + \\Delta x) 就是原函数曲线在 x_0 + \\Delta x 和 x_0 + 2\\Delta x (\\Delta x \\to 0) 处的导数，这在原函数曲线上表现为 f(x_0) \\sim f(x_0 + \\Delta x)(\\Delta x \\to 0) ， f(x_0 + \\Delta x) \\sim f(x_0 + 2\\Delta x)(\\Delta x \\to 0) 。这两段相连的曲线，我们知道因为 \\Delta x \\to 0 所以这两段曲线都缩略了两个点，而二阶导就是对这两点之间曲线段的拟合度的衡量。\n以此类推， x_0 处的三阶导、四阶导实际上就是通过对求导这个操作把原函数曲线在 x_0 的邻域内的曲线段一遍遍的放大，然后用切线来拟合曲线。\n所以泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x - x_0) + \\frac{f''(x_0)}{2!}(x - x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n, \\, R_n(x) = o\\left((x - x_0)^n\\right) 就是函数 f(x) 在 x_0 处，通过 n 次求导迭代得到的最终拟合的结果。而根据迭代的定义，我们知道这个迭代的拟合的过程中给出的赋值是唯一的，并且我们可以根据迭代次数来构造一个不同次迭代赋值得到的函数值的序列。\n总结 总而言之，以下是皮亚诺公理的全部内容：\n公理假设 皮亚诺公理假设存在一个集合 \\mathbb{N} ，其元素被称为自然数，以及一个称为“后继函数”的映射 S: \\mathbb{N} \\to \\mathbb{N} ，满足以下五条公理：\n五条皮亚诺公理 零是自然数：\n0 \\in \\mathbb{N}. （注：有些表述中将 0 换为 1 ，视具体情况而定。）\n每个自然数都有一个后继：\n\\forall n \\in \\mathbb{N}, S(n) \\in \\mathbb{N}. 后继函数 S 为每个自然数定义一个唯一的“下一个”自然数。\n零不是任何自然数的后继：\n\\forall n \\in \\mathbb{N}, S(n) \\neq 0. 这保证了自然数序列是以 0 为起点、向后无限延伸的，且没有“前驱”。\n不同的自然数有不同的后继（后继函数是单射）：\n\\forall m, n \\in \\mathbb{N}, \\, S(m) = S(n) \\implies m = n. 这保证了后继函数不会将两个不同的自然数映射到同一个自然数。\n数学归纳原理：\n若一个性质 P 满足以下两点：\nP(0) 成立； 对任何 n \\in \\mathbb{N} ，如果 P(n) 成立，则 P(S(n)) 也成立， 则 P(n) 对所有 n \\in \\mathbb{N} 成立。\n数学归纳原理确保可以对自然数集合进行递归定义和归纳证明。\n解释与扩展 皮亚诺公理定义了自然数的基本结构，其中 S 通常被解释为“加 1”操作。例如：\nS(0) 通常表示 1 ， S(S(0)) 表示 2 ，以此类推。 递归定义 通过皮亚诺公理可以递归定义自然数的加法和乘法等运算：\n加法定义：\nn + 0 = n, \\quad n + S(m) = S(n + m). 乘法定义：\nn \\cdot 0 = 0, \\quad n \\cdot S(m) = (n \\cdot m) + n. 数学基础中的地位 皮亚诺公理在数学基础中占有重要地位，为数理逻辑、集合论以及模型论等领域提供了形式化的支柱。\n","cover":null,"tags":["数学分析"],"title":"2.1 皮亚诺公理","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/"},{"content":"层叠样式表（Cascading Style Sheets，CSS）是一种强大的编程语言，可用于改变文档或文档集合的呈现方式，它几乎已经渗透到网络的每个角落以及许多表面上非网络的环境中。例如，嵌入式设备的显示通常使用 CSS 来设计其用户界面，许多 RSS 客户端允许你对订阅源和订阅条目应用 CSS，一些即时消息客户端使用 CSS 来格式化聊天窗口。CSS 的某些方面甚至可以在 JavaScript (JS) 框架的语法中以及 JS 本身中找到。它无处不在！\nCSS 最早在 1994 年被提出，当时正值互联网开始真正流行之际。当时，浏览器赋予用户大量的样式控制能力——例如，NCSA Mosaic 的显示偏好允许用户定义每种元素的字体系列、大小和颜色。而文档作者却没有任何这样的能力；他们只能将内容标记为段落、某一级别的标题、预格式化文本或其他十几种元素类型之一。如果用户将其浏览器配置为使所有一级标题变得又小又粉红，而所有六级标题变得又大又红，那完全是用户自己的选择。\nCSS 正是在这种环境中被引入的。其目标是为网页作者提供一种简单的声明式样式语言，既灵活又强大，最重要的是，能够同时为作者和用户提供样式控制能力。通过层叠机制，这些样式可以被组合和优先排序，使网站作者和读者都能表达自己的需求——尽管最终的决定权始终在读者手中。\n工作迅速推进，到 1996 年底，CSS1 已经完成。尽管新成立的 CSS 工作组继续推进 CSS2 的开发，但浏览器在以互操作性方式实现 CSS1 时遇到了困难。尽管 CSS 的每个部分本身都相对简单，但它们的组合却产生了一些令人意想不到的复杂行为。不幸的是，还出现了一些问题，比如臭名昭著的盒模型实现差异。这些问题一度威胁到 CSS 的发展，但幸运的是，一些巧妙的提议被实施，浏览器开始趋于一致。在接下来的几年里，随着互操作性的增强以及像《Wired》杂志基于 CSS 的重新设计和 CSS Zen Garden 等高调发展项目的推动，CSS 开始流行起来。\n在这一切发生之前，CSS 工作组于 1998 年初完成了 CSS2 规范。CSS2 甫一完成，随即开始了 CSS3 的开发以及一个经过澄清的版本 CSS2.1 的工作。与当时的潮流一致，最初称为 CSS3 的规范被设计为一系列（理论上）独立的模块，而不是一个庞大的整体规范。这种方法反映了当时活跃的 XHTML 规范，它也因类似的原因被分解为模块。\n对 CSS 进行模块化的理由是，每个模块可以按照自己的节奏进行开发，特别是重要或流行的模块可以沿着万维网联盟（W3C）的进展路径快速推进，而不会被其他模块拖延。事实上，这种方式确实奏效了。截至 2012 年初，已有三个 CSS Level 3 模块（以及 CSS1 和 CSS 2.1）达到了完整的推荐标准——CSS Color Level 3、CSS Namespaces 和 Selectors Level 3。同时，有七个模块达到了候选推荐（Candidate Recommendation）状态，还有数十个模块处于各种工作草案阶段。如果按照旧的方法，颜色、选择器和命名空间模块必须等到规范的所有其他部分完成或被舍弃之后，才能成为完成的规范的一部分。多亏了模块化设计，它们无需等待。\n因此，虽然我们无法指着一本完整的文档说“这就是 CSS”，但我们可以根据模块名称来讨论特性，因为这些特性是通过模块引入的。模块带来的灵活性远远弥补了它们有时造成的语义上的尴尬。（如果你想要接近单一整体规范的内容，CSS 工作组每年都会发布“Snapshot”文档。）\n有了这些背景知识，我们就可以开始理解 CSS 了。让我们从样式表的基本内容开始讲起。\n","cover":null,"tags":["前端开发"],"title":"1.1 (web)style 简史","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.1/"},{"content":"在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：\n1 2 3 4 5 6 7 8 /* 示例代码，仅用于展示 */ .example h1 { color: maroon; /* 改变一级标题颜色 */ } .example body { background: yellow; /* 设置背景颜色 */ } 诸如此类的样式共同构成了样式表的主体。\n规则的结构 为了更详细的说明规则的概念，让我们分解下代码的结构。\n每条规则由两个基本部分组成：选择器（selector）和声明块（declaration block）。声明块包含一个或多个声明（declaration），而每个声明由一个属性（property）和一个值（value）组成。每个样式表都是由这样的一系列规则构成的。图 1-1 展示了规则的各个部分。 选择器位于规则的左侧，用于定义文档中哪些部分将被选中进行样式应用。在图 1-1 中，选择器为 \u0026lt;h1\u0026gt;，表示选择所有一级标题（heading level 1）元素。如果选择器是 p，那么所有段落（\u0026lt;p\u0026gt;）元素将被选中。\n规则的右侧是声明块，由一个或多个声明组成。每个声明由一个 CSS 属性和该属性的值组成。在图 1-1 中，声明块包含两个声明。第一个声明指定规则会将文档的某些部分设置为红色文本，第二个声明指定文档的某些部分将有一个黄色背景。因此，文档中的所有 \u0026lt;h1\u0026gt; 元素（由选择器定义）将被设置为红色文本，并带有黄色背景。\n供应商前缀（Vendor Prefixing） 有时，您会看到 CSS 的某些部分带有连字符和标签，例如：-o-border-image。这些供应商前缀是浏览器供应商用来标记某些属性、值或其他 CSS 部分为实验性或专有功能（或者两者兼有）的一种方式。截至 2023 年初，仍有一些供应商前缀在使用，其中最常见的如表 1-1 所示。 如表1-1所示，供应商前缀的通用格式通常是连字符、标签和连字符，尽管有几个前缀错误地省略了第一个连字符。\n供应商前缀的使用与滥用历史悠久、复杂且超出了本书的范围。简单来说，它们最初的目的是为浏览器供应商提供测试新功能的方式，从而加速互操作性的发展，同时避免被与其他浏览器不兼容的遗留行为所束缚。这避免了一类几乎在 CSS 初期扼杀其发展的问题。然而，不幸的是，这些带前缀的属性随后被网页作者广泛使用，最终导致了全新的一类问题。\n截至 2023 年初，带有供应商前缀的 CSS 功能几乎已经不存在，旧的前缀属性和值正被浏览器实现逐步且稳定地移除。您可能永远不需要编写带前缀的 CSS，但可能会在实际项目中遇到，或者从遗留代码库中继承以下类似的代码：\n/* 示例代码，演示供应商前缀 */ .example { -webkit-transform: rotate(45deg); /* WebKit 内核浏览器 */ -moz-transform: rotate(45deg); /* Gecko 内核浏览器 */ -ms-transform: rotate(45deg); /* Trident 内核浏览器 */ -o-transform: rotate(45deg); /* 旧版 Opera 浏览器 */ transform: rotate(45deg); /* 标准 CSS 写法 */ } 这段代码实际上表达了同样的内容四次：分别为 WebKit（如 Safari、Chrome）、Gecko（如 Firefox）和 Opera 浏览器的前缀版本，最后是符合 CSS 标准的写法。再次强调，这种写法已经不再必要。我们在此仅包含它是为了让您对其可能的外观有一个概念，以备将来遇到类似情况时能够识别。\n空白符处理 CSS 基本上对规则之间的空白符不敏感，对规则内部的空白符也不太敏感，尽管存在一些例外情况。\n通常，CSS 处理空白字符的方式与 HTML 相同：任何连续的空白字符序列都会在解析时折叠为一个空格。因此，你可以以下列方式格式化这个假设的彩虹规则：\nrainbow: infrared red orange yellow green blue indigo violet ultraviolet;\nrainbow: infrared red orange yellow green blue indigo violet ultraviolet ; 以及你能想到的任何其他分隔模式。唯一的限制是分隔字符必须是空白字符：空格、制表符或换行符，单独使用或组合使用，数量不限。\n类似地，你可以以任何喜欢的方式用空格格式化一系列规则。以下这些都是这只是无数可能性中的五个例子：\n/* 示例代码，演示空白符处理 */ /* 示例样式仅应用于 .example 类范围 */ .example html {color: black;} /* 黑色文字 */ .example body {background: white;} /* 白色背景 */ .example p {color: gray;} /* 灰色段落文字 */ .example h2 {color: silver;} /* 银色标题 */ .example ol { color: silver; /* 银色有序列表 */ } 正如你从第一条规则中看到的，空白字符在很大程度上可以省略。实际上，这通常是压缩 CSS 的情况，压缩 CSS 是指移除了所有多余空白字符的 CSS，通常由某种自动化的服务器端脚本完成。第一条规则之后的规则逐步使用了更多的空白字符，直到最后一条规则，几乎每个可以分开到单独一行的部分都被分开了。\n所有这些方法都是有效的，所以您应该选择最有意义的格式——也就是最容易读懂的格式，并坚持使用它。\nCSS 中的注释 CSS允许注释。这些注释与 C/C++ 注释非常相似，它们被/* 和 */包围：\n/* This is a CSS comment */\n注释可以跨越多行，就像 C++ 一样。\n/* This is a CSS comment, and it can be several lines long without any problem whatsoever. */\n重要的是要记住，CSS 注释不能嵌套。例如，这是不正确的：\n/* This is a comment, in which we find another comment, which is WRONG /* Another comment */ and back to the first comment, which is not a comment.*/ 一种意外创建“嵌套”注释的情况是暂时注释掉包含注释的大块样式表。由于 CSS 不允许嵌套注释，“外层”注释会在“内层”注释结束的地方结束。\n不幸的是，CSS 中没有像 // 或 # 这样的“单行注释”模式（其中 # 已经被保留用于 ID 选择器）。CSS 中唯一的注释模式是 /* */。因此，如果您希望在与标记相同行中添加注释，需要注意放置的方式。例如，这是正确的做法：\n/* 示例代码，演示 CSS 单行注释的正确用法 */ .example h1 {color: gray;} /* 一级标题为灰色 */ .example h2 {color: silver;} /* 二级标题为银色 */ .example p {color: white;} /* 段落文字为白色 */ .example pre {color: gray;} /* 预格式化文字为灰色 */ 以下示例中，因为有四行注释都没有正确标注，大部分样式表将成为注释的一部分，因此将无法生效：\n.example h1 {color: gray;} /* This CSS comment is several lines .example h2 {color: silver;} long, but since it is not wrapped .example p {color: white;} in comment markers, the last three .example pre {color: gray;} styles are part of the comment. */ 在此示例中，只有第一条规则（h1 {color: gray;}）会应用到文档中。其余规则作为注释的一部分，被浏览器的渲染引擎忽略。\nCSS 注释被 CSS 解析器视为完全不存在，因此在解析时不算作空白字符。这意味着我们可以将它们放在规则的中间，甚至直接插入到声明中！\n标记（Markup） 样式表中没有标记（markup）。唯一的例外是 HTML 注释标记，由于历史原因，它被允许出现在 \u0026lt;style\u0026gt; 元素中：\n\u0026lt;!-- 示例代码，用于展示历史标记 --\u0026gt; \u0026lt;style\u0026gt; /* 这种写法仅为历史兼容性展示 */ .example h1 {color: maroon;} /* 一级标题为栗色 */ .example body {background: yellow;} /* 背景为黄色 */ \u0026lt;/style\u0026gt; 就像这样，不过即使是以上这样的代码也不再被推荐；需要它的浏览器已经几乎被遗忘了。\n说到标记，现在是时候稍微绕一下弯路来讨论 CSS 将用于设置样式的元素，以及 CSS 如何以最基本的方式影响这些元素。\n特别提示：在 Markdown 文档中嵌入示例代码块时，请注意添加诸如 .example 这类的名称来规避代码块对页面的影响。例如，如果我们在本文的第一个示例中忽略 .example 而直接书写 p 等选择器时，由于恰好示例代码是 css 代码，且示例代码恰好是全局选择器，因此我们新添加的属性值就会更改原来的页面样式。\n","cover":null,"tags":["前端开发"],"title":"1.2 样式表内容","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/"},{"content":"使用简单的文本编辑器，输入前面的任一示例并以文件名保存，如 helloworld.html 或 helloworld.htm；你可以选择使用 .htm 或 .html 文件扩展名，但无论你选择哪个进行开发，都要保持一致。这本书的所有文件都使用 .html。\n将示例文件保存到本地文件系统后，在 Web 浏览器中打开它，方法是打开文件菜单，然后根据你的浏览器选择打开、打开页面或打开文件： 一旦您的浏览器读取了该文件，它就应该呈现如下所示的页面： 如果由于某种原因没有使用适当的扩展名保存文件，则浏览器不会尝试解释 HTML 标记。例如，请注意当你尝试以 .txt 扩展名打开内容时: 如果要对文档进行更改，可以更新标记，保存文件，返回浏览器，然后单击重新加载或刷新按钮。有时，浏览器仍会从其缓存中重新加载页面；如果页面在重新加载时没有正确更新，请在按住 Shift 键的同时单击重新加载按钮，浏览器应该会刷新该页面。\n在编写标记时，保持浏览器和编辑器同时打开是一个非常好的主意，以避免不断地重新打开其中之一。许多 Web 编辑器将帮助您将 Web 页面加载到各种浏览器中，甚至直接预览标记的可视化。图1-1显示了 Adobe 广受欢迎的 Dreamweaver 程序[]。 ","cover":null,"tags":["前端开发"],"title":"1.3 Viewing Markup Locally","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.3/"},{"content":"在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。\n1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。\n数学中的语句按照分支被分为各自分支中的基本语句和复合语句。\n具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\\cdot7+2\\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 \u003c 来表征小于的线性序关系，那么 1+2\u003c2+3 、 5\\cdot2\u003c5\\cdot3 就都是基础语句。\n复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如\n\\begin{array}{l} ((5 \\cdot 2\u003c3 \\cdot 2) \\rightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\leftrightarrow(0=1)) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\vee(\\neg(0=1))) \\\\ ((5 \\cdot 2\u003c3 \\cdot 2) \\wedge(\\neg(0=1))) \\end{array} 就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：\n\\neg(非),\\rightarrow(蕴含),\\leftrightarrow(对等),\\vee(或),\\wedge(且) 其中，\n1.符号\u0026quot; \\neg \u0026quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”\n2.符号\u0026quot; \\rightarrow \u0026quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”\n3.符号\u0026quot; \\leftrightarrow \u0026quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思\n4.符号\u0026quot; \\vee \u0026quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”\n5.符号\u0026quot; \\wedge \u0026quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”\n基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：\n\\begin{array}{l} 5\\cdot7+2\\cdot3=41\\\\ 5\\cdot3=11 \\end{array} 在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \\{0,1\\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。\n复合语句真假判定归结过程 复合语句的真假判定依赖于复合语句的布尔值计算规则。\n同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。\n我们约定用 1 来表示真，用 0 来表示假。并且 1\\ne 0 。复合语句的真假赋值必须遵从以下五条计算等式规则：\n1.否定词计算规则：‘并非’\n如果 A 是一个已经被赋值了的较低层次的逻辑命题，那么对于 A 的否定式 (\\neg A) 的赋值必须满足下述背反等式的要求：\n对 (\\neg A) 赋值为 1 的充要条件是对 A 的赋值为 0 ,对 (\\neg A) 赋值为 0 的充要条件是对 A 的赋值为 1 2.蕴含词计算规则：‘如果，那么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式 (A\\rightarrow B) 的真值赋值必须满足下述蕴含等式要求：对 (A\\rightarrow B) 的赋值为 0 的充分必要条件是 “(对 A 赋值为 1 ，对 B 赋值为 0 )”。 在蕴含赋值计算表中，我们将蕴含式 (A \\to B) 放于最右侧是因为， (A \\to B) 命题的层级比 A 和 B 都高，对于 (A \\to B) 的真值的赋值依赖于对 A 和 B 的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。\n3.析取词计算规则：‘要么，要么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的析取式 (A \\lor B) 的赋值必须满足下述析取等式要求：对 (A \\lor B) 的赋值为 1 的充分必要条件是 “（或对 A 的赋值为 1 ，或对 B 的赋值为 1 ）”，对 (A \\lor B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，并且对 B 的赋值也为 0 ）”。\n4.合取词计算规则：‘不仅，而且’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么他们的合取式 (A \\land B) 的赋值必须满足以下合取等式要求：对 (A \\land B) 的赋值为 1 的充分必要条件是 “（对 A 的赋值为 1 ，并且对 B 的赋值也为 1 ）”，对 (A \\land B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，或对 B 的赋值为 0 ）”。\n5.对等词计算规则：‘当且仅当’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的对等式 (A \\leftrightarrow B) 的赋值必须满足以下对等等式要求：对 (A \\leftrightarrow B) 赋值为 1 的充分必要条件是 “（对 A 和对 B 的赋值是相等的）”，对 (A \\leftrightarrow B) 赋值为 0 的充分必要条件是 “（对 A 和对 B 的赋值是不相等的）”。\n从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）\n\\begin{array}{l} 1. \\, A \\, \\text{与} \\, (\\neg(\\neg A)) \\, \\text{等价} \\\\ 2. \\, (A \\to B) \\, \\text{与} \\, ((\\neg B) \\to (\\neg A)) \\, \\text{等价} \\\\ 3. \\, (A \\lor B) \\, \\text{与} \\, (B \\lor A) \\, \\text{等价} \\\\ 4. \\, (A \\land B) \\, \\text{与} \\, (B \\land A) \\, \\text{等价} \\\\ 5. \\, (A \\leftrightarrow B) \\, \\text{与} \\, (B \\leftrightarrow A) \\, \\text{等价} \\end{array} 另外两条规律也值得注意：\n\\begin{array}{l} 6. \\, \\text{如果} \\, (A \\to B) \\, \\text{并且} \\, (B \\to C), \\, \\text{则} \\, (A \\to C) \\\\ 7. \\, \\text{如果} \\, (A \\leftrightarrow B) \\, \\text{并且} \\, (B \\leftrightarrow C), \\, \\text{则} \\, (A \\leftrightarrow C) \\end{array} 在数学逻辑中，我们实际上可以只要一条基本的推导规则：由 A 和 (A \\to B) 导出 B 来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。\n另外还需要注意，人们时常使用 \\Leftarrow 代替 \\leftarrow ， \\Rightarrow 代替 \\rightarrow ， \\Leftrightarrow 代替 \\leftrightarrow 。\n1.1.2 表达式及其语义解释 基本表达式及其语义解释 一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。\n比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：\nx+(y+z)=(x+y)+z\\\\ 当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。\n前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如， x+y=y+x 这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?\n在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为论域。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的结构就是线性代数的基本对象。\n因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。\n第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如\n1，2，3\\cdots2024\\cdots\\\\ 为一个项。\n任何一个被用来表示任意个体的变量（符号），比如\nx,y,z,A,B,C\\cdots \\\\ 也是一个项。\n然后，由任意两个已有的项 t_1 和 t_2 经过加法、乘法运算就可以得到新的项\nt_1+t_2,t_1\\cdot t_2 \\\\ 最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots+a_nx_n\\\\ x^m+b_1x^m+\\cdots+b_{m-1}x_1 \\end{array} 就是两个项。\n第二，我们规定，任何一个基本表达式无非就是由两个项所组成的一个等式，比如\n\\begin{array}{l} a_1x_1+a_2x_2+\\cdots a_nx_n=1,\\\\ x_m+\\cdots+b_m=0\\\\ \\end{array} 如果我们还关心诸如实数的线性序（例如 \u003c 就是被用来表达线性序的符号），那么任何一个涉及线性序的基本表达式就是由两个项所组成的不等式。比如\n\\begin{array}{l} a_1x_1+\\cdots+a_nx_n\u003c0,\\\\ b_1m_1+\\cdots+b_2m_2\u003ex_1+\\cdots+x_n\\\\ \\end{array} 不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种基本表达式：项之间的等式、项之间的不等式。以上两种基本表达式我们就分别称之为基本等式和基本不等式。\n第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。\n第四，在前述的基础上，我们来解决基本表达式的真假判定问题。\n给定一个基本表达式，令 t_1(x_1, \\cdots, x_n) 、 t_2(x_1, \\cdots, x_n) 为所涉及的两个项，并且约定，无论是 t_1 还是 t_2 ，在项中出现的所有自变量都出自变量 x_1, \\cdots, x_n 中。那么这 n 个变量就可以彼此独立地在实数范围内取任何值。\n我们规定任何一个实数的 n -元组 (a_1, \\cdots, a_n) 就是上述 n 个变量的一组取值。我们称 (a_1, \\cdots, a_n) 为 x_1, \\cdots, x_n 的一组赋值或者解释。\n并且，我们规定，记号 t_1(a_1, \\cdots, a_2) 和 t_2(a_1, \\cdots, a_2) 分别用来标识由计算过程 t_i (i=1, 2) 以数据 (a_1, \\cdots, a_n) 为输入所计算出来的结果，并且称 t_i 在数据 (a_1, \\cdots, a_n) 处的赋值或者解释。\n在此基础上，我们称数值等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 为基本等式 t_1 = t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n类似的我们称数值不等式\n\\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 为基本不等式 t_1 \u003c t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n现在，我们就规定：\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值不等式 \\begin{array}{l} t_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2) \\end{array} 的确不成立。\n量词与表达式 前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入量词。\n既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。\n比如说考虑基本等式 x = y 和基本不等式 x \u003c y ，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。\n我们将“存在”这个词作为一种量词引入数学，并且用符号 \\exists 来表征“存在”：\n\\begin{array}{l} (\\exists x (\\exists y (x = y))), \\\\ (\\exists x (\\exists y (x \u003c y))) \\end{array} 其中 \\exists x, \\exists y 就都被称为一个存在量词。一个存在量词由符号 \\exists 与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号 () 将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n又比如，考虑基本等式 x + y = y + x 和基本不等式 0 \u003c (x + y)^2 。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。\n我们将“对于所有”这个短语作为一个量词引入，并且用符号 \\forall 来表征这个短语：\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 其中， \\forall x, \\forall y 就都被称为一个全称量词。一个全称量词由符号 \\forall 和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号 () 将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。\n第一，每一个基本表达式都是一个表达式：\n\\begin{array}{l} (t_1 = t_2), \\quad (t_1 \u003c t_2) \\quad (\\text{为了规范起见，我们加上圆括号}) \\end{array} 第二，假设已经得到一个表达式，比如说这个表达式被记作 \\varphi ，那么这个表达式的否定式 (\\neg \\varphi) 也是一个表达式。\n第三，假设已经得到两个表达式，比如说它们被记为 \\varphi 和 \\psi ，那么\n(1) (\\varphi \\lor \\psi) 是一个表达式\n(2) (\\varphi \\land \\psi) 是一个表达式\n(3) (\\varphi \\to \\psi) 是一个表达式\n第四，假设已经得到一个表达式 \\varphi ， x 是一个变量符号，那么\n(1) (\\exists x \\varphi) 是一个表达式\n(2) (\\forall x \\varphi) 是一个表达式\n最后，除了以上的规定，没有获得新的表达式的可能途径。\n关于两个量词的否定，我们规定\n\\begin{array}{l} (\\neg (\\forall x \\varphi)) \\text{ 即为 } (\\exists x (\\neg \\varphi)) \\end{array} 以及\n\\begin{array}{l} (\\neg (\\exists x \\varphi)) \\text{ 即为 } (\\forall x (\\neg \\varphi)) \\end{array} 自由变元与约束变元 关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式 \\varphi 和一个变量符号 x ，假设这个 x 在表达式中出现若干次。\n如果 x 在某一处的出现不在任何存在量词或全称量词的作用范围内，就称 x 为 \\varphi 的一个自由变量。反之，则被称为约束变量。\n在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为语句。比如\n\\begin{array}{l} (\\forall x (\\forall y (x + y = y + x))) \\end{array} 就是一个语句。\n在应用中，我们常常会使用形如下述的受囿量词：\n\\begin{array}{l} \\forall x \\in A, \\quad \\exists x \\in A \\end{array} 这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围 A 之中，并且通常 A 就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如\n\\begin{array}{l} (\\forall x \\in A \\varphi(x)) \\end{array} 这个表达式实际上是\n\\begin{array}{l} \\forall x ((x \\in A) \\to \\varphi(x)) \\end{array} 同样的\n\\begin{array}{l} (\\exists x \\in A \\varphi(x)) \\iff \\exists x ((x \\in A) \\land \\varphi(x)) \\end{array} 更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。\n表达式语义解释与真假判定 仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。\n我们现在设 \\varphi(x_1, x_2, \\cdots, x_n) 是一个表达式，并且 \\varphi 中出现的任何的自由变元都来自 (x_1, x_2, \\cdots, x_n) 中，设 (a_1, a_2, \\cdots, a_n) 是实数的一个 n 元组。我们将 \\varphi 中出现的自由变元 x_i 进行赋值，使得自由变元 x_i 被相应的赋值为 a_i ，这时 \\varphi[a_1, a_2, \\cdots, a_n] 就是对 (a_1, a_2, \\cdots, a_n) 的性质描述，其中没有任何的需要特定赋值的自由变元。\n我们将根据表达式 \\varphi(x_1, x_2, \\cdots, x_n) 构造中可能存在的结构来规定如何判定\n\\varphi[a_1, a_2, \\cdots, a_n] 的真假。\n(1) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是一个基本表达式，那么 \\varphi[a_1, a_2, \\cdots, a_n] 的真假已经在前文被确定好了。\n(2) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是表达式 \\phi(x_1, x_2, \\cdots, x_n) 的否定式，即 \\varphi = (\\neg \\phi) 并且 \\phi[a_1, a_2, \\cdots, a_n] 的真假已经被确定，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为假\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为真\n(3) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是由两个表达式 \\psi_1(x_1, x_2, \\cdots, x_n) 和 \\psi_2(x_1, x_2, \\cdots, x_n) 通过联结词 \\lor 联结而成，即 \\varphi = (\\psi_1 \\lor \\psi_2) ，并且 \\psi_1[a_1, a_2, \\cdots, a_n] 和 \\psi_2[a_1, a_2, \\cdots, a_n] 的真假已经确定，那么\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(4) 把上述推导的联结词换成 \\land ，那么 (a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(5) 如果 \\varphi = (\\psi_1 \\to \\psi_2) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，但是 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(6) 如果 \\varphi = (\\forall y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为假\n(7) 如果 \\varphi = (\\exists y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为假\n当一个表达式在一组数据 (a_1, \\cdots, a_n) 下为真时，我们说这组数据满足表达式。反之则不满足。\n比如，下面这三句话在任何地方都是真语句，只要涉及到等号，下面三个语句就都为真。\n\\begin{array}{l} (\\forall x (x = x)) \\\\ (\\forall x (\\forall y ((x = y) \\to (y = x)))) \\\\ (\\forall x (\\forall y (\\forall z (((x = y) \\land (y = z)) \\to (x = z))))) \\end{array} 这三句话称为基本等号律，也称同一律。\n","cover":null,"tags":["代数学"],"title":"1.1  逻辑基础","url":"/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/"},{"content":"函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。\n若函数 f(t) 变成了另一个函数 f(t)\\longrightarrow \\tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \\delta f 被定义为\n\\delta f(t):=\\tilde{f(t)}-f(t)\\\\ 上式中的变分符号\u0026quot; \\delta \u0026quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \\delta f 是作为另一个函数存在的。\n函数的变分 \\delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变\nf(t)\\xrightarrow{t\\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\\cdots\\\\ 而函数的变分 \\delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关\nf(t)\\rightarrow\\tilde{f(t)}\\equiv(f+\\delta f)(t)=f(t)+\\delta f(t)\\\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如\n\\delta (f^n)=nf^{n-1}\\delta f\\\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有\n\\begin{align} \\delta(af_1+bf_2)=a\\delta f_1+b\\delta f_2\\\\ \\delta(f_1f_2)=(\\delta f_1)f_2+f_1(\\delta f_2) \\end{align}\\\\ 另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“\nd(\\delta f)=\\delta(df)\\\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B' 点的差，即\n\\tilde{f}(t+dt)-f(t)\\\\ 若先微分后变分(路径 A\\rightarrow B\\rightarrow B' ),精确到一阶小量有\n\\begin{align} C'B长度\u0026=f(t+dt)-f(t)=df(t)\\\\ BB'长度\u0026=\\tilde{f}(t+dt)-f(t+dt)\\\\ \u0026=\\delta(f(t+dt))\\\\ \u0026=\\delta(f(t)+df(t))\\\\ \u0026=\\delta(f(t))+\\delta(d(f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=df(t)+\\delta f(t)+\\delta (df(t))\\\\ 若先变分再微分(路径 A\\rightarrow A'\\rightarrow B ),精确到一阶小量有\n\\begin{align} AA'长度\u0026=\\tilde{f}(t)-f(t) \\\\\u0026=\\delta f(t)\\\\ A'C长度\u0026=\\tilde{f}(t+dt)-\\tilde{f}(t)\\\\ \u0026=d\\tilde{f}(t)\\\\ \u0026=d((f+\\delta f)(t))\\\\ \u0026=df(t)+d(\\delta f(t)) \\end{align}\\\\ 于是，\n\\tilde{f}(t+dt)-f(t)=\\delta f(t)+df(t)+d(\\delta f(t))\\\\ 进而有，\nd(\\delta f)=\\delta(df)\\\\ 上式的直接推论即变分和求导运算也可以交换顺序，即是说\u0026quot;导数的变分\u0026quot;=\u0026ldquo;变分的导数\u0026rdquo;.\n\\frac{d}{dt}(\\delta f(t))=\\delta(\\frac{d}{dt}f(t))\\\\ 这里的关键在于，变分变化的是函数本身，而与自变量无关。\n","cover":null,"tags":["经典力学"],"title":"1.2 变分","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.2/"},{"content":"我们首先来回顾一下函数的概念。\n一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：\n函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\\in X 和 y\\in Y 之间建立的一个对应关系即为映射。\nf:x\\rightarrow y=f(x) \\\\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。\n例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。\n上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。\n这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。\n至此，**\u0026ldquo;泛函\u0026rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\\cdots,f_n(x) ，所有这些函数自然也构成集合 \\mathcal{F}=\\{f_1,f_2,\\cdots,f_n\\} ,把函数 f 的泛函记为 s[f] ，即\nS:f\\longmapsto S=S[f],\\quad\\mathcal{F}\\longmapsto \\mathcal{C}\\\\ 其中， \\mathcal{C} 代表复数集合。\n泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。\n1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如\n平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函\nS(曲线长度)=S[f](曲线方程f的泛函)=\\int\\limits_{曲线}dx\\sqrt{1+(f'(x))^2}\\\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函\nW=W[p]=\\int\\limits_{过程}p(V)dV\\\\ 三维空间曲线方程记为 z=\\phi(x,y) ，则曲面面积 A 为二元函数 z=\\phi(x,y) 的泛函\nA=A[\\phi]=\\iint_{\\text {区域 }} \\mathrm{d} x \\mathrm{~d} y \\sqrt{1+\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial \\phi}{\\partial y}\\right)^{2}} \\\\ 经典力学中的遇见的泛函，通常为以下形式\nS[f]=\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right)\\\\ 此处的被积函数 L=L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 是函数 f(t) 及其导数的一般函数。\n可以再次看到，泛函的结果或者说输出 s[f] 是一个数，但是 s[f] 描述的对象是函数的函数，也就是函数所遵循的具体的对应关系，在上式中，它是 f(t) 遵循 \\int\\limits_{t_1}^{t_2} dtL\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 。\n我们称数 s[f] 是 f 的泛函，其实是\u0026quot; s[f] 所描述的函数的函数是函数 f 的泛函\u0026quot;的简洁说法，因为 s[f] 的结果是数，所以简称数 s[f] 是 f 的泛函。\n","cover":null,"tags":["经典力学"],"title":"1.1 泛函","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.1/"},{"content":"1.Markdown 语法 元素 Markdown 语法 标题 (Heading) # H1 ## H2 ### H3 粗体 (Bold) bold text 斜体 (Italic) italicized text 引用块 (Blockquote) \u0026gt; blockquote 有序列表 (Ordered List) 1. First item 2. Second item 3. Third item 无序列表 (Unordered List) - First item - Second item - Third item 代码 (Code) code 分隔线 (Horizontal Rule) \u0026mdash; 链接 (Link) title 一级列表项 1 二级列表项 1.1 三级列表项 1.1.1 二级列表项 1.2 一级列表项 2 元素 Markdown 语法 表格 (Table) | Syntax | Description | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | Header | Title | | Paragraph | Text | 代码块 (Fenced Code Block) \u0026lt;br\u0026gt; { \u0026lt;br\u0026gt; \u0026quot;firstName\u0026quot;: \u0026quot;John\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;lastName\u0026quot;: \u0026quot;Smith\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;age\u0026quot;: 25 \u0026lt;br\u0026gt; } \u0026lt;br\u0026gt; 标题编号 (Heading ID) ### My Great Heading {#custom-id} 定义列表 (Definition List) term : definition 删除线 (Strikethrough) The world is flat. 任务列表 (Task List) - [x] Write the press release - [ ] Update the website - [ ] Contact the media ~ 公理1.1 ~\n公理1.1\n以上内容来自 Markdown 语法官方中文教程\n2.Markdown 语法报错修正 代码块 `` Markdown 代码块中的代码是保存功能而不仅仅只是展示用的，因此，当处于代码块中的代码是关于页面设定的代码，那么，它就会影响网页的生成。\n为了避免这种情况，我们需要采用如下语法来规避影响：\nHTML 标签 在需要显示代码时，可以使用 \u0026lt;code\u0026gt; 或 \u0026lt;pre\u0026gt; 标签来确保代码的正确显示，这些标签不会引起 Markdown 渲染问题。\n例如：\n1 \u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt; 更保险一些可以改写为\n1 \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 其中 pre 标签是 HTML 中的一个标签，用于定义 预格式化文本。它的作用是按照原样保留文本的格式，尤其是 空格、换行和制表符 等白空格字符，不会被浏览器自动压缩或忽略。常用于显示格式化的文本内容，比如代码、日志文件等。\n以及，三个反引号之后的语法声明，例如 三反引号+html 只是使得代码块中的 HTML 语法高亮显示，而不是对其格式化。\n3.LaTex渲染测试 测试项目（1）：行内渲染和展示渲染\nS[x^A(t)]=\\int dtL(x^A(t),\\dot{x}^A(t))\\tag{1.0} d \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over B} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\times \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over r} }}{{{r^3}}} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\sin \\theta }}{{{r^2}}} 结果表明，展示渲染块内无需添加 // 以声明展示居中，这正是我们特地定义展示渲染模式的目的。（事实上，展示渲染加 // 会导致报错）\n根据 layouts/shortcode/latex.html 设定，{{latex}} 默认 display=\u0026ldquo;true\u0026rdquo; 因此展示渲染可以直接使用 {{latex}}{{/latex}}，行内展示则需要定义 display=\u0026ldquo;false\u0026rdquo;。(但是保险起见还是全都加上 dispaly 属性的好，因为有时 api 会因为一些神必原因而为此报错)\n测试结果项目（2）：公式内空格\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots)\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots) S[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\nS[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots) 测试结果项目（3）：公式写法\n\\bigg、\\equiv 等特殊符号都是可用的。 align 环境中不可插入中文，需要使用 \\text{}。 特殊符号也不可携带中文，例如：\\xlongequal{\\text{变分与求导交换顺序}}、_{\\text{全导数}}。因此，我们或者使用全英文，或者对中文使用 \\text{} 转写。 {{latex}} 内可以无需在意符号转义。但是为了避免报错，还是建议当输入 f\u0026rsquo;(x) 这样的符号时，\u0026rsquo; 尽量使用英文冒号键而不是反引号键。 测试项目(2)证明了特殊符号之间的空格不影响渲染结果，但是，需要注意的是，特殊符号和字母之间必须有空格，例如 \\delta L。因为 \\deltaL 这个特殊符号是不存在的。 Markdown 加粗语法可以包裹 LaTeX 代码。 有序列表、无序列表都需要在文本和序号之间加一个空格符。\n4.脚注样式测试 The Einstein field equations (EFE) may be written in the form:1\nwhere G_{\\mu\\nu} is the Einstein tensor, g_{\\mu\\nu} is the metric tensor, T_{\\mu\\nu} is the stress–energy tensor, \\Lambda is the cosmological constant and \\kappa is the Einstein gravitational constant.\nFootnote 1.\n爱因斯坦场方程（EFE）可以写成： G_{\\mu \\nu}+\\Lambda g_{\\mu \\nu}=\\kappa T_{\\mu \\nu} where G_{\\mu\\nu} is the Einstein tensor, g_{\\mu\\nu} is the metric tensor, T_{\\mu\\nu} is the stress–energy tensor, \\Lambda is the cosmological constant and \\kappa is the Einstein gravitational constant.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":null,"title":"测试专用页","url":"/notes/test-page/"},{"content":"1.请给出以下集合的笛卡尔积的几何解释：\n二线段（矩形） 二直线（平面） 直线和圆周（圆柱面） 直线和圆面（圆柱体） 二圆周（圆环面） 圆周和圆面（圆环体） 解答：\n二线段（矩形） 集合： A = [a_1, a_2] ， B = [b_1, b_2] 。 笛卡尔积：\nA \\times B = {(x, y) \\mid x \\in [a_1, a_2], y \\in [b_1, b_2] } 。\n几何解释：\n该笛卡尔积代表了二维平面中的一个矩形区域，其中横坐标范围为 [a_1, a_2] ，纵坐标范围为 [b_1, b_2] 。因此，笛卡尔积构成了一个矩形。\n二直线（平面） 集合： A = \\mathbb{R} ， B = \\mathbb{R} 。 笛卡尔积：\nA \\times B = \\mathbb{R}^2 几何解释：\n二直线的笛卡尔积是二维平面。每个直线可以看作一个一维空间（实数集合 \\mathbb{R} ），而笛卡尔积将其结合形成了一个二维平面 \\mathbb{R}^2 。\n直线和圆周（圆柱面） 集合： A = \\mathbb{R} ， B = S^1 （单位圆周）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times S^1 几何解释：\n直线和圆周的笛卡尔积在三维空间中形成了一个圆柱面。圆周 S^1 提供了一个循环的二维几何结构，直线 \\mathbb{R} 沿该圆周的每个点延伸，因此形成了一个圆柱面。圆柱面每一“层”都是一个圆周。\n当我们将圆周 S^1 中的点用极坐标表示时，通常会使用坐标对 (r,\\theta) ，由于 S^1 形成的圆周是一个单位圆，因此 r=1 。\nA=\\mathbb{R} 表示一条直线（即 x 轴）。 B=S^1 表示单位圆周，圆周上的任意一个点的极坐标表示为 (r,\\theta)=(1,\\theta) 基于以上条件，笛卡尔积 A \\times B = \\mathbb{R} \\times S^1 中的每一个元素就都是形如 (x,(1,\\theta)) 的元素。\n更进一步，如果我们考虑的是三维空间中的直线和圆周的笛卡尔积，则我们需要用笛卡尔坐标系来表示这些点。\n圆周上的点 (r,\\theta)=(1,\\theta) 通过极坐标转换到笛卡尔坐标时，可以得到圆周上一个点的笛卡尔坐标表示：\n(x,y)=(\\cos(\\theta),\\sin(\\theta)) 因此，笛卡尔积中元素点所对应的三维坐标形式即为：\n(x,y,z)=(\\cos(\\theta),\\sin(\\theta),a) 其中 a\\in A 。\n这个结果表明了情况三的笛卡尔积的几何结构：\n直线（z 轴）上的每一个点 a 都对应圆周上的一个点 (\\cos(\\theta),\\sin(\\theta),a) (\\cos(\\theta),\\sin(\\theta),a) 最终构成的集合的几何形式即为 x-y 平面上的单位圆（简单起见，我们可以把圆心与坐标原点重合）。 (x,y,z)=(\\cos(\\theta),\\sin(\\theta),a) 所构成的几何形状自然就是，以 x-y 平面上的单位圆为底，整个 z 轴为高的一个圆柱面。（圆柱面是一个曲面，它由一族平行的直线构成，每条直线都通过一个固定的曲线（通常是圆形）。圆柱面是二维的，没有“内部”部分，它只包含外部的“面”。） 直线和圆面（圆柱体） 集合： A = \\mathbb{R} ， B = \\mathbb{R}^2 （二维圆面，如 x^2 + y^2 = r^2 ）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times \\mathbb{R}^2 几何解释：\n直线和圆面的笛卡尔积生成一个圆柱体。直线 \\mathbb{R} 是圆柱体的轴，而二维圆面 \\mathbb{R}^2 在每个点沿轴方向扩展，形成圆柱体的横截面。\n实际上，基于上一情况的描述，我们容易知道，这个圆周体上的元素的形式为：\n(x,y,z)=(r\\cos(\\theta),r\\sin(\\theta),a) 二圆周（圆环面） 集合： A = S^1 ， B = S^1 。 笛卡尔积：\nA \\times B = S^1 \\times S^1 几何解释：\n两个圆周的笛卡尔积描述了一个圆环面。每个点在这个圆环面上都可以由两个角度来标定，分别属于两个独立的圆周。形象地说，圆环面是两个圆周的组合，类似于圆环的表面。\n在这个情况下，由于笛卡尔积的两个坐标都可以使用极坐标来表示，因此我们可以完全使用极坐标系来描述这个笛卡尔积，那么，该笛卡尔积上的每一个元素的形式即为：\n(r\\theta_1,r\\theta_2)=(\\theta_1,\\theta_2) 让我们来看一些更有趣的事实：\n1. S^1 \\times S^1 的拓扑维度：\nS^1 是一个一维流形，它在拓扑意义上需要一个参数（ |\\theta ）即可描述。因此\nS^1 的维度是 1 维。 S^1 \\times S^1 的维度是 2 维。 从流形的角度，它本质上是一个二维流形（常称为环面或圆环面，torus）。这个二维性与所使用的坐标系无关——它是一个固有性质。无论你用哪种坐标（极坐标、角度坐标或其他），该流形本身的拓扑维度始终是 2。\n2.极坐标描述 vs. 笛卡尔坐标描述：\n在描述 S^1 \\times S^1 时，我们只需要用两组角度来参数化描述：\n(\\theta_1,\\theta_2) 这里用两个角度参数就能完全描述这个流形上的任意一点，因此体现了它的二维本质。\n如果你尝试用“笛卡尔坐标”来描述每个 S^1 ，你可能会写出\nS^1=\\{(x,y)|x^2+y^2=1^2\\} 这里的每一个 S^1 都嵌入到 \\mathbb{R}^2 中，因此 S^1 \\times S^1 被嵌入到 \\mathbb{R}^2 \\times \\mathbb{R}^2=\\mathbb{R}^4 中，在这种表示下，笛卡尔积元素中的一个点 (\\theta_1,\\theta_2) 被映射为：\n(\\cos(\\theta_1),\\sin(\\theta_1),\\cos(\\theta_2),\\sin(\\theta_2))\\in\\mathbb{R}^4 虽然这里用了四个坐标数值来描述这个环面上的一个点，但这并不意味着该流形是四维的。它只意味着当你以这种方式嵌入到 \\mathbb{R}^4 时，这个二维流形占据了一个四维空间中的二维子集。换句话说，它是一个嵌入在四维空间中的二维曲面，就像一条线（1维）可以嵌入到平面（2维）中，而不会改变线本身是一维的事实。坐标系的选择不会改变流形的维数。\n因此，我们在情况3、4中说讨论的笛卡尔积，实际上都是二维流形嵌入三维空间的实例，它们本身仍然是二维的。\n圆周和圆面（圆环体） 集合： A = S^1 ， B = \\mathbb{R}^2 （二维圆面）。 笛卡尔积：\nA \\times B = S^1 \\times \\mathbb{R}^2 几何解释：\n圆周和圆面的笛卡尔积描述了一个圆环体。圆周 S^1 确定了该体的一个边界，而二维圆面 \\mathbb{R}^2 表示内部的自由度。圆环体可以想象为一个在三维空间中的“管状”体，外部表面是由圆周和圆面笛卡尔积形成的。\n有了情况5的讨论，我们很容易就可以看出此笛卡尔积的几何意义，本质上，它是一个三维流形，\n将 S^1 理解为一个“环”（圆周），将 \\mathbb{R}^2 理解为一个无限扩展的平面。那么 S^1 \\times \\mathbb{R}^2 可以看作是在圆周的每一点上，都“附着”了一个与之关联的二维平面。\n换句话说，如果你固定一个 \\theta \\in S^1 ，那么对应的 {\\theta} \\times \\mathbb{R}^2 就是一个平面。随着 \\theta 沿着圆周变化，这些平面在空间中“环绕”一圈，形成了一个三维的几何结构。\n若仅有 S^1 \\times \\mathbb{R} ，我们会得到一个圆柱面（2维流形：圆周 × 直线）。 而当直线 \\mathbb{R} 替换为平面 \\mathbb{R}^2 ，每个圆周点对应的不是一条线，而是一个无限扩展的平面。将这些无数平面按照圆周参数拼接起来，就会得到一个比圆柱面更高维的结构——一个 3维流形，可以形象地称其为“环状分布的无限平面叠加”。\n虽然这个形状很难在我们的三维直观中完全可视化，但从拓扑维度与参数化的角度，它是一个3维的流形，其内部结构由一个环状方向（ S^1 ）和两个线性无界方向（ \\mathbb{R}^2 ）组成。\n1. 什么是流形？\n首先，**流形（manifold）**是一个具有局部欧几里得空间结构的几何对象。对于 二维流形 来说，它在局部看起来就像一个二维平面，即在每个点附近都有一个局部坐标系统（通常是二维坐标）。但全局结构可能更复杂，具有弯曲或扭曲的特性。\n例如，地球表面是一个二维流形，它局部看上去是平面的（如地图上的小区域），但全局却是球形的。\n2. 二维流形嵌入到三维空间\n当我们说一个 二维流形 嵌入到 三维空间 中时，实际上是指流形的每个点都通过一个嵌入函数与三维空间中的一个点一一对应。这个嵌入的意义是，流形可以通过一些连续函数与三维空间的点相对应，使得流形在局部看起来和欧几里得平面一致，但可能具有全局的弯曲或曲率。 常见的二维流形嵌入三维空间的例子：\n圆环（圆周）：圆周是一个二维流形，局部上看起来像平面，但在三维空间中，它形成了一个二维曲面。 球面（如地球表面）：球面是一个二维流形，在三维空间中它表现为一个弯曲的表面。尽管它是二维流形，但它的形状在三维空间中是显而易见的。 环面（如甜甜圈形状）：环面是两个圆周的笛卡尔积( S^1 \\times S^1 )，它是一个二维流形，嵌入三维空间时，表现为一个环状的表面。 3. 流形看上去是否是三维的？\n当二维流形嵌入三维空间时，它 在整体上 不会显现出三维的结构，因为它只有 二维。然而，二维流形的形状和性质可能会因为其弯曲、扭曲等特性而使得它的几何体积在视觉上更为复杂，从而给人一种“近似三维”的感觉。 例如：\n一个 圆柱面 是一个二维流形，在三维空间中表现为一个有曲率的表面，尽管它是二维的，但由于其延伸在三维空间中，它看上去很像三维物体。(实际上，它的对应物体就是一张无限薄的，位于三维空间的，弯曲的矩形纸张。) 球面 是二维流形，但它在三维空间中的嵌入是弯曲的，从几何学上看，它显然是一个弯曲的三维物体，尽管它本质上是二维流形。 因此，二维流形在三维空间中的“外观”并不意味着它变成了三维物体，而是它依然是二维的，但是由于其在空间中是弯曲的，或者有拓扑结构，它会在视觉上显得有一定的复杂性。我们可以通过其 局部坐标系 和 全局形状 来区分它是二维的。\n3. 局部坐标系与全局形态\n我们之前讨论过，局部坐标系 能够描述流形在某一点附近的几何性质，但它无法揭示流形的 全局形态。对于 球面（S²） 或 球体（B³） 这样的物体，局部坐标系只能提供该物体某个小区域的欧几里得性质。\n在球面上的某个小区域，局部坐标系看起来像平面，但这不能描述球面的弯曲结构，尤其是球面的 全局曲率。局部坐标系无法直接揭示球面如何从局部变到整体的弯曲形状。球体的局部坐标系也只能描述球体某一点附近的结构，不能通过局部坐标系统来理解球体的 整体体积 和 三维结构。\n4.三维物体与二维物体的本质区别\n三维物体和二维物体的本质区别，不仅在于维度上的差异，还在于它们的 几何性质 和 拓扑结构。\n4.1 维度差异\n二维物体的每个点都可以用两个参数来描述，例如在平面上的 (x,y) 。在球面上，你可以使用极坐标 (r,\\theta) 来描述每个点。 三维物体每个点需要三个参数来描述，例如在三维空间中的 (x,y,z) 坐标。对于球体，球体的内部点和球面上的点都属于同一个物体，但它们在 维度 上有根本的区别，球体的内部有额外的体积和空间扩展。 4.2 几何性质\n二维物体：只有 两维几何属性（如弯曲度、曲率等）。二维物体通常不能再扩展成其他维度的结构，它只能弯曲或扭曲。\n三维物体：三维物体有 体积、厚度 和 空间，可以有不同的结构和属性，比如 体积的分布、内外结构、容积 等。这些特性使得三维物体与二维物体本质上有很大区别。 4.3 拓扑结构\n二维物体的拓扑：二维物体的拓扑结构决定了它的边界、孔洞等性质。一个球面是 无边界 的，且在全局上是 闭合 的。三维物体的拓扑：三维物体的拓扑结构决定了它的体积、边界和孔洞。一个球体是一个 三维 闭合体，具有 体积 和 内部结构。\n5.球面被嵌入三维空间时，其表面上的点将使用三个坐标参数来描述，为什么这不代表它具有第三个维度属性？\n这个问题实际上与经典力学的约束与自由度的解释是一致的。在数学中，球面 S^2 被视为一个二维流形。这意味着，尽管球面嵌入三维空间，我们仍然认为球面只有二维，因为我们用 两个参数 就能描述球面上的任何一点。\n球面是通过两个参数（比如极坐标系中的 \\theta 和 \\phi 来描述的\nS^2=\\{(x,y,z)\\in\\mathbb{R}^3|x^2+y^2+z^2=r^2\\} 虽然在三维空间中，球面上的每个点都需要三个坐标来表示，但这三个坐标是由 两个自由参数( \\theta 和 \\phi )和一个约束条件( x^2+y^2+z^2=r^2 ) 共同决定的。这些坐标并不增加球面作为流形的维度，而是描述了它的嵌入。\n","cover":null,"tags":["数学分析"],"title":"1.2 集合及其基本运算习题选做","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.1/"},{"content":"1.关于这个网站的用途： 本网站为个人博客网站。主要的用途有三个部分：\n读书笔记的记录。 学习过程中的思考记录 资源的合法分享 由于本人能力不足，无法做到在教材的基础之上进行创新的讲述，因此，读书笔记的内容可能会与原文存在很大重合。 但为了保证对原教材的权益保护。本网站绝不会进行任何的盈利活动，读书笔记的分享也仅出于个人的记录需要和学习的分享需要。 如果您发现网站有任何事实不正确、侵犯版权或任何其他问题，请联系我，我会按照您的要求进行删改。对于任何此类错误，我提前表示歉意。\n2.关于这个网站的目的： 由于一些特殊的原因，我没有在学校进行学习。我所有的学习资源和途径均来自于互联网上秉持着开源精神的伟大的人们。\n为此，我也希望对互联网进行力所能及的微小回馈。我将在这个网站分享我所有的读书笔记，希望我的资料可以帮助到对相关领域同样感兴趣的朋友们。另外，欢迎您通过网站内所提供的任何途径联系我，希望我们之间可能存在的沟通能够为您带来一些帮助。\n3.关于本人的联系方式 您可以通过邮箱和知乎联系我：\nQQ mail: chiaralee953@foxmail.com Zhihu：Chiara Lee 最后，希望您在我的网站玩的愉快。请尽情的享受探索知识的乐趣吧。\nChiara Lee Chiara Lee\n以理性审视世界，凭理想创造世界。\n社交网络\nTwitter ZhiHu @Chiara-Lee Github @Chiara-Lee ","cover":null,"tags":null,"title":"关于","url":"/about/"},{"content":"","cover":null,"tags":null,"title":"友人帐","url":"/friends/"},{"content":"网站建设部分 本网站借助了以下平台的服务，感谢这些平台慷慨的免费计划：\n1.网站框架及部署\nHugo 构建框架 Tailwind CSS 构建网站样式 Netlify 网站部署平台 ChatGPT 修复帮助、问题纠正以及资料查询(哦，等等，这个是付费的) 特别致谢：\nHugo in Action\u0026ndash;by Atishay Jain 该书为本网站建设的参考教材，网站前期的主体架构均来源于书中。在此感谢作者 Atishay Jain 的开源精神。 Atishay Jain 书作者 Github 账号 2.网站图片及文本\n重返未来1999 网站壁纸 Fontawesome 网站图标 重返未来1999 友人帐背景 Georgia 网站字体 [LaTeX] 网站上的 LaTeX 渲染来自\u0026quot;Hugo in Action\u0026quot;中的 api 文件，读者可以在我的 GitHub Calenton 库找到它 以上即为本网站目前引用的所有资料，关于本网站引用的教材资料，将会在 笔记 页进行特殊声明。最后，再次感谢以上资源提供者。\n","cover":null,"tags":null,"title":"引用资料致谢","url":"/reference/"}]