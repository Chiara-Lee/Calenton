<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content='在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。
1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。
数学中的语句按照分支被分为各自分支中的基本语句和复合语句。
具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\cdot7+2\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 < 来表征小于的线性序关系，那么 1+2<2+3 、 5\cdot2<5\cdot3 就都是基础语句。
复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如
\begin{array}{l} ((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\ ((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1))) \end{array} 就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：
\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且) 其中，
1.符号" \neg "用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”
2.符号" \rightarrow "用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”
3.符号" \leftrightarrow "用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思
4.符号" \vee "用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”
5.符号" \wedge "用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”
基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：
\begin{array}{l} 5\cdot7+2\cdot3=41\\ 5\cdot3=11 \end{array} 在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \{0,1\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。'><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>1.1 逻辑基础</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/math/>Math</a></li><li><a href=/notes/physcis/>Physics</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>1.1 逻辑基础</h1><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#111-语句真假判定>1.1.1 语句真假判定</a><ul><li><a href=#基本语句的真假判定>基本语句的真假判定</a></li><li><a href=#复合语句真假判定归结过程>复合语句真假判定归结过程</a></li></ul></li><li><a href=#112-表达式及其语义解释>1.1.2 表达式及其语义解释</a><ul><li><a href=#基本表达式及其语义解释>基本表达式及其语义解释</a></li><li><a href=#量词与表达式>量词与表达式</a></li><li><a href=#自由变元与约束变元>自由变元与约束变元</a></li><li><a href=#表达式语义解释与真假判定>表达式语义解释与真假判定</a></li></ul></li></ul></nav><div class=content-wrapper><div class=content><p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。</p><h2 id=111-语句真假判定>1.1.1 语句真假判定</h2><p>在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。</p><p>数学中的语句按照分支被分为各自分支中的<strong>基本语句</strong>和<strong>复合语句</strong>。</p><p>具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如
<span class=fallback-latex>5\cdot7+2\cdot3=41
</span>就是一个基本语句。如果还涉及到线性序，例如用
<span class=fallback-latex><
</span>来表征小于的线性序关系，那么
<span class=fallback-latex>1+2<2+3
</span>、
<span class=fallback-latex>5\cdot2<5\cdot3
</span>就都是基础语句。</p><p>复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如</p><span class=fallback-latex>\begin{array}{l} ((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\ ((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1))) \end{array}</span><p>就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：</p><span class=fallback-latex>\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且)</span><p>其中，</p><p>1.符号"
<span class=fallback-latex>\neg
</span>"用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”</p><p>2.符号"
<span class=fallback-latex>\rightarrow
</span>"用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”</p><p>3.符号"
<span class=fallback-latex>\leftrightarrow
</span>"用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思</p><p>4.符号"
<span class=fallback-latex>\vee
</span>"用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”</p><p>5.符号"
<span class=fallback-latex>\wedge
</span>"用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”</p><h3 id=基本语句的真假判定>基本语句的真假判定</h3><p>在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：</p><span class=fallback-latex>\begin{array}{l}
5\cdot7+2\cdot3=41\\
5\cdot3=11
\end{array}</span><p>在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域
<span class=fallback-latex>\{0,1\}
</span>上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。
在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。<strong>若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。</strong></p><h3 id=复合语句真假判定归结过程>复合语句真假判定归结过程</h3><p>复合语句的真假判定依赖于复合语句的布尔值计算规则。</p><p>同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。</p><p>我们约定用
<span class=fallback-latex>1
</span>来表示真，用
<span class=fallback-latex>0
</span>来表示假。并且
<span class=fallback-latex>1\ne 0
</span>。复合语句的真假赋值必须遵从以下五条计算等式规则：</p><p>1.否定词计算规则：‘并非’</p><p>如果
<span class=fallback-latex>A
</span>是一个已经被赋值了的较低层次的逻辑命题，那么对于
<span class=fallback-latex>A
</span>的否定式
<span class=fallback-latex>(\neg A)
</span>的赋值必须满足下述<strong>背反等式</strong>的要求：</p><p>对
<span class=fallback-latex>(\neg A)
</span>赋值为
<span class=fallback-latex>1
</span>的充要条件是对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>,对
<span class=fallback-latex>(\neg A)
</span>赋值为
<span class=fallback-latex>0
</span>的充要条件是对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/1.png></p><p>2.蕴含词计算规则：‘如果，那么’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式
<span class=fallback-latex>(A\rightarrow B)
</span>的真值赋值必须满足下述<strong>蕴含等式要求</strong>：对
<span class=fallback-latex>(A\rightarrow B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “(对
<span class=fallback-latex>A
</span>赋值为
<span class=fallback-latex>1
</span>，对
<span class=fallback-latex>B
</span>赋值为
<span class=fallback-latex>0
</span>)”。
<img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/2.png></p><p>在蕴含赋值计算表中，我们将蕴含式
<span class=fallback-latex>(A \to B)
</span>放于最右侧是因为，
<span class=fallback-latex>(A \to B)
</span>命题的层级比
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>都高，对于
<span class=fallback-latex>(A \to B)
</span>的真值的赋值依赖于对
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。</p><p>3.析取词计算规则：‘要么，要么’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的析取式
<span class=fallback-latex>(A \lor B)
</span>的赋值必须满足下述<strong>析取等式要求</strong>：对
<span class=fallback-latex>(A \lor B)
</span>的赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span>，或对
<span class=fallback-latex>B
</span>的赋值为
<span class=fallback-latex>1
</span>）”，对
<span class=fallback-latex>(A \lor B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>，并且对
<span class=fallback-latex>B
</span>的赋值也为
<span class=fallback-latex>0
</span>）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/3.png></p><p>4.合取词计算规则：‘不仅，而且’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么他们的合取式
<span class=fallback-latex>(A \land B)
</span>的赋值必须满足以下<strong>合取等式要求</strong>：对
<span class=fallback-latex>(A \land B)
</span>的赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span>，并且对
<span class=fallback-latex>B
</span>的赋值也为
<span class=fallback-latex>1
</span>）”，对
<span class=fallback-latex>(A \land B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>，或对
<span class=fallback-latex>B
</span>的赋值为
<span class=fallback-latex>0
</span>）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/4.png></p><p>5.对等词计算规则：‘当且仅当’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的对等式
<span class=fallback-latex>(A \leftrightarrow B)
</span>的赋值必须满足以下<strong>对等等式要求</strong>：对
<span class=fallback-latex>(A \leftrightarrow B)
</span>赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>和对
<span class=fallback-latex>B
</span>的赋值是相等的）”，对
<span class=fallback-latex>(A \leftrightarrow B)
</span>赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>和对
<span class=fallback-latex>B
</span>的赋值是不相等的）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/5.png></p><p>从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）</p><span class=fallback-latex>\begin{array}{l}
1. \, A \, \text{与} \, (\neg(\neg A)) \, \text{等价} \\
2. \, (A \to B) \, \text{与} \, ((\neg B) \to (\neg A)) \, \text{等价} \\
3. \, (A \lor B) \, \text{与} \, (B \lor A) \, \text{等价} \\
4. \, (A \land B) \, \text{与} \, (B \land A) \, \text{等价} \\
5. \, (A \leftrightarrow B) \, \text{与} \, (B \leftrightarrow A) \, \text{等价}
\end{array}</span><p>另外两条规律也值得注意：</p><span class=fallback-latex>\begin{array}{l}
6. \, \text{如果} \, (A \to B) \, \text{并且} \, (B \to C), \, \text{则} \, (A \to C) \\
7. \, \text{如果} \, (A \leftrightarrow B) \, \text{并且} \, (B \leftrightarrow C), \, \text{则} \, (A \leftrightarrow C)
\end{array}</span><p>在数学逻辑中，我们实际上可以只要一条基本的推导规则：由
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>(A \to B)
</span>导出
<span class=fallback-latex>B
</span>来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。</p><p>另外还需要注意，人们时常使用
<span class=fallback-latex>\Leftarrow
</span>代替
<span class=fallback-latex>\leftarrow
</span>，
<span class=fallback-latex>\Rightarrow
</span>代替
<span class=fallback-latex>\rightarrow
</span>，
<span class=fallback-latex>\Leftrightarrow
</span>代替
<span class=fallback-latex>\leftrightarrow
</span>。</p><h2 id=112-表达式及其语义解释>1.1.2 表达式及其语义解释</h2><h3 id=基本表达式及其语义解释>基本表达式及其语义解释</h3><p>一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。</p><p>比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：</p><span class=fallback-latex>x+(y+z)=(x+y)+z\\</span><p>当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。</p><p>前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如，
<span class=fallback-latex>x+y=y+x
</span>这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?</p><p>在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为<strong>论域</strong>。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的<strong>结构</strong>就是线性代数的基本对象。</p><p>因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。</p><p>第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如</p><span class=fallback-latex>1，2，3\cdots2024\cdots\\</span><p>为一个<strong>项</strong>。</p><p>任何一个被用来表示任意个体的变量（符号），比如</p><span class=fallback-latex>x,y,z,A,B,C\cdots \\</span><p>也是一个<strong>项</strong>。</p><p>然后，由任意两个已有的项
<span class=fallback-latex>t_1
</span>和
<span class=fallback-latex>t_2
</span>经过加法、乘法运算就可以得到新的项</p><span class=fallback-latex>t_1+t_2,t_1\cdot t_2 \\</span><p>最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如</p><span class=fallback-latex>\begin{array}{l}
a_1x_1+a_2x_2+\cdots+a_nx_n\\
x^m+b_1x^m+\cdots+b_{m-1}x_1
\end{array}</span><p>就是两个项。</p><p>第二，我们规定，任何一个<strong>基本表达式</strong>无非就是由两个项所组成的一个等式，比如</p><span class=fallback-latex>\begin{array}{l}
a_1x_1+a_2x_2+\cdots a_nx_n=1,\\
x_m+\cdots+b_m=0\\
\end{array}</span><p>如果我们还关心诸如实数的线性序（例如
<span class=fallback-latex><
</span>就是被用来表达线性序的符号），那么任何一个涉及<strong>线性序的基本表达式</strong>就是由两个项所组成的不等式。比如</p><span class=fallback-latex>\begin{array}{l} a_1x_1+\cdots+a_nx_n<0,\\ b_1m_1+\cdots+b_2m_2>x_1+\cdots+x_n\\ \end{array}</span><p>不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种<strong>基本表达式</strong>：<strong>项之间的等式、项之间的不等式</strong>。以上两种基本表达式我们就分别称之为基本等式和基本不等式。</p><p>第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。</p><p>第四，在前述的基础上，我们来解决基本表达式的真假判定问题。</p><p>给定一个基本表达式，令
<span class=fallback-latex>t_1(x_1, \cdots, x_n)
</span>、
<span class=fallback-latex>t_2(x_1, \cdots, x_n)
</span>为所涉及的两个项，并且约定，无论是
<span class=fallback-latex>t_1
</span>还是
<span class=fallback-latex>t_2
</span>，在项中出现的所有自变量都出自变量
<span class=fallback-latex>x_1, \cdots, x_n
</span>中。那么这
<span class=fallback-latex>n
</span>个变量就可以彼此独立地在实数范围内取任何值。</p><p>我们规定任何一个实数的
<span class=fallback-latex>n
</span>-元组
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>就是上述
<span class=fallback-latex>n
</span>个变量的一组取值。我们称
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为
<span class=fallback-latex>x_1, \cdots, x_n
</span>的一组<strong>赋值</strong>或者<strong>解释</strong>。</p><p>并且，我们规定，记号
<span class=fallback-latex>t_1(a_1, \cdots, a_2)
</span>和
<span class=fallback-latex>t_2(a_1, \cdots, a_2)
</span>分别用来标识由计算过程
<span class=fallback-latex>t_i (i=1, 2)
</span>以数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为输入所计算出来的结果，并且称
<span class=fallback-latex>t_i
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>赋值</strong>或者<strong>解释</strong>。</p><p>在此基础上，我们称数值等式</p><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>为基本等式
<span class=fallback-latex>t_1 = t_2
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>语义解释</strong>。</p><p>类似的我们称数值不等式</p><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>为基本不等式
<span class=fallback-latex>t_1 < t_2
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>语义解释</strong>。</p><p>现在，我们就规定：</p><ol><li>基本等式
<span class=fallback-latex>t_1 = t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为真，当且仅当数值等式</li></ol><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>的确成立。</p><ol start=2><li>基本等式
<span class=fallback-latex>t_1 = t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为假，当且仅当数值等式</li></ol><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>的确不成立。</p><ol start=3><li>基本不等式
<span class=fallback-latex>t_1 < t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为真，当且仅当数值不等式</li></ol><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>的确成立。</p><ol start=4><li>基本不等式
<span class=fallback-latex>t_1 < t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为假，当且仅当数值不等式</li></ol><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>的确不成立。</p><h3 id=量词与表达式>量词与表达式</h3><p>前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入<strong>量词</strong>。</p><p>既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。</p><p>比如说考虑基本等式
<span class=fallback-latex>x = y
</span>和基本不等式
<span class=fallback-latex>x < y
</span>，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。</p><p>我们将“存在”这个词作为一种量词引入数学，并且用符号
<span class=fallback-latex>\exists
</span>来表征“存在”：</p><span class=fallback-latex>\begin{array}{l} (\exists x (\exists y (x = y))), \\ (\exists x (\exists y (x < y))) \end{array}</span><p>其中
<span class=fallback-latex>\exists x, \exists y
</span>就都被称为一个<strong>存在量词</strong>。一个存在量词由符号
<span class=fallback-latex>\exists
</span>与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号
<span class=fallback-latex>()
</span>将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p><p>又比如，考虑基本等式
<span class=fallback-latex>x + y = y + x
</span>和基本不等式
<span class=fallback-latex>0 < (x + y)^2
</span>。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。</p><p>我们将“对于所有”这个短语作为一个量词引入，并且用符号
<span class=fallback-latex>\forall
</span>来表征这个短语：</p><span class=fallback-latex>\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}</span><p>其中，
<span class=fallback-latex>\forall x, \forall y
</span>就都被称为一个<strong>全称量词</strong>。一个全称量词由符号
<span class=fallback-latex>\forall
</span>和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号
<span class=fallback-latex>()
</span>将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p><p>在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。</p><p>第一，每一个基本表达式都是一个表达式：</p><span class=fallback-latex>\begin{array}{l} (t_1 = t_2), \quad (t_1 < t_2) \quad (\text{为了规范起见，我们加上圆括号}) \end{array}</span><p>第二，假设已经得到一个表达式，比如说这个表达式被记作
<span class=fallback-latex>\varphi
</span>，那么这个表达式的否定式
<span class=fallback-latex>(\neg \varphi)
</span>也是一个表达式。</p><p>第三，假设已经得到两个表达式，比如说它们被记为
<span class=fallback-latex>\varphi
</span>和
<span class=fallback-latex>\psi
</span>，那么</p><p>(1)
<span class=fallback-latex>(\varphi \lor \psi)
</span>是一个表达式<br>(2)
<span class=fallback-latex>(\varphi \land \psi)
</span>是一个表达式<br>(3)
<span class=fallback-latex>(\varphi \to \psi)
</span>是一个表达式</p><p>第四，假设已经得到一个表达式
<span class=fallback-latex>\varphi
</span>，
<span class=fallback-latex>x
</span>是一个变量符号，那么<br>(1)
<span class=fallback-latex>(\exists x \varphi)
</span>是一个表达式<br>(2)
<span class=fallback-latex>(\forall x \varphi)
</span>是一个表达式</p><p>最后，除了以上的规定，没有获得新的表达式的可能途径。</p><p>关于两个量词的否定，我们规定</p><span class=fallback-latex>\begin{array}{l}
(\neg (\forall x \varphi)) \text{ 即为 } (\exists x (\neg \varphi))
\end{array}</span><p>以及</p><span class=fallback-latex>\begin{array}{l}
(\neg (\exists x \varphi)) \text{ 即为 } (\forall x (\neg \varphi))
\end{array}</span><h3 id=自由变元与约束变元>自由变元与约束变元</h3><p>关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式
<span class=fallback-latex>\varphi
</span>和一个变量符号
<span class=fallback-latex>x
</span>，假设这个
<span class=fallback-latex>x
</span>在表达式中出现若干次。</p><p>如果
<span class=fallback-latex>x
</span>在某一处的出现不在任何存在量词或全称量词的作用范围内，就称
<span class=fallback-latex>x
</span>为
<span class=fallback-latex>\varphi
</span>的一个<strong>自由变量</strong>。反之，则被称为<strong>约束变量</strong>。</p><p>在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为<strong>语句</strong>。比如</p><span class=fallback-latex>\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}</span><p>就是一个语句。</p><p>在应用中，我们常常会使用形如下述的<strong>受囿量词</strong>：</p><span class=fallback-latex>\begin{array}{l}
\forall x \in A, \quad \exists x \in A
\end{array}</span><p>这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围
<span class=fallback-latex>A
</span>之中，并且通常
<span class=fallback-latex>A
</span>就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如</p><span class=fallback-latex>\begin{array}{l}
(\forall x \in A \varphi(x))
\end{array}</span><p>这个表达式实际上是</p><span class=fallback-latex>\begin{array}{l}
\forall x ((x \in A) \to \varphi(x))
\end{array}</span><p>同样的</p><span class=fallback-latex>\begin{array}{l}
(\exists x \in A \varphi(x)) \iff \exists x ((x \in A) \land \varphi(x))
\end{array}</span><p>更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。</p><h3 id=表达式语义解释与真假判定>表达式语义解释与真假判定</h3><p>仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。</p><p>我们现在设
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是一个表达式，并且
<span class=fallback-latex>\varphi
</span>中出现的任何的自由变元都来自
<span class=fallback-latex>(x_1, x_2, \cdots, x_n)
</span>中，设
<span class=fallback-latex>(a_1, a_2, \cdots, a_n)
</span>是实数的一个
<span class=fallback-latex>n
</span>元组。我们将
<span class=fallback-latex>\varphi
</span>中出现的自由变元
<span class=fallback-latex>x_i
</span>进行赋值，使得自由变元
<span class=fallback-latex>x_i
</span>被相应的赋值为
<span class=fallback-latex>a_i
</span>，这时
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>就是对
<span class=fallback-latex>(a_1, a_2, \cdots, a_n)
</span>的性质描述，其中没有任何的需要特定赋值的自由变元。</p><p>我们将根据表达式
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>构造中可能存在的结构来规定如何判定</p><span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]</span><p>的真假。</p><p>(1) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是一个基本表达式，那么
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>的真假已经在前文被确定好了。</p><p>(2) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是表达式
<span class=fallback-latex>\phi(x_1, x_2, \cdots, x_n)
</span>的否定式，即
<span class=fallback-latex>\varphi = (\neg \phi)
</span>并且
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>的真假已经被确定，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真当且仅当
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>为假<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假当且仅当
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>为真</p><p>(3) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是由两个表达式
<span class=fallback-latex>\psi_1(x_1, x_2, \cdots, x_n)
</span>和
<span class=fallback-latex>\psi_2(x_1, x_2, \cdots, x_n)
</span>通过联结词
<span class=fallback-latex>\lor
</span>联结而成，即
<span class=fallback-latex>\varphi = (\psi_1 \lor \psi_2)
</span>，并且
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>和
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>的真假已经确定，那么<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，并且
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(4) 把上述推导的联结词换成
<span class=fallback-latex>\land
</span>，那么
 (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，并且
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(5) 如果
<span class=fallback-latex>\varphi = (\psi_1 \to \psi_2)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，但是
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(6) 如果
<span class=fallback-latex>\varphi = (\forall y \psi)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当对每一个实数
<span class=fallback-latex>a
</span>都有
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当存在一个实数
<span class=fallback-latex>a
</span>使得
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(7) 如果
<span class=fallback-latex>\varphi = (\exists y \psi)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当存在一个实数
<span class=fallback-latex>a
</span>使得
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当对每一个实数
<span class=fallback-latex>a
</span>都有
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为假</p><p>当一个表达式在一组数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>下为真时，我们说这组数据满足表达式。反之则不满足。</p><p>比如，下面这三句话在任何地方都是真语句，<strong>只要涉及到等号，下面三个语句就都为真</strong>。</p><span class=fallback-latex>\begin{array}{l}
(\forall x (x = x)) \\
(\forall x (\forall y ((x = y) \to (y = x)))) \\
(\forall x (\forall y (\forall z (((x = y) \land (y = z)) \to (x = z)))))
\end{array}</span><p>这三句话称为<strong>基本等号律</strong>，也称<strong>同一律</strong>。</p></div><aside class=sidebar><div class=card><h2>摘要</h2><p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领 …</p></div><div class=card><h2>阅读时长</h2><p>6 min</p></div><div class=card><h2>总字数</h2><p>≈ 1233</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
代数学</a></p></div></aside></div></div></main><div id=related><h2>Related Pages</h2><ul class=posts><li class=post><a href=https://chiara-lee.netlify.app/notes/physcis/classical-mechnics/gaoxian/1.2/><h2>1.2 变分</h2><article>函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。
若函数 f(t) 变成了另一个函数 f(t)\longrightarrow \tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \delta f 被定义为
\delta f(t):=\tilde{f(t)}-f(t)\\ 上式中的变分符号" \delta "代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \delta f 是作为另一个函数存在的。
函数的变分 \delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变
f(t)\xrightarrow{t\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\cdots\\ 而函数的变分 \delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关
f(t)\rightarrow\tilde{f(t)}\equiv(f+\delta f)(t)=f(t)+\delta f(t)\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如
\delta (f^n)=nf^{n-1}\delta f\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有
\begin{align} \delta(af_1+bf_2)=a\delta f_1+b\delta f_2\\ \delta(f_1f_2)=(\delta f_1)f_2+f_1(\delta f_2) \end{align}\\ 另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“
d(\delta f)=\delta(df)\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B' 点的差，即</article><div>Read More</div></a></li><li class=post><a href=https://chiara-lee.netlify.app/notes/physcis/classical-mechnics/gaoxian/1.1/><h2>1.1 泛函</h2><article>我们首先来回顾一下函数的概念。
一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：
函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\in X 和 y\in Y 之间建立的一个对应关系即为映射。
f:x\rightarrow y=f(x) \\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。
例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。
上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。
这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。
至此，**&ldquo;泛函&rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\cdots,f_n(x) ，所有这些函数自然也构成集合 \mathcal{F}=\{f_1,f_2,\cdots,f_n\} ,把函数 f 的泛函记为 s[f] ，即
S:f\longmapsto S=S[f],\quad\mathcal{F}\longmapsto \mathcal{C}\\ 其中， \mathcal{C} 代表复数集合。
泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。
1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如
平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函
S(曲线长度)=S[f](曲线方程f的泛函)=\int\limits_{曲线}dx\sqrt{1+(f'(x))^2}\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函
W=W[p]=\int\limits_{过程}p(V)dV\\ 三维空间曲线方程记为 z=\phi(x,y) ，则曲面面积 A 为二元函数 z=\phi(x,y) 的泛函
A=A[\phi]=\iint_{\text {区域 }} \mathrm{d} x \mathrm{~d} y \sqrt{1+\left(\frac{\partial \phi}{\partial x}\right)^{2}+\left(\frac{\partial \phi}{\partial y}\right)^{2}} \\ 经典力学中的遇见的泛函，通常为以下形式</article><div>Read More</div></a></li></ul></div><div class=comments data-articleurl=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><footer class=dark><nav><ul><li><a href=/categories>目录</a></li><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>