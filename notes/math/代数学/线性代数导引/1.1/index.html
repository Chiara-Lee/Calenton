<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content='在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。
1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。
数学中的语句按照分支被分为各自分支中的基本语句和复合语句。
具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\cdot7+2\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 < 来表征小于的线性序关系，那么 1+2<2+3 、 5\cdot2<5\cdot3 就都是基础语句。
复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如
\begin{array}{l} ((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\ ((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1))) \end{array} 就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：
\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且) 其中，
1.符号" \neg "用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”
2.符号" \rightarrow "用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”
3.符号" \leftrightarrow "用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思
4.符号" \vee "用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”
5.符号" \wedge "用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”
基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：
\begin{array}{l} 5\cdot7+2\cdot3=41\\ 5\cdot3=11 \end{array} 在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \{0,1\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。'><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>1.1 逻辑基础</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/physcis/>Physics</a></li><li><a href=/notes/math/>Math</a></li><li><a href=/notes/computer-science-and-technology/>Cst</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>1.1 逻辑基础</h1><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#111-语句真假判定>1.1.1 语句真假判定</a><ul><li><a href=#基本语句的真假判定>基本语句的真假判定</a></li><li><a href=#复合语句真假判定归结过程>复合语句真假判定归结过程</a></li></ul></li><li><a href=#112-表达式及其语义解释>1.1.2 表达式及其语义解释</a><ul><li><a href=#基本表达式及其语义解释>基本表达式及其语义解释</a></li><li><a href=#量词与表达式>量词与表达式</a></li><li><a href=#自由变元与约束变元>自由变元与约束变元</a></li><li><a href=#表达式语义解释与真假判定>表达式语义解释与真假判定</a></li></ul></li></ul></nav><div class=content-wrapper><div class=content><p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。</p><h2 id=111-语句真假判定>1.1.1 语句真假判定</h2><p>在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。</p><p>数学中的语句按照分支被分为各自分支中的<strong>基本语句</strong>和<strong>复合语句</strong>。</p><p>具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如
<span class=fallback-latex>5\cdot7+2\cdot3=41
</span>就是一个基本语句。如果还涉及到线性序，例如用
<span class=fallback-latex><
</span>来表征小于的线性序关系，那么
<span class=fallback-latex>1+2<2+3
</span>、
<span class=fallback-latex>5\cdot2<5\cdot3
</span>就都是基础语句。</p><p>复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如</p><span class=fallback-latex>\begin{array}{l} ((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\ ((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\ ((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1))) \end{array}</span><p>就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：</p><span class=fallback-latex>\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且)</span><p>其中，</p><p>1.符号"
<span class=fallback-latex>\neg
</span>"用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”</p><p>2.符号"
<span class=fallback-latex>\rightarrow
</span>"用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”</p><p>3.符号"
<span class=fallback-latex>\leftrightarrow
</span>"用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思</p><p>4.符号"
<span class=fallback-latex>\vee
</span>"用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”</p><p>5.符号"
<span class=fallback-latex>\wedge
</span>"用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”</p><h3 id=基本语句的真假判定>基本语句的真假判定</h3><p>在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：</p><span class=fallback-latex>\begin{array}{l}
5\cdot7+2\cdot3=41\\
5\cdot3=11
\end{array}</span><p>在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域
<span class=fallback-latex>\{0,1\}
</span>上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。
在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。<strong>若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。</strong></p><h3 id=复合语句真假判定归结过程>复合语句真假判定归结过程</h3><p>复合语句的真假判定依赖于复合语句的布尔值计算规则。</p><p>同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。</p><p>我们约定用
<span class=fallback-latex>1
</span>来表示真，用
<span class=fallback-latex>0
</span>来表示假。并且
<span class=fallback-latex>1\ne 0
</span>。复合语句的真假赋值必须遵从以下五条计算等式规则：</p><p>1.否定词计算规则：‘并非’</p><p>如果
<span class=fallback-latex>A
</span>是一个已经被赋值了的较低层次的逻辑命题，那么对于
<span class=fallback-latex>A
</span>的否定式
<span class=fallback-latex>(\neg A)
</span>的赋值必须满足下述<strong>背反等式</strong>的要求：</p><p>对
<span class=fallback-latex>(\neg A)
</span>赋值为
<span class=fallback-latex>1
</span>的充要条件是对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>,对
<span class=fallback-latex>(\neg A)
</span>赋值为
<span class=fallback-latex>0
</span>的充要条件是对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/1.png></p><p>2.蕴含词计算规则：‘如果，那么’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式
<span class=fallback-latex>(A\rightarrow B)
</span>的真值赋值必须满足下述<strong>蕴含等式要求</strong>：对
<span class=fallback-latex>(A\rightarrow B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “(对
<span class=fallback-latex>A
</span>赋值为
<span class=fallback-latex>1
</span>，对
<span class=fallback-latex>B
</span>赋值为
<span class=fallback-latex>0
</span>)”。
<img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/2.png></p><p>在蕴含赋值计算表中，我们将蕴含式
<span class=fallback-latex>(A \to B)
</span>放于最右侧是因为，
<span class=fallback-latex>(A \to B)
</span>命题的层级比
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>都高，对于
<span class=fallback-latex>(A \to B)
</span>的真值的赋值依赖于对
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。</p><p>3.析取词计算规则：‘要么，要么’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的析取式
<span class=fallback-latex>(A \lor B)
</span>的赋值必须满足下述<strong>析取等式要求</strong>：对
<span class=fallback-latex>(A \lor B)
</span>的赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span>，或对
<span class=fallback-latex>B
</span>的赋值为
<span class=fallback-latex>1
</span>）”，对
<span class=fallback-latex>(A \lor B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>，并且对
<span class=fallback-latex>B
</span>的赋值也为
<span class=fallback-latex>0
</span>）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/3.png></p><p>4.合取词计算规则：‘不仅，而且’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么他们的合取式
<span class=fallback-latex>(A \land B)
</span>的赋值必须满足以下<strong>合取等式要求</strong>：对
<span class=fallback-latex>(A \land B)
</span>的赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>1
</span>，并且对
<span class=fallback-latex>B
</span>的赋值也为
<span class=fallback-latex>1
</span>）”，对
<span class=fallback-latex>(A \land B)
</span>的赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（或对
<span class=fallback-latex>A
</span>的赋值为
<span class=fallback-latex>0
</span>，或对
<span class=fallback-latex>B
</span>的赋值为
<span class=fallback-latex>0
</span>）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/4.png></p><p>5.对等词计算规则：‘当且仅当’</p><p>如果
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是已经被赋值了的较低层级的逻辑命题，那么它们的对等式
<span class=fallback-latex>(A \leftrightarrow B)
</span>的赋值必须满足以下<strong>对等等式要求</strong>：对
<span class=fallback-latex>(A \leftrightarrow B)
</span>赋值为
<span class=fallback-latex>1
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>和对
<span class=fallback-latex>B
</span>的赋值是相等的）”，对
<span class=fallback-latex>(A \leftrightarrow B)
</span>赋值为
<span class=fallback-latex>0
</span>的充分必要条件是 “（对
<span class=fallback-latex>A
</span>和对
<span class=fallback-latex>B
</span>的赋值是不相等的）”。</p><p><img src=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/5.png></p><p>从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）</p><span class=fallback-latex>\begin{array}{l}
1. \, A \, \text{与} \, (\neg(\neg A)) \, \text{等价} \\
2. \, (A \to B) \, \text{与} \, ((\neg B) \to (\neg A)) \, \text{等价} \\
3. \, (A \lor B) \, \text{与} \, (B \lor A) \, \text{等价} \\
4. \, (A \land B) \, \text{与} \, (B \land A) \, \text{等价} \\
5. \, (A \leftrightarrow B) \, \text{与} \, (B \leftrightarrow A) \, \text{等价}
\end{array}</span><p>另外两条规律也值得注意：</p><span class=fallback-latex>\begin{array}{l}
6. \, \text{如果} \, (A \to B) \, \text{并且} \, (B \to C), \, \text{则} \, (A \to C) \\
7. \, \text{如果} \, (A \leftrightarrow B) \, \text{并且} \, (B \leftrightarrow C), \, \text{则} \, (A \leftrightarrow C)
\end{array}</span><p>在数学逻辑中，我们实际上可以只要一条基本的推导规则：由
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>(A \to B)
</span>导出
<span class=fallback-latex>B
</span>来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。</p><p>另外还需要注意，人们时常使用
<span class=fallback-latex>\Leftarrow
</span>代替
<span class=fallback-latex>\leftarrow
</span>，
<span class=fallback-latex>\Rightarrow
</span>代替
<span class=fallback-latex>\rightarrow
</span>，
<span class=fallback-latex>\Leftrightarrow
</span>代替
<span class=fallback-latex>\leftrightarrow
</span>。</p><h2 id=112-表达式及其语义解释>1.1.2 表达式及其语义解释</h2><h3 id=基本表达式及其语义解释>基本表达式及其语义解释</h3><p>一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。</p><p>比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：</p><span class=fallback-latex>x+(y+z)=(x+y)+z\\</span><p>当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。</p><p>前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如，
<span class=fallback-latex>x+y=y+x
</span>这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?</p><p>在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为<strong>论域</strong>。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的<strong>结构</strong>就是线性代数的基本对象。</p><p>因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。</p><p>第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如</p><span class=fallback-latex>1，2，3\cdots2024\cdots\\</span><p>为一个<strong>项</strong>。</p><p>任何一个被用来表示任意个体的变量（符号），比如</p><span class=fallback-latex>x,y,z,A,B,C\cdots \\</span><p>也是一个<strong>项</strong>。</p><p>然后，由任意两个已有的项
<span class=fallback-latex>t_1
</span>和
<span class=fallback-latex>t_2
</span>经过加法、乘法运算就可以得到新的项</p><span class=fallback-latex>t_1+t_2,t_1\cdot t_2 \\</span><p>最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如</p><span class=fallback-latex>\begin{array}{l}
a_1x_1+a_2x_2+\cdots+a_nx_n\\
x^m+b_1x^m+\cdots+b_{m-1}x_1
\end{array}</span><p>就是两个项。</p><p>第二，我们规定，任何一个<strong>基本表达式</strong>无非就是由两个项所组成的一个等式，比如</p><span class=fallback-latex>\begin{array}{l}
a_1x_1+a_2x_2+\cdots a_nx_n=1,\\
x_m+\cdots+b_m=0\\
\end{array}</span><p>如果我们还关心诸如实数的线性序（例如
<span class=fallback-latex><
</span>就是被用来表达线性序的符号），那么任何一个涉及<strong>线性序的基本表达式</strong>就是由两个项所组成的不等式。比如</p><span class=fallback-latex>\begin{array}{l} a_1x_1+\cdots+a_nx_n<0,\\ b_1m_1+\cdots+b_2m_2>x_1+\cdots+x_n\\ \end{array}</span><p>不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种<strong>基本表达式</strong>：<strong>项之间的等式、项之间的不等式</strong>。以上两种基本表达式我们就分别称之为基本等式和基本不等式。</p><p>第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。</p><p>第四，在前述的基础上，我们来解决基本表达式的真假判定问题。</p><p>给定一个基本表达式，令
<span class=fallback-latex>t_1(x_1, \cdots, x_n)
</span>、
<span class=fallback-latex>t_2(x_1, \cdots, x_n)
</span>为所涉及的两个项，并且约定，无论是
<span class=fallback-latex>t_1
</span>还是
<span class=fallback-latex>t_2
</span>，在项中出现的所有自变量都出自变量
<span class=fallback-latex>x_1, \cdots, x_n
</span>中。那么这
<span class=fallback-latex>n
</span>个变量就可以彼此独立地在实数范围内取任何值。</p><p>我们规定任何一个实数的
<span class=fallback-latex>n
</span>-元组
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>就是上述
<span class=fallback-latex>n
</span>个变量的一组取值。我们称
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为
<span class=fallback-latex>x_1, \cdots, x_n
</span>的一组<strong>赋值</strong>或者<strong>解释</strong>。</p><p>并且，我们规定，记号
<span class=fallback-latex>t_1(a_1, \cdots, a_2)
</span>和
<span class=fallback-latex>t_2(a_1, \cdots, a_2)
</span>分别用来标识由计算过程
<span class=fallback-latex>t_i (i=1, 2)
</span>以数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为输入所计算出来的结果，并且称
<span class=fallback-latex>t_i
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>赋值</strong>或者<strong>解释</strong>。</p><p>在此基础上，我们称数值等式</p><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>为基本等式
<span class=fallback-latex>t_1 = t_2
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>语义解释</strong>。</p><p>类似的我们称数值不等式</p><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>为基本不等式
<span class=fallback-latex>t_1 < t_2
</span>在数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>处的<strong>语义解释</strong>。</p><p>现在，我们就规定：</p><ol><li>基本等式
<span class=fallback-latex>t_1 = t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为真，当且仅当数值等式</li></ol><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>的确成立。</p><ol start=2><li>基本等式
<span class=fallback-latex>t_1 = t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为假，当且仅当数值等式</li></ol><span class=fallback-latex>\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}</span><p>的确不成立。</p><ol start=3><li>基本不等式
<span class=fallback-latex>t_1 < t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为真，当且仅当数值不等式</li></ol><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>的确成立。</p><ol start=4><li>基本不等式
<span class=fallback-latex>t_1 < t_2
</span>相对于数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>为假，当且仅当数值不等式</li></ol><span class=fallback-latex>\begin{array}{l} t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2) \end{array}</span><p>的确不成立。</p><h3 id=量词与表达式>量词与表达式</h3><p>前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入<strong>量词</strong>。</p><p>既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。</p><p>比如说考虑基本等式
<span class=fallback-latex>x = y
</span>和基本不等式
<span class=fallback-latex>x < y
</span>，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。</p><p>我们将“存在”这个词作为一种量词引入数学，并且用符号
<span class=fallback-latex>\exists
</span>来表征“存在”：</p><span class=fallback-latex>\begin{array}{l} (\exists x (\exists y (x = y))), \\ (\exists x (\exists y (x < y))) \end{array}</span><p>其中
<span class=fallback-latex>\exists x, \exists y
</span>就都被称为一个<strong>存在量词</strong>。一个存在量词由符号
<span class=fallback-latex>\exists
</span>与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号
<span class=fallback-latex>()
</span>将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p><p>又比如，考虑基本等式
<span class=fallback-latex>x + y = y + x
</span>和基本不等式
<span class=fallback-latex>0 < (x + y)^2
</span>。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。</p><p>我们将“对于所有”这个短语作为一个量词引入，并且用符号
<span class=fallback-latex>\forall
</span>来表征这个短语：</p><span class=fallback-latex>\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}</span><p>其中，
<span class=fallback-latex>\forall x, \forall y
</span>就都被称为一个<strong>全称量词</strong>。一个全称量词由符号
<span class=fallback-latex>\forall
</span>和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号
<span class=fallback-latex>()
</span>将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p><p>在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。</p><p>第一，每一个基本表达式都是一个表达式：</p><span class=fallback-latex>\begin{array}{l} (t_1 = t_2), \quad (t_1 < t_2) \quad (\text{为了规范起见，我们加上圆括号}) \end{array}</span><p>第二，假设已经得到一个表达式，比如说这个表达式被记作
<span class=fallback-latex>\varphi
</span>，那么这个表达式的否定式
<span class=fallback-latex>(\neg \varphi)
</span>也是一个表达式。</p><p>第三，假设已经得到两个表达式，比如说它们被记为
<span class=fallback-latex>\varphi
</span>和
<span class=fallback-latex>\psi
</span>，那么</p><p>(1)
<span class=fallback-latex>(\varphi \lor \psi)
</span>是一个表达式<br>(2)
<span class=fallback-latex>(\varphi \land \psi)
</span>是一个表达式<br>(3)
<span class=fallback-latex>(\varphi \to \psi)
</span>是一个表达式</p><p>第四，假设已经得到一个表达式
<span class=fallback-latex>\varphi
</span>，
<span class=fallback-latex>x
</span>是一个变量符号，那么<br>(1)
<span class=fallback-latex>(\exists x \varphi)
</span>是一个表达式<br>(2)
<span class=fallback-latex>(\forall x \varphi)
</span>是一个表达式</p><p>最后，除了以上的规定，没有获得新的表达式的可能途径。</p><p>关于两个量词的否定，我们规定</p><span class=fallback-latex>\begin{array}{l}
(\neg (\forall x \varphi)) \text{ 即为 } (\exists x (\neg \varphi))
\end{array}</span><p>以及</p><span class=fallback-latex>\begin{array}{l}
(\neg (\exists x \varphi)) \text{ 即为 } (\forall x (\neg \varphi))
\end{array}</span><h3 id=自由变元与约束变元>自由变元与约束变元</h3><p>关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式
<span class=fallback-latex>\varphi
</span>和一个变量符号
<span class=fallback-latex>x
</span>，假设这个
<span class=fallback-latex>x
</span>在表达式中出现若干次。</p><p>如果
<span class=fallback-latex>x
</span>在某一处的出现不在任何存在量词或全称量词的作用范围内，就称
<span class=fallback-latex>x
</span>为
<span class=fallback-latex>\varphi
</span>的一个<strong>自由变量</strong>。反之，则被称为<strong>约束变量</strong>。</p><p>在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为<strong>语句</strong>。比如</p><span class=fallback-latex>\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}</span><p>就是一个语句。</p><p>在应用中，我们常常会使用形如下述的<strong>受囿量词</strong>：</p><span class=fallback-latex>\begin{array}{l}
\forall x \in A, \quad \exists x \in A
\end{array}</span><p>这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围
<span class=fallback-latex>A
</span>之中，并且通常
<span class=fallback-latex>A
</span>就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如</p><span class=fallback-latex>\begin{array}{l}
(\forall x \in A \varphi(x))
\end{array}</span><p>这个表达式实际上是</p><span class=fallback-latex>\begin{array}{l}
\forall x ((x \in A) \to \varphi(x))
\end{array}</span><p>同样的</p><span class=fallback-latex>\begin{array}{l}
(\exists x \in A \varphi(x)) \iff \exists x ((x \in A) \land \varphi(x))
\end{array}</span><p>更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。</p><h3 id=表达式语义解释与真假判定>表达式语义解释与真假判定</h3><p>仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。</p><p>我们现在设
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是一个表达式，并且
<span class=fallback-latex>\varphi
</span>中出现的任何的自由变元都来自
<span class=fallback-latex>(x_1, x_2, \cdots, x_n)
</span>中，设
<span class=fallback-latex>(a_1, a_2, \cdots, a_n)
</span>是实数的一个
<span class=fallback-latex>n
</span>元组。我们将
<span class=fallback-latex>\varphi
</span>中出现的自由变元
<span class=fallback-latex>x_i
</span>进行赋值，使得自由变元
<span class=fallback-latex>x_i
</span>被相应的赋值为
<span class=fallback-latex>a_i
</span>，这时
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>就是对
<span class=fallback-latex>(a_1, a_2, \cdots, a_n)
</span>的性质描述，其中没有任何的需要特定赋值的自由变元。</p><p>我们将根据表达式
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>构造中可能存在的结构来规定如何判定</p><span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]</span><p>的真假。</p><p>(1) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是一个基本表达式，那么
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>的真假已经在前文被确定好了。</p><p>(2) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是表达式
<span class=fallback-latex>\phi(x_1, x_2, \cdots, x_n)
</span>的否定式，即
<span class=fallback-latex>\varphi = (\neg \phi)
</span>并且
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>的真假已经被确定，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真当且仅当
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>为假<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假当且仅当
<span class=fallback-latex>\phi[a_1, a_2, \cdots, a_n]
</span>为真</p><p>(3) 如果
<span class=fallback-latex>\varphi(x_1, x_2, \cdots, x_n)
</span>是由两个表达式
<span class=fallback-latex>\psi_1(x_1, x_2, \cdots, x_n)
</span>和
<span class=fallback-latex>\psi_2(x_1, x_2, \cdots, x_n)
</span>通过联结词
<span class=fallback-latex>\lor
</span>联结而成，即
<span class=fallback-latex>\varphi = (\psi_1 \lor \psi_2)
</span>，并且
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>和
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>的真假已经确定，那么<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，并且
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(4) 把上述推导的联结词换成
<span class=fallback-latex>\land
</span>，那么
 (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，并且
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(5) 如果
<span class=fallback-latex>\varphi = (\psi_1 \to \psi_2)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为假，或者
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当
<span class=fallback-latex>\psi_1[a_1, a_2, \cdots, a_n]
</span>为真，但是
<span class=fallback-latex>\psi_2[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(6) 如果
<span class=fallback-latex>\varphi = (\forall y \psi)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当对每一个实数
<span class=fallback-latex>a
</span>都有
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当存在一个实数
<span class=fallback-latex>a
</span>使得
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为假</p><p>(7) 如果
<span class=fallback-latex>\varphi = (\exists y \psi)
</span>，则<br> (a)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为真，当且仅当存在一个实数
<span class=fallback-latex>a
</span>使得
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为真<br> (b)
<span class=fallback-latex>\varphi[a_1, a_2, \cdots, a_n]
</span>为假，当且仅当对每一个实数
<span class=fallback-latex>a
</span>都有
<span class=fallback-latex>\psi[a_1, a_2, \cdots, a_n]
</span>为假</p><p>当一个表达式在一组数据
<span class=fallback-latex>(a_1, \cdots, a_n)
</span>下为真时，我们说这组数据满足表达式。反之则不满足。</p><p>比如，下面这三句话在任何地方都是真语句，<strong>只要涉及到等号，下面三个语句就都为真</strong>。</p><span class=fallback-latex>\begin{array}{l}
(\forall x (x = x)) \\
(\forall x (\forall y ((x = y) \to (y = x)))) \\
(\forall x (\forall y (\forall z (((x = y) \land (y = z)) \to (x = z)))))
\end{array}</span><p>这三句话称为<strong>基本等号律</strong>，也称<strong>同一律</strong>。</p></div><aside class=sidebar><div class=card><h2>摘要</h2><p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领 …</p></div><div class=card><h2>阅读时长</h2><p>6 min</p></div><div class=card><h2>总字数</h2><p>≈ 1233</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
代数学</a></p></div></aside></div></div></main><div id=related><h2>Related Pages</h2><ul class=posts><li class=post><a href=https://chiara-lee.netlify.app/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/2.1/><h2>2.1 位形和时间演化</h2><article>2.1.1 位形 力学研究的基本问题是物理系统的时间演化。具体而言，即是要研究物理系统的“位形”随时间的演化。位形是粒子在空间中的位置这一概念的推广。简单之，**位形（configuration）**即粒子系统中各个粒子的空间位置，或者更一般的物理系统在空间中的形状、分布。
例如，考虑 N 个粒子构成的粒子系，给出 N 个粒子的空间坐标 {x_1, x_2, \dots, x_N} 即给出粒子系的一个位形。又例如，琴弦振动的形状，即是琴弦的位形；鼓面弯曲的形状，即是鼓面的位形。
位形的概念可以推广至连续系统和非机械系统。例如，描述气体扩散，给出空间中每一点气体分子数密度 \rho(x) ，即给出气体的位形。描述热传导，给出空间中每一点的局域温度 T(x) ，即给出温度的位形。描述电磁场，给出空间中每一点的矢量 E(x) ，即给出电场的位形。
2.1.2 位形空间与流形 系统所有可能位形的集合，就构成位形空间（configuration space）。位形空间中的一点，即代表系统的一种可能的位形。
例如，在水平面上运动的粒子，其位形即水平面上的点，其位形空间即水平面；限制在圆环上运动的粒子，其位形即圆环上的点，其位形空间即整个圆环；限制在球面上运动的粒子，其位形即球面上的点，其位形空间就是整个球面。
一般来说，物理系统的位形空间一般都不是平坦的线性空间（矢量空间）。例如，球面是一个二维空间，但显然不是平坦的。但是，球面局部的一个小块，看上去又和二维平面很像。数学上对于这种一般的空间的描述，即所谓流形（manifold）理论。简单之，流形即局部看起来像是平坦空间的东西，但是其一般是弯曲的，往往还是具有很复杂的结构。数学上“空间”一词经常特指线性空间，因此位形流形（configuration manifold）是更确切的称呼，不过本书一般仍然用物理上习惯的“位形空间”一词。
2.1.3 世界线 现在考虑时间演化。随着时间参数 t 的变化，系统在位形空间中连续地由一点（某个位形）移动到另一点，所“扫出”的曲线即位形空间中的轨迹。把“时间”这一维加进来，可以认为“位形空间”和“时间轴”合在一起构成更大的空间。
随着时间的演化，位形空间中的点在这个空间中也扫出一条连续的曲线，有时被称作世界线（world line），如图 2.1 所示。因为某一时刻的位形本身不能唯一决定此前或此后的位形，所以世界线是可以相交的，如图 2.1 中 A 点和 B 点。</article><div>Read More</div></a></li><li class=post><a href=https://chiara-lee.netlify.app/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/2.2/><h2>2.2 广义坐标</h2><article>2.2.1 广义坐标的概念 坐标无非是某种空间的参数化，即只要给定一组数，能够唯一确定空间中的一点，就可以称这组数为“坐标”。例如，通常的 3 维空间中的点粒子，我们可以采用直角坐标 \{x, y, z\} ，柱坐标 \{r, \phi, z\} ，球坐标 \{r, \theta, \phi\} 等来参数化其位置。点粒子在空间中的位置的参数化是普通坐标，而位形是点粒子位置概念的推广，自然而然，对位形空间的参数化即广义坐标（generalized coordinates），其是任何一组能够唯一确定系统某个位形的独立参数。这些概念的推广可以总结如下：
物理系统 s 个独立的广义坐标：
\boxed{\{q^1, \cdots, q^s\} \equiv \{q^a\}, \quad a = 1, 2, \cdots, s} \tag{2.1} 代表位形空间中的一点，即代表系统某个唯一确定的位形。因此，
\text{位形空间的维数} = \text{独立广义坐标的个数}. \tag{2.2} 此处的重点在于，独立广义坐标 的个数即为位形空间的维数。
广义坐标是用于描述系统状态的一组参数。独立的广义坐标指的是相互之间不受约束的那些参数。例如，在一个无约束的粒子系统中，每个粒子的三个位置坐标 (x,y,z) 都是独立的。然而，如果系统中有约束（如两粒子用一根固定长度的杆连接），那么它们的坐标之间会存在关系，使得一些坐标不再独立。
位形空间的维数等于描述系统状态所需的独立广义坐标的个数。这是因为每个独立广义坐标提供一个自由度。如果一个系统有 n 个自由度，就意味着它的位形空间是 n 维的。例如：
一个三维空间中的点粒子，其位形空间是三维（由 x, y, z 描述）。 一个三维刚体（不考虑形变）有 6 个自由度，其位形空间是六维（3 个平移 + 3 个旋转参数）。 我们在知乎上回答的问题 为什么广义坐标个数和自由度不一样? 则是将减少维数的约束类型具体的讨论的出来，但其实归根结底，位形空间的维数和广义坐标的关系就是上面这句简单的
\text{位形空间的维数} = \text{独立广义坐标的个数}. 广义坐标只是位形空间的参数化，所以选择非常任意。原则上，广义坐标的选取有无限多种。广义坐标的量纲不一定是长度量纲，一般也不能三个（或者多个）一组合成一个矢量，这也是位形空间一般不是线性空间的反映。例如，球面不是平坦的线性空间，球面坐标 \{\theta, \phi\} 也不是任何矢量的分量。</article><div>Read More</div></a></li></ul></div><div class=comments data-articleurl=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><script src=/js/footnotes.js></script><footer class=dark><nav><ul><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li><li><a href></a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>