<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content="目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。
具体做法如下：
5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。
定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：
0+m:=m 现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为
(n++)+m:=(n+m)++ 于是， 0+m 就是 m， 1+m 就是 (0++)+m=(0+m)++=m++ ， 2+m 就是 (1++)+m=(1+m)++=(m++)++ ，以此类推。例如：
2+m=(1++)+m=(1+m)++=(m++)++\\ 2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\ 根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>2.2 加法和归纳原理的两个变体</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/computer-science-and-technology/>Cst</a></li><li><a href=/notes/math/>Math</a></li><li><a href=/notes/physcis/>Physics</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>2.2 加法和归纳原理的两个变体</h1><h2>Table of Contents</h2><nav id=TableOfContents></nav><div class=content-wrapper><div class=content><p>目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。</p><p>具体做法如下：</p><p>5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。</p><p><strong>定义 2.2.1 (自然数的加法)</strong> 令 m 为一个自然数，我们定义 m 加 0 为：</p><span class=fallback-latex>0+m:=m</span><p>现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为</p><span class=fallback-latex>(n++)+m:=(n+m)++</span><p>于是，
<span class=fallback-latex>0+m
</span>就是 m，
<span class=fallback-latex>1+m
</span>就是
<span class=fallback-latex>(0++)+m=(0+m)++=m++
</span>，
<span class=fallback-latex>2+m
</span>就是
<span class=fallback-latex>(1++)+m=(1+m)++=(m++)++
</span>，以此类推。例如：</p><span class=fallback-latex>2+m=(1++)+m=(1+m)++=(m++)++\\
2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\</span><p>根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。</p><p>现在，我们将之前一般化的讨论特殊化为，
<span class=fallback-latex>a_n=n+m
</span>和
<span class=fallback-latex>f_n(a_n)=a_n++
</span>的情景。</p><p>注意：我们以上定义的自然数加法是不对称的：
<span class=fallback-latex>3+5
</span>表明将 3 增长了 5 次，而
<span class=fallback-latex>5+3
</span>表明将 5 增加了 3 次。不过，它们生成的值是一样的。更一般，对于任意自然数 m、n。有</p><span class=fallback-latex>m+n=n+m</span><p>均成立。（我们将稍后给出其证明）</p><p><strong>引理 2.2.2</strong> 对任意自然数 n，
<span class=fallback-latex>n+0=n
</span>恒成立。</p><p>注意，我们的定义是
<span class=fallback-latex>0+m:=m
</span>，由于我们尚未证明
<span class=fallback-latex>m+n=n+m
</span>对于任意自然数 n、m 均成立，因此我们不可以直接通过交换律得到
<span class=fallback-latex>n+0=n
</span>。</p><p><strong>证明</strong>:<br>采用归纳法来证明。因为
<span class=fallback-latex>0 + m = m
</span>对任意自然数
<span class=fallback-latex>m
</span>均成立并且
<span class=fallback-latex>0
</span>是一个自然数，所以我们能得到最基本的情况
<span class=fallback-latex>0 + 0 = 0
</span>。</p><p>现在归纳性地假设
<span class=fallback-latex>n + 0 = n
</span>成立。我们希望证明
<span class=fallback-latex>(n++) + 0 = n++
</span>。</p><p>根据加法的定义，
<span class=fallback-latex>(n++) + 0 = (n + 0)++
</span>；<br>又根据
<span class=fallback-latex>n + 0 = n
</span>可以推导出
<span class=fallback-latex>(n + 0)++ = n++
</span>。</p><p>至此整个归纳过程就结束了。
<span class=fallback-latex>\Box</span></p><p><strong>引理 2.2.3</strong> 对任意的自然数
<span class=fallback-latex>n
</span>和
<span class=fallback-latex>m
</span>，有<br><span class=fallback-latex>n + (m++) = (n + m)++</span><br>成立。</p><p>同样，因为目前我们还不知道有
<span class=fallback-latex>a + b = b + a
</span>，所以不能从
<span class=fallback-latex>(n++) + m = (n + m)++
</span>中推导出本结论。</p><p><strong>证明</strong>:<br>将
<span class=fallback-latex>m
</span>设为定值，对
<span class=fallback-latex>n
</span>采用归纳法。首先考虑最基本的情况，
<span class=fallback-latex>n = 0
</span>。此时我们必须证明<br><span class=fallback-latex>0 + (m++) = (0 + m)++</span></p><p>根据加法定义，左侧等于
<span class=fallback-latex>m++
</span>，再次根据加法定义，显然右侧也为
<span class=fallback-latex>m++
</span>，因此等式成立。</p><p>现在归纳性地假定
<span class=fallback-latex>n + (m++) = (n + m)++
</span>成立，那么我们必须证明<br><span class=fallback-latex>(n++) + (m++) = ((n++) + m)++</span><br>根据加法的定义，上式左端等于
<span class=fallback-latex>(n + (m++))++
</span>又由归纳假设可得
<span class=fallback-latex>(n+(m++))++ = ((n + m)++)++
</span>。
类似地，根据加法的定义可得，
<span class=fallback-latex>(n++) + m = (n + m)++
</span>，从而等式的右端也等于
<span class=fallback-latex>((n + m)++)++
</span>。</p><p>因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。
<span class=fallback-latex>\Box</span></p><p>作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到<br><span class=fallback-latex>n++ = n + 1。</span></p><p>因为
<span class=fallback-latex>n+1=n+(0++)=(n+0)++=n++
</span>。</p><p>如之前承诺的，现在，我们来证明
<span class=fallback-latex>a + b = b + a
</span>。</p><p><strong>命题 2.2.4 （加法是可交换的）</strong><br>对任意的自然数
<span class=fallback-latex>n
</span>和
<span class=fallback-latex>m
</span>，有<br><span class=fallback-latex>n + m = m + n</span><br>成立。</p><p><strong>证明</strong>:<br>将
<span class=fallback-latex>m
</span>设为定值，对
<span class=fallback-latex>n
</span>采用归纳法。首先证明当
<span class=fallback-latex>n = 0
</span>时结论成立，也就是说证明
<span class=fallback-latex>0 + m = m + 0
</span>。</p><p>一方面，根据加法的定义可以推出
<span class=fallback-latex>0 + m = m
</span>；<br>另一方面，根据引理 2.2.2 可得
<span class=fallback-latex>m + 0 = m
</span>。<br>于是
<span class=fallback-latex>n = 0
</span>时结论成立。</p><p>现在归纳性地假设
<span class=fallback-latex>n + m = m + n
</span>成立，那么我们要证明<br><span class=fallback-latex>(n++) + m = m + (n++)</span><br>来完成归纳。</p><p>根据加法的定义，
<span class=fallback-latex>(n++) + m = (n + m)++
</span>；<br>根据引理 2.2.3，
<span class=fallback-latex>m + (n++) = (m + n)++
</span>；<br>但由归纳假设
<span class=fallback-latex>n + m = m + n
</span>可知
<span class=fallback-latex>(m + n)++ = (n + m)++
</span>。<br>因此
<span class=fallback-latex>(n++) + m = m + (n++)
</span>，进而归纳过程结束。
<span class=fallback-latex>\Box</span></p><p><strong>命题 2.2.5 （加法是可结合的）</strong><br>对任意三个自然数
<span class=fallback-latex>a
</span>、
<span class=fallback-latex>b
</span>、
<span class=fallback-latex>c
</span>，有<br><span class=fallback-latex>(a + b) + c = a + (b + c)</span><br>成立。</p><p><strong>证明</strong>:<br>固定
<span class=fallback-latex>a, c \in N
</span>, 对
<span class=fallback-latex>b
</span>进行归纳讨论.</p><p><strong>设定当
<span class=fallback-latex>b = 0
</span></strong>:<br><span class=fallback-latex>(a + 0) + c = a + c = a + (c + 0) = a + (0 + c)</span></p><p>现在归纳假设
<span class=fallback-latex>b=n
</span>时命题成立, 需要证明
<span class=fallback-latex>b=n++
</span>时命题成立:<br><span class=fallback-latex>\begin{align}
(a + (n++)) + c &= ((a + n)++) + c \\  
&= c + ((a + n)++) \\
&= (c + a + n)++ \\  
&= ((a + n) + c)++ \\
&= (a + (n + c))++ \\  
&= a + (n + c)++ \\
&= a + ((n++) + c)  
\end{align}  </span></p><p>根据数学归纳法，命题对所有自然数均成立。</p><p>正是因为有了这条结合律，我们可以把
<span class=fallback-latex>a, b, c
</span>的和写成
<span class=fallback-latex>a + b + c
</span>的形式，而无需顾虑它们是按照什么样的次序加起来的。</p><p>下面，我们给出消去律。</p><p><strong>命题 2.2.6 （消去律）</strong><br>令
<span class=fallback-latex>a, b, c
</span>为任意三个自然数并且满足<br><span class=fallback-latex>a + b = a + c,</span><br>那么
<span class=fallback-latex>b = c
</span>成立。</p><p><strong>注意</strong>:<br>由于目前我们还没有给出减法和负数的概念，所以这里不能利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及了一种“虚拟减法”。</p><p><strong>证明</strong>:<br>我们通过对
<span class=fallback-latex>a
</span>进行归纳来证明该命题。<br>首先考虑最基本的情况
<span class=fallback-latex>a = 0
</span>，我们有<br><span class=fallback-latex>0 + b = 0 + c,</span><br>那么根据加法的定义，由
<span class=fallback-latex>0 + b = 0 + c
</span>可以得到
<span class=fallback-latex>b = c
</span>，故命题成立。</p><p>现在归纳性假设关于
<span class=fallback-latex>a
</span>的消去律成立（进而从
<span class=fallback-latex>a + b = a + c
</span>中可以得到
<span class=fallback-latex>b = c
</span>），接下来我们要证明关于
<span class=fallback-latex>a++
</span>的消去律也成立。换言之，就是在假设<br><span class=fallback-latex>(a++) + b = (a++) + c</span><br>成立时，去证明
<span class=fallback-latex>b = c
</span>成立。根据加法的定义，我们有<br><span class=fallback-latex>(a++) + b = (a + b)++</span><br>和<br><span class=fallback-latex>(a++) + c = (a + c)++,</span><br>从而可以得到<br><span class=fallback-latex>(a + b)++ = (a + c)++.</span><br>根据公理 2.4（任意两个不同的自然数的后继也是不同的），我们进一步得到<br><span class=fallback-latex>a + b = a + c.</span><br>显然上式为待证情况的充要条件。因为我们已知关于
<span class=fallback-latex>a
</span>的消去律成立，所以有
<span class=fallback-latex>b = c
</span>成立，结论得证。至此归纳法结束。<br><span class=fallback-latex>\Box</span></p><p>现在我们讨论加法与正性是如何相互作用的。</p><p><strong>定义 2.2.7 （正自然数）</strong>
称一个自然数
<span class=fallback-latex>n
</span>是正的，当且仅当它不等于
<span class=fallback-latex>0
</span>。</p><p><strong>命题 2.2.8</strong>
如果
<span class=fallback-latex>a
</span>是正的并且
<span class=fallback-latex>b
</span>是自然数，那么
<span class=fallback-latex>a + b
</span>是正的（从而根据命题2.2.4可知，
<span class=fallback-latex>b + a
</span>也是正的）。</p><p><strong>证明：</strong>
我们通过对
<span class=fallback-latex>b
</span>进行归纳来证明该命题。如果
<span class=fallback-latex>b = 0
</span>，那么<br><span class=fallback-latex>a + b = a + 0 = a</span><br>显然是正的，从而
<span class=fallback-latex>b = 0
</span>时的结论得证。</p><p>现在归纳性地假设
<span class=fallback-latex>a + b
</span>是正的。那么根据公理 2.3 (0 不是任何自然数的后继)可知，<br><span class=fallback-latex>a + (b++) = (a + b)++</span><br>不等于零，从而
<span class=fallback-latex>a + (b++)
</span>是正的。至此归纳法结束。<br><span class=fallback-latex>\Box</span></p><p><strong>推论 2.2.9</strong><br>如果
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>是自然数并且满足
<span class=fallback-latex>a + b = 0
</span>，那么
<span class=fallback-latex>a = 0
</span>且
<span class=fallback-latex>b = 0
</span>。</p><p><strong>证明</strong>：<br>假设结论的反面
<span class=fallback-latex>a \neq 0
</span>或
<span class=fallback-latex>b \neq 0
</span>成立。如果
<span class=fallback-latex>a \neq 0
</span>，那么
<span class=fallback-latex>a
</span>是正的，从而根据 <strong>命题 2.2.8</strong> 可知，
<span class=fallback-latex>a + b
</span>是正的，这显然与已知条件
<span class=fallback-latex>a + b = 0
</span>相矛盾。类似地，如果
<span class=fallback-latex>b \neq 0
</span>，那么
<span class=fallback-latex>b
</span>是正的，同样根据 <strong>命题 2.2.8</strong> 可知，
<span class=fallback-latex>a + b
</span>是正的，这与
<span class=fallback-latex>a + b = 0
</span>相矛盾。于是
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>必须同时为
<span class=fallback-latex>0
</span>。□</p><p><strong>引理 2.2.10</strong> 令
<span class=fallback-latex>a
</span>表示一个正自然数，那么恰存在一个自然数
<span class=fallback-latex>b
</span>使得
<span class=fallback-latex>b++ = a
</span>。</p><p><strong>证明</strong>：
根据皮亚诺公理 3 （0 不是任何自然数的后继）和 4（不同自然数的后继互不相同）有
<span class=fallback-latex>\forall m, n \in \mathbb{N}, S(m) = S(n) \implies m = n.
</span>则，
<span class=fallback-latex>\begin{align}
&S(b)=a\\
&\forall n \in \mathbb{N},\text{if} S(n)=S(b)=a \implies n = b.
\end{align}
</span>至此命题成立。</p><p><strong>定义 2.2.11 （自然数的序）</strong><br>令
<span class=fallback-latex>n
</span>和
<span class=fallback-latex>m
</span>表示任意两个自然数。我们称
<span class=fallback-latex>n
</span>大于等于
<span class=fallback-latex>m
</span>，并且记作
<span class=fallback-latex>n \geq m
</span>或者
<span class=fallback-latex>m \leq n
</span>，当且仅当存在自然数
<span class=fallback-latex>a
</span>使得
<span class=fallback-latex>n = m + a
</span>。我们称
<span class=fallback-latex>n
</span>大于
<span class=fallback-latex>m
</span>，并且记作
<span class=fallback-latex>n > m
</span>或者
<span class=fallback-latex>m < n
</span>，当且仅当
<span class=fallback-latex>n \geq m
</span>且
<span class=fallback-latex>n \neq m
</span>。</p><p>于是，例如由于
<span class=fallback-latex>8 = 5 + 3
</span>并且
<span class=fallback-latex>8 \neq 5
</span>，所以
<span class=fallback-latex>8 > 5
</span>。另外注意，对任意的
<span class=fallback-latex>n
</span>均有
<span class=fallback-latex>n++ > n
</span>；因此不存在最大的自然数
<span class=fallback-latex>n
</span>，这是因为下一个数
<span class=fallback-latex>n++
</span>总是更大。</p><p><strong>命题 2.2.12 （自然数的序的基本性质）</strong><br>令
<span class=fallback-latex>a, b, c
</span>为任意自然数，那么：<br>(a) （序是自反的）
<span class=fallback-latex>a \geq a
</span>。<br>(b) （序是可传递的）如果
<span class=fallback-latex>a \geq b
</span>并且
<span class=fallback-latex>b \geq c
</span>，那么
<span class=fallback-latex>a \geq c
</span>。<br>(c) （序是反对称的）如果
<span class=fallback-latex>a \geq b
</span>并且
<span class=fallback-latex>b \geq a
</span>，那么
<span class=fallback-latex>a = b
</span>。
(d) （加法保持序不变）
<span class=fallback-latex>a \geq b
</span>，当且仅当
<span class=fallback-latex>a + c \geq b + c
</span>。<br>(e)
<span class=fallback-latex>a < b
</span>，当且仅当
<span class=fallback-latex>a++ \leq b
</span>。<br>(f)
<span class=fallback-latex>a < b
</span>，当且仅当存在正自然数
<span class=fallback-latex>d
</span>使得
<span class=fallback-latex>b = a + d
</span>。</p><p><strong>证明</strong>:</p><p><strong>(a)</strong>
<span class=fallback-latex>a \geq a
</span><span class=fallback-latex>a + 0 = a \rightarrow a \geq a</span></p><p><strong>(b)</strong>
<span class=fallback-latex>a \geq b,b \geq c
</span>，那么
<span class=fallback-latex>a \geq c
</span><span class=fallback-latex>\begin{align}
a \geq b \rightarrow a = b + n, n \in \mathbb{N}\\
b \geq c \rightarrow b = c + m, m \in \mathbb{N}\\
\end{align}
</span>因此，
<span class=fallback-latex>a = b + n = c + m + n
</span>显然就可得结论，
<span class=fallback-latex>a \geq c</span></p><p><strong>(c)</strong>
<span class=fallback-latex>a \geq b，b \geq a
</span>，则
<span class=fallback-latex>a = b
</span><span class=fallback-latex>\begin{align}
a \geq b \rightarrow a = b + n, n \in \mathbb{N}\\
b \geq a \rightarrow b = a + m, m \in \mathbb{N}\\
\end{align}
</span>即
<span class=fallback-latex>a = a + m + n
</span>显然，
<span class=fallback-latex>m = 0，n = 0
</span>，则
<span class=fallback-latex>a = b
</span>。</p><p><strong>(d)</strong>
<span class=fallback-latex>a \geq b
</span>if and only if
<span class=fallback-latex>a + c \geq b + c
</span>.
<span class=fallback-latex>\begin{align}
(a \geq b) &\iff a = b + m, \, m \in \mathbb{N} \\
&\iff a + c = b + m + c = b + c + m, \, m \in \mathbb{N} \\
&\iff a + c \geq b + c.
\end{align}</span></p><p><strong>(e)</strong>
<span class=fallback-latex>a < b
</span>if and only if
<span class=fallback-latex>a++ \leq b
</span>.</p><p>We have</p><span class=fallback-latex>\begin{align} (a < b) &\iff ((a \leq b) \land (a \neq b)) \\ &\iff ((a + m = b, \, m \in \mathbb{N}) \land (a \neq b)) \\ &\iff m \neq 0 \\ &\iff \exists n \in \mathbb{N}, \, n++ = m \\ &\iff a + (n++) = b, \, n \in \mathbb{N} \\ &\iff (a++) + n = b, \, n \in \mathbb{N} (引理 2.2.3)\\ &\iff a++ \leq b. \end{align} 
   </span><p><strong>(f)</strong>
<span class=fallback-latex>a < b
</span>if and only if
<span class=fallback-latex>b = a + d
</span>for some positive number
<span class=fallback-latex>d
</span>.</p><p>We have</p><span class=fallback-latex>\begin{align} (a < b) &\iff ((a \leq b) \land (a \neq b)) \\ &\iff (a + d = b, \, d \in \mathbb{N}) \land (d \neq 0) \\ &\iff a + d = b, \, d \text{ is positive.} \end{align}</span><p><strong>命题 2.2.13 （自然数的序的三歧性）</strong><br>令
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>表示任意两个自然数，那么在下面三种表述中恰有一种表述为真：
<span class=fallback-latex>a < b
</span>，
<span class=fallback-latex>a = b
</span>，
<span class=fallback-latex>a > b
</span>。</p><p><strong>证明</strong>：</p><p>首先我们证明
<span class=fallback-latex>a < b
</span>，
<span class=fallback-latex>a = b
</span>以及
<span class=fallback-latex>a > b
</span>这三种表述中同时为真的表述个数不超过一个。如果
<span class=fallback-latex>a < b
</span>，那么根据定义可知
<span class=fallback-latex>a \neq b
</span>；同样，如果
<span class=fallback-latex>a > b
</span>，根据定义可知
<span class=fallback-latex>a \neq b
</span>。如果
<span class=fallback-latex>a > b
</span>并且
<span class=fallback-latex>a < b
</span>，那么根据命题 2.2.12 可知
<span class=fallback-latex>a = b
</span>，这显然与
<span class=fallback-latex>a \neq b
</span>相矛盾。因此同时为真的表述个数不超过一个。</p><p>现在我们证明至少有一个表述为真。</p><p>保持
<span class=fallback-latex>b
</span>固定不变，对
<span class=fallback-latex>a
</span>进行归纳。当
<span class=fallback-latex>a = 0
</span>时，对所有的
<span class=fallback-latex>b
</span>均有
<span class=fallback-latex>0 \leq b
</span>（为什么？）因此我们得到
<span class=fallback-latex>0 = b
</span>或者
<span class=fallback-latex>0 < b
</span>，从而
<span class=fallback-latex>a = 0
</span>时的结论得证。</p><p>现在归纳性地假设关于
<span class=fallback-latex>a
</span>的命题已经被证明是成立的，下面我们要证明
<span class=fallback-latex>a++
</span>也同样成立。</p><p>从关于
<span class=fallback-latex>a
</span>的三歧性中可知，存在三种可能的情况：
<span class=fallback-latex>a < b
</span>，
<span class=fallback-latex>a = b
</span>以及
<span class=fallback-latex>a > b
</span>。如果
<span class=fallback-latex>a > b
</span>，那么有
<span class=fallback-latex>a++ > b
</span>。（为什么？）如果
<span class=fallback-latex>a = b
</span>，那么
<span class=fallback-latex>a++ > b
</span>。（为什么？）现在假设
<span class=fallback-latex>a < b
</span>，那么根据命题 2.2.12 可知
<span class=fallback-latex>a++ \leq b
</span>。于是我们得到要么
<span class=fallback-latex>a++ = b
</span>，要么
<span class=fallback-latex>a++ < b
</span>，其中任何一种情况都符合我们的要求。至此归纳法结束。</p><p><strong>Why 1:</strong> When
<span class=fallback-latex>a = 0
</span>, we have
<span class=fallback-latex>0 \leq b
</span>for all
<span class=fallback-latex>b
</span>.</p><span class=fallback-latex>(0 + b = b, b \in \mathbb{N}) \Rightarrow (0 \leq b, b \in \mathbb{N})</span><hr><p><strong>Why 2:</strong> If
<span class=fallback-latex>a > b
</span>, then
<span class=fallback-latex>a++ > b
</span>.</p><span class=fallback-latex>(a > b) \Rightarrow (a = b + m, m \in \mathbb{N}) \land (a \neq b) \\ \Rightarrow a++ = b + (m++) \Rightarrow a++ > b</span><hr><p><strong>Why 3:</strong> If
<span class=fallback-latex>a = b
</span>, then
<span class=fallback-latex>a++ > b
</span>.</p><span class=fallback-latex>(a = b) \Rightarrow a++ = b++ = (b + 0)++ = b + (0++) = b + 1 \\ \Rightarrow a++ > b</span><p><strong>命题 2.2.14 （强归纳法原理）</strong><br>令
<span class=fallback-latex>m_0
</span>表示一个自然数，
<span class=fallback-latex>P(m)
</span>表示与任意自然数
<span class=fallback-latex>m
</span>有关的性质。假设对任意满足
<span class=fallback-latex>m \geq m_0
</span>的自然数
<span class=fallback-latex>m
</span>，均有如下内容成立：若
<span class=fallback-latex>P(m')
</span>对任意满足
<span class=fallback-latex>m_0 \leq m' < m
</span>的自然数
<span class=fallback-latex>m'
</span>均为真，那么
<span class=fallback-latex>P(m)
</span>也为真。（特别地，这意味着
<span class=fallback-latex>P(m_0)
</span>为真，因为当
<span class=fallback-latex>m = m_0
</span>时，前提中的
<span class=fallback-latex>m'
</span>取值范围为空。）于是我们能够断定，对于任意满足
<span class=fallback-latex>m \geq m_0
</span>的自然数
<span class=fallback-latex>m
</span>，
<span class=fallback-latex>P(m)
</span>为真。</p><hr><p><strong>注 2.2.15</strong> 在应用强归纳法原理的时候，我们通常令
<span class=fallback-latex>m_0 = 0
</span>或者
<span class=fallback-latex>m_0 = 1
</span>。</p><p><strong>证明：</strong>
设
<span class=fallback-latex>P(m)
</span>是一个与自然数
<span class=fallback-latex>m
</span>相关的命题。如果满足以下条件：</p><ol><li><strong>基础情况</strong>：当
<span class=fallback-latex>m = m_0
</span>时，
<span class=fallback-latex>P(m_0)
</span>为真。</li><li><strong>归纳假设</strong>：对于任意
<span class=fallback-latex>m > m_0
</span>，如果
<span class=fallback-latex>P(m')
</span>对所有
<span class=fallback-latex>m_0 \leq m' < m
</span>都成立，则
<span class=fallback-latex>P(m)
</span>也为真。</li></ol><p>则结论是：
<span class=fallback-latex>P(m)
</span>对所有
<span class=fallback-latex>m \geq m_0
</span>成立。</p><p><strong>证明过程</strong></p><p><strong>1. 用普通归纳法重新定义问题</strong></p><p>设
<span class=fallback-latex>Q(n)
</span>表示如下命题：</p><blockquote><p>对于所有
<span class=fallback-latex>m
</span>满足
<span class=fallback-latex>m_0 \leq m < m_0 + n
</span>，命题
<span class=fallback-latex>P(m)
</span>都为真。</p></blockquote><p>我们的目标是证明：对于所有正整数
<span class=fallback-latex>n
</span>，
<span class=fallback-latex>Q(n)
</span>成立。这等价于强归纳原理，因为
<span class=fallback-latex>Q(n)
</span>的结论覆盖了
<span class=fallback-latex>P(m)
</span>在
<span class=fallback-latex>m \geq m_0
</span>的所有情况。</p><p><strong>2. 验证基础情况</strong></p><p>当
<span class=fallback-latex>n = 1
</span>时，
<span class=fallback-latex>Q(1)
</span>的含义是：对于所有
<span class=fallback-latex>m
</span>满足
<span class=fallback-latex>m_0 \leq m < m_0 + 1
</span>，
<span class=fallback-latex>P(m)
</span>为真。</p><p>因为能满足
<span class=fallback-latex>m_0 \leq m < m_0 + 1
</span>的自然数
<span class=fallback-latex>m
</span>只有
<span class=fallback-latex>m_0
</span>，因此此情况下性质仅涉及
<span class=fallback-latex>P(m_0)
</span>，而强归纳原理假设，
<span class=fallback-latex>P(m_0)
</span>为真，因此
<span class=fallback-latex>Q(1)
</span>为真。</p><p><strong>3. 验证归纳步骤</strong></p><p>假设
<span class=fallback-latex>Q(n)
</span>为真，即：<br>对于所有
<span class=fallback-latex>m
</span>满足
<span class=fallback-latex>m_0 \leq m < m_0 + n
</span>，
<span class=fallback-latex>P(m)
</span>为真。</p><p>需要证明
<span class=fallback-latex>Q(n+1)
</span>为真，即：<br>对于所有
<span class=fallback-latex>m
</span>满足
<span class=fallback-latex>m_0 \leq m < m_0 + n + 1
</span>，
<span class=fallback-latex>P(m)
</span>为真。</p><p>根据
<span class=fallback-latex>Q(n)
</span>，我们已经知道：</p><ul><li><span class=fallback-latex>P(m')
</span>对于所有
<span class=fallback-latex>m_0 \leq m' < m_0 + n
</span>都成立。</li></ul><p>我们现在需要证明
<span class=fallback-latex>P(m_0 + n)
</span>为真。这与基础情况的逻辑是相同的。</p><p>因为
<span class=fallback-latex>Q(n+1)
</span>的定义是
<span class=fallback-latex>Q(n+1) := \forall m(m_0 < m < m_0 + n + 1 \rightarrow P(m) \text{为真})</span></p><p>根据归纳假设，
<span class=fallback-latex>Q(n)
</span>为真，即
<span class=fallback-latex>P(m) \text{对于所有的} m_0 \le m < m_0 + n \text{都为真}</span></p><p>所以我们有待验证的范围还剩下
<span class=fallback-latex>m_0 + n \le m < m_0 + n + 1</span></p><p>而满足上述范围的自然数
<span class=fallback-latex>m
</span>只有
<span class=fallback-latex>m_0 + n
</span>。</p><p>综上，我们只需要证明
<span class=fallback-latex>P(m_0 + n)
</span>为真，即可得到
<span class=fallback-latex>Q(n+1)
</span>为真。</p><p>根据强归纳原理假设，若
<span class=fallback-latex>P(m')
</span>对所有
<span class=fallback-latex>m_0 \leq m' < m
</span>都成立，则
<span class=fallback-latex>P(m)
</span>为真。<br>将
<span class=fallback-latex>m = m_0 + n
</span>代入，这里
<span class=fallback-latex>P(m')
</span>对所有
<span class=fallback-latex>m_0 \leq m' < m_0 + n
</span>已经成立（由归纳假设
<span class=fallback-latex>Q(n)
</span>），因此
<span class=fallback-latex>P(m_0 + n)
</span>为真。</p><p>结合归纳假设，我们得出
<span class=fallback-latex>Q(n+1)
</span>为真。</p><p><strong>4. 归纳完成</strong></p><p>通过普通数学归纳法，我们证明了
<span class=fallback-latex>Q(n)
</span>对所有正整数
<span class=fallback-latex>n
</span>都成立。这意味着：</p><ul><li>对于所有
<span class=fallback-latex>m \geq m_0
</span>，
<span class=fallback-latex>P(m)
</span>为真。</li></ul><p><strong>逆向归纳法原理</strong></p><p>令
<span class=fallback-latex>n
</span>表示一个自然数，
<span class=fallback-latex>P(m)
</span>是关于自然数的一个性质并且满足：只要
<span class=fallback-latex>P(m++)
</span>为真，
<span class=fallback-latex>P(m)
</span>就为真。假设
<span class=fallback-latex>P(n)
</span>也为真，证明：
<span class=fallback-latex>P(m)
</span>对任意满足
<span class=fallback-latex>m \leq n
</span>的自然数
<span class=fallback-latex>m
</span>均为真；这被称为<strong>逆向归纳法原理</strong>。（提示：对变量
<span class=fallback-latex>n
</span>使用归纳法。）</p><p><strong>证明：</strong>
Induction on
<span class=fallback-latex>n
</span>, let
<span class=fallback-latex>Q(n)
</span>represent:<br><span class=fallback-latex>Q(n) := \{ P(m) \text{ is true, } \forall m \leq n \}</span></p><p><strong>Case 0</strong>:
<span class=fallback-latex>Q(0)
</span>is true.</p><p>If
<span class=fallback-latex>Q(k)
</span>is true, then consider
<span class=fallback-latex>Q(k++)
</span>:<br><span class=fallback-latex>Q(k++) = \{ P(m) \text{ is true, } \forall m \leq k++ \}
</span>,<br>as
<span class=fallback-latex>P(k++)
</span>is true. Hence,
<span class=fallback-latex>Q(k++)
</span>is true.</p><p>The induction is valid.</p></div><aside class=sidebar><div class=card><h2>摘要</h2><p>目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。
具体做法如下：
5 加上 3 与对 5 进行 3 次增量运算的结果是一 …</p></div><div class=card><h2>阅读时长</h2><p>10 min</p></div><div class=card><h2>总字数</h2><p>≈ 1975</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
数学分析</a></p></div></aside></div></div></main><div id=related><h2>Related Pages</h2><ul class=posts><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/><h2>2.1 皮亚诺公理</h2><article>在学习实数分析之前，我们首先要回溯数的概念以及数的性质。
我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?
实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。
现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。
自然数集定义 定义 2.1.1 （非正式的）自然数是集合
N := \{ 0, 1, 2, 3, \cdots \} 的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。
注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \{1, 2, 3, \cdots \} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。
从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：
N 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？
我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？
我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：
a^3 = a \cdot a \cdot a 。
乘法运算只不过是对加法运算的重复迭代：
3 \cdot a = a + a + a 。</article><div>Read More</div></a></li><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E8%B0%A2%E6%83%A0%E6%B0%91%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.1/><h2>1.1 符号约定</h2><article>凡教材中所用数字，若未加说明，则默认为实数。
对于实数，教材采用的理解即为“可以用十进有尽小数和无尽小数表示的数。”
\mathbb{N}_+ ：所有正整数所组成的集合。 \mathbb{R} ：所有实数组成的集合（同时也用于表示无限区间 (-\infty,+\infty) ）。 \mathbb{Q} ：所有有理数组成的集合。 \mathbb{C} ：所有复数组成的集合。 [x] 表示实数 x 的整数部分，即不超过 x 的最大整数。例如 [\sqrt{2}]=1,[-\sqrt{2}]=-2 关于 [x] 的基本不等式是：
[x]\le x <[x]+1 x-1 < [x]\le x \square 表示一个证明或解的结束。 \binom{n}{k}=C^k_n=\frac{n(n-1)\cdots(n-l+1)}{k!} 若 A 和 B 为两集合，则使用记号 A-B 或者 A \ B 表示 A 与 B 的差集。其也就是集合 A \ B={x | x\in A\vee x\notin B} 。 用 O_{\delta}(a)\, U_{\delta}(a) 表示以 a 为中心，以 \delta > 0 为半径的邻域。它就是开区间 (a-\delta ,a+\delta) 。如不必指出半径，则可简写为 O(a)\, U(a)</article><div>Read More</div></a></li></ul></div><div class=comments data-articleurl=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><footer class=dark><nav><ul><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li><li><a href></a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>