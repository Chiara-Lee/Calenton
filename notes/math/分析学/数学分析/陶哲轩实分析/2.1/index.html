<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content="1.摘要 本文公理一览：
公理 3.1（集合是对象） 相等公理、替换公理 公理 3.2 (空集) 公理 3.3（单元素集与双元素集） 公理 3.4（两集合并集） 公理 3.5（分类公理） 公理 3.6 (替代) 公理 3.7 (无穷大) 2.正文 定义 3.1.1（非正式的）（集合）
我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \{3,8,5,2\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\in A ，否则，记作 x\notin A 。
这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。
首先阐明一个观点：我们把集合本身看作一类对象。
公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。
到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \in A 是无定义的。例如， 3 \in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。）"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>3.1 基础知识</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/physcis/>Physics</a></li><li><a href=/notes/math/>Math</a></li><li><a href=/notes/computer-science-and-technology/>Cst</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>3.1 基础知识</h1><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#1摘要>1.摘要</a></li><li><a href=#2正文>2.正文</a></li><li><a href=#3习题>3.习题</a></li></ul></nav><div class=content-wrapper><div class=content><h2 id=1摘要>1.摘要</h2><p>本文公理一览：</p><ul><li>公理 3.1（集合是对象）</li><li>相等公理、替换公理</li><li>公理 3.2 (空集)</li><li>公理 3.3（单元素集与双元素集）</li><li>公理 3.4（两集合并集）</li><li>公理 3.5（分类公理）</li><li>公理 3.6 (替代)</li><li>公理 3.7 (无穷大)</li></ul><h2 id=2正文>2.正文</h2><p><strong>定义 3.1.1（非正式的）</strong>（集合）</p><p>我们把 <strong>集合 A</strong> 定义为任意的一堆没有次序的对象。例如，
<span class=fallback-latex>\{3,8,5,2\}
</span>是一个集合。如果
<span class=fallback-latex>x
</span>是这堆对象中的一个，那么我们称 <strong><span class=fallback-latex>x
</span>是
<span class=fallback-latex>A
</span>中的一个元素</strong> ，记作
<span class=fallback-latex>x\in A
</span>，否则，记作
<span class=fallback-latex>x\notin A
</span>。</p><p>这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。</p><p>首先阐明一个观点：我们把集合本身看作一类对象。</p><p><strong>公理 3.1（集合是对象）</strong> 如果
<span class=fallback-latex>A
</span>是一个集合，那么
<span class=fallback-latex>A
</span>也是一个对象。特别地，给定两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>，问
<span class=fallback-latex>A
</span>是不是
<span class=fallback-latex>B
</span>中的元素是有意义的。</p><p>到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果
<span class=fallback-latex>x
</span>是一个对象，
<span class=fallback-latex>A
</span>是一个集合，那么
<span class=fallback-latex>x \in A
</span>要么为真，要么为假。（如果
<span class=fallback-latex>A
</span>不是集合，则我们认为
<span class=fallback-latex>x \in A
</span>是无定义的。例如，
<span class=fallback-latex>3 \in 4
</span>既非真也非假，该命题是无意义的，因为
<span class=fallback-latex>4
</span>不是一个集合。）</p><p>接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{2, 3, 5, 8\}
</span>看作同一个集合。另外，
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{3, 8, 5, 2, 1\}
</span>是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素
<span class=fallback-latex>1
</span>。基于类似的原因，
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{3, 8, 5\}
</span>也是不同的集合。我们把这部分内容作为一个定义。</p><p><strong>定义 3.1.4（集合的相等）</strong> 称两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是相等的，即
<span class=fallback-latex>A = B
</span>，当且仅当
<span class=fallback-latex>A
</span>中的每个元素都是
<span class=fallback-latex>B
</span>中的元素并且
<span class=fallback-latex>B
</span>中的每一个元素也都是
<span class=fallback-latex>A
</span>中的元素。也就是说，
<span class=fallback-latex>A = B
</span>，当且仅当
<span class=fallback-latex>A
</span>中的任一元素
<span class=fallback-latex>x
</span>属于
<span class=fallback-latex>B
</span>，同时
<span class=fallback-latex>B
</span>中的任一元素
<span class=fallback-latex>y
</span>也属于
<span class=fallback-latex>A
</span>，这记为
<span class=fallback-latex>(\forall x \in A, x \in B),(\forall y \in B, y \in A)</span></p><p>相等是如何定义的取决于所考察对象的类型，而且从某种程度上来说，这只不过是一个关于下定义的问题而已。然而，从逻辑学的角度来说，我们要求相等遵守下面四条 <strong>相等公理</strong> ：</p><ul><li><strong>（自反公理）</strong> 给定任意的对象
<span class=fallback-latex>x
</span>，我们有
<span class=fallback-latex>x = x
</span>。</li><li><strong>（对称公理）</strong> 给定任意两个同类型的对象
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>y
</span>，如果
<span class=fallback-latex>x = y
</span>，那么
<span class=fallback-latex>y = x
</span>。</li><li><strong>（传递公理）</strong> 给定任意三个同类型的对象
<span class=fallback-latex>x
</span>、
<span class=fallback-latex>y
</span>和
<span class=fallback-latex>z
</span>，若
<span class=fallback-latex>x = y
</span>且
<span class=fallback-latex>y = z
</span>，则
<span class=fallback-latex>x = z
</span>。</li><li><strong>（替换公理）</strong> 给定任意两个同类型的对象
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>y
</span>，如果
<span class=fallback-latex>x = y
</span>，那么对任意一个函数或者运算
<span class=fallback-latex>f
</span>都有
<span class=fallback-latex>f(x) = f(y)
</span>。类似地，对任意一个关于
<span class=fallback-latex>x
</span>的性质
<span class=fallback-latex>P(x)
</span>，如果
<span class=fallback-latex>x = y
</span>，那么
<span class=fallback-latex>P(x)
</span>和
<span class=fallback-latex>P(y)
</span>就是等价的命题。</li></ul><p>容易验证，定义3.1.4满足自反、对称、传递三个性质。</p><p><strong>自反性（Reflexive）:</strong>
<span class=fallback-latex>(\forall x \in A, x \in A) \Rightarrow A = A</span></p><p><strong>对称性（Symmetric）:</strong>
<span class=fallback-latex>(A = B) \Rightarrow (\forall x \in A, x \in B) \land (\forall x \in B, x \in A) \Rightarrow B = A</span></p><p><strong>传递性（Transitive）:</strong>
<span class=fallback-latex>(A = B) \land (B = C) \Rightarrow (\forall x \in A, x \in B) \land (\forall x \in B, x \in C) \Rightarrow (\forall x \in A, x \in C)</span></p><span class=fallback-latex>(A = B) \land (B = C) \Rightarrow (\forall x \in B, x \in A) \land (\forall x \in C, x \in B) \Rightarrow (\forall x \in C, x \in A)
</span><span class=fallback-latex>\text{以上两种情况同时成立，这意味着 } A = C</span><p>根据定义 3.1.4 观察可知，如果
<span class=fallback-latex>x \in A
</span>并且
<span class=fallback-latex>A = B
</span>，那么
<span class=fallback-latex>x \in B
</span>。于是 “是……的元素” 这种
<span class=fallback-latex>\in
</span>关系遵守替换公理。正因如此，只要我们能够把定义在集合上的新运算仅用
<span class=fallback-latex>\in
</span>的语言来描述，这个新运算就会遵守替换公理。例如，对于本节中剩下的定义，情况就是这样。（另外，在良好的定义方式中，我们不能使用集合中 “第一个” 或者 “最后一个” 元素这样的概念，因为这将违背替换公理。例如，虽然集合
<span class=fallback-latex>\{1, 2, 3, 4, 5\}
</span>与
<span class=fallback-latex>\{3, 4, 2, 1, 5\}
</span>表示同一个集合，但是它们的第一个元素是不一样的。）</p><p>面我们来讨论到底什么样的对象是集合，什么样的对象不是集合。</p><p>这与上一章中我们如何定义自然数相类似。我们从单个的自然数
<span class=fallback-latex>0
</span>开始，利用增量运算从
<span class=fallback-latex>0
</span>中构造出更多的数。</p><p>这里我们将尝试做类似的事情，从单个集合（空集）开始，利用各种运算从空集中构造出更多的集合。我们首先假定空集的存在性。</p><p><strong>公理 3.2 (空集)</strong> 存在一个集合
<span class=fallback-latex>\varnothing
</span>，被称为<strong>空集</strong>，它不包含任何元素。也就是说，对于任意的对象
<span class=fallback-latex>x
</span>均有
<span class=fallback-latex>x\notin\varnothing
</span>。</p><p>空集也记作
<span class=fallback-latex>{}
</span>。注意只能有一个空集，如果存在两个集合
<span class=fallback-latex>\varnothing
</span>和
<span class=fallback-latex>\varnothing'
</span>都是空集，那么根据定义3.1.4 （集合的相等）可知，它们必定相等。</p><p>如果一个集合不等于空集，那么称该集合是非空的。下面这个命题非常简单，却值得叙述。</p><p><strong>引理 3.1.6（单个选取）</strong> 设
<span class=fallback-latex>A
</span>是一个非空集合，那么存在一个对象
<span class=fallback-latex>x
</span>使得
<span class=fallback-latex>x \in A
</span>。</p><p><strong>证明：</strong> 我们用反证法来证明。假设不存在任何对象
<span class=fallback-latex>x
</span>使得
<span class=fallback-latex>x \in A
</span>，那么对任意一个对象
<span class=fallback-latex>x
</span>而言，有
<span class=fallback-latex>x \notin A
</span>。另外根据公理 3.2 (空集)可知：
<span class=fallback-latex>x \notin \varnothing
</span>。于是
<span class=fallback-latex>x \in A \iff x \in \varnothing
</span>（这两个命题均为假），进而根据定义 3.1.4 (集合的相等)有
<span class=fallback-latex>A = \varnothing
</span>，显然这与已知条件“
<span class=fallback-latex>A
</span>是一个非空集合”相矛盾。</p><p>注 3.1.7 上述引理断言，给定任意一个非空集合
<span class=fallback-latex>A
</span>，我们可以“选取”
<span class=fallback-latex>A
</span>中的一个元素
<span class=fallback-latex>x
</span>，以此来证实
<span class=fallback-latex>A
</span>的非空性。</p><p>后面（在引理 3.5.12 中）我们将证明对于给定的任意有限多个非空集合
<span class=fallback-latex>A_1, \cdots, A_n
</span>，能够从每个集合
<span class=fallback-latex>A_1, \cdots, A_n
</span>中分别选取一个元素
<span class=fallback-latex>x_1, \cdots, x_n
</span>，这称作“有限选取”。**但是如果想要从无穷多个集合中选取元素，我们就需要另一个公理，即选择公理。**关于选择公理的讨论将留到 8.4 节。</p><p>如果公理 3.2 （空集）是集合论中唯一一个公理，那么集合论必然相当乏味，因为在这种情况下，只有唯一一个集合存在，那就是空集。现在我们给出更深层次的公理来丰富可用集合的种类。</p><p><strong>公理 3.3（单元素集与双元素集）</strong></p><p>如果
<span class=fallback-latex>a
</span>是一个对象，那么存在一个集合
<span class=fallback-latex>\{a\}
</span>并且该集合中唯一的一个元素就是
<span class=fallback-latex>a
</span>。也就是说，对于任意一个对象
<span class=fallback-latex>y
</span>，我们有
<span class=fallback-latex>y \in \{a\}
</span>，当且仅当
<span class=fallback-latex>y=a
</span>；我们称
<span class=fallback-latex>\{a\}
</span>是元素为
<span class=fallback-latex>a
</span>的 <strong>单元素集</strong>。</p><p>更进一步地，如果
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>都是对象，那么存在一个集合
<span class=fallback-latex>\{a, b\}
</span>，并且该集合的元素只有
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>。换言之，对于任何一个对象
<span class=fallback-latex>y
</span>，有
<span class=fallback-latex>y \in \{a,b\}
</span>，当且仅当，
<span class=fallback-latex>y=a
</span>或者
<span class=fallback-latex>y=b
</span>，我们称该集合是由
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>所组成的<strong>双元素集。</strong></p><p>注 3.1.9 正如只存在唯一一个空集那样，根据定义 3.1.4 （集合的相等）可知，元素为
<span class=fallback-latex>a
</span>的单元素集也只有一个。类似地，给定任意两个对象
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>，那么只存在唯一一个由
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>构成的双元素集。同样，定义 3.1.4 （集合的相等）也能确保
<span class=fallback-latex>\{a, b\} = \{b, a\}
</span>以及
<span class=fallback-latex>\{a, a\} = \{a\}
</span>。于是，单元素集公理事实上是多余的，因为它是从双元素集公理中推导出的一个结论。反过来，双元素集公理可以由单元素集公理以及后面的两集合并集公理推出（参见引理 3.1.13）。人们可能会问为什么我们不继续构造三元素集公理、四元素集公理等；然而，一旦我们引入下面的两集合并集公理，就没有必要再去构造这些公理了。</p><p>目前为止，我们构造的每一个集合所包含的元素个数都不超过两个。接下来这个公理将让我们能够构造出比之前稍大一些的集合。</p><p><strong>公理 3.4（两集合并集）</strong> 给定任意两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>，存在一个集合
<span class=fallback-latex>A \cup B
</span>被称为
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的 <strong>并集</strong>，该集合的元素由属于
<span class=fallback-latex>A
</span>的或者属于
<span class=fallback-latex>B
</span>的或者同时属于
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的所有元素共同构成。换言之，对任意的对象
<span class=fallback-latex>x
</span>，</p><span class=fallback-latex>x \in A \cup B \iff (x \in A \text{ 或 } x \in B)</span><p>回忆一下，“或”在数学中默认表示 <strong>包含</strong>，也可以说，<strong>“
<span class=fallback-latex>X
</span>或
<span class=fallback-latex>Y
</span>为真”</strong> 是指 <strong>“要么
<span class=fallback-latex>X
</span>为真，要么
<span class=fallback-latex>Y
</span>为真，要么
<span class=fallback-latex>X
</span>和
<span class=fallback-latex>Y
</span>都为真”。</strong> 参见 A.1 节。</p><p>例 3.1.11 集合
<span class=fallback-latex>\{1,2\} \cup \{2,3\}
</span>中的元素是由属于
<span class=fallback-latex>\{1,2\}
</span>的或者属于
<span class=fallback-latex>\{2,3\}
</span>的或者同时属于这两个集合的一切元素共同构成的；换言之，这个集合的元素就是 1、2 和 3。因此，我们把该集合记作
<span class=fallback-latex>\{1,2\} \cup \{2,3\} = \{1,2,3\}
</span>。</p><p>注 3.1.12 如果
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>和
<span class=fallback-latex>A'
</span>都是集合并且
<span class=fallback-latex>A
</span>等于
<span class=fallback-latex>A'
</span>，那么
<span class=fallback-latex>A \cup B
</span>等于
<span class=fallback-latex>A' \cup B
</span>。</p><p><strong>证明：</strong></p><blockquote><p>步骤 1: 证明
<span class=fallback-latex>A \cup B \subseteq A' \cup B</span></p><p>假设
<span class=fallback-latex>x \in A \cup B
</span>。根据并集的定义，
<span class=fallback-latex>x \in A \cup B
</span>意味着
<span class=fallback-latex>x \in A
</span>或者
<span class=fallback-latex>x \in B
</span>。</p><ul><li>如果
<span class=fallback-latex>x \in A
</span>，由于
<span class=fallback-latex>A = A'
</span>，因此
<span class=fallback-latex>x \in A'
</span>，所以
<span class=fallback-latex>x \in A' \cup B
</span>。</li><li>如果
<span class=fallback-latex>x \in B
</span>，显然
<span class=fallback-latex>x \in A' \cup B
</span>（因为
<span class=fallback-latex>x \in B
</span>）。</li></ul><p>因此，
<span class=fallback-latex>x \in A' \cup B
</span>。从而，我们得出
<span class=fallback-latex>A \cup B \subseteq A' \cup B
</span>。</p><p>步骤 2: 证明
<span class=fallback-latex>A' \cup B \subseteq A \cup B</span></p><p>假设
<span class=fallback-latex>x \in A' \cup B
</span>。根据并集的定义，
<span class=fallback-latex>x \in A' \cup B
</span>意味着
<span class=fallback-latex>x \in A'
</span>或者
<span class=fallback-latex>x \in B
</span>。</p><ul><li>如果
<span class=fallback-latex>x \in A'
</span>，由于
<span class=fallback-latex>A = A'
</span>，因此
<span class=fallback-latex>x \in A
</span>，所以
<span class=fallback-latex>x \in A \cup B
</span>。</li><li>如果
<span class=fallback-latex>x \in B
</span>，显然
<span class=fallback-latex>x \in A \cup B
</span>（因为
<span class=fallback-latex>x \in B
</span>）。</li></ul><p>因此，
<span class=fallback-latex>x \in A \cup B
</span>。从而，我们得出
<span class=fallback-latex>A' \cup B \subseteq A \cup B
</span>。</p><p>结论:</p><p>由步骤 1 和步骤 2，我们得出
<span class=fallback-latex>A \cup B = A' \cup B
</span>。
<span class=fallback-latex>\square</span></p></blockquote><p>虽然以上证明显式的写出了尚未定义的集合之间的属于关系，但实际上，我们完全可以删掉这些属于号，而只使用
<span class=fallback-latex>(\forall x \in A, x \in B),(\forall y \in B, y \in A)
</span>这种写法，上述证明过程仍然成立，因此，该证明过程使用到的只有集合相等定义和并集公理。</p><p>类似地，如果
<span class=fallback-latex>B'
</span>是与
<span class=fallback-latex>B
</span>相等的集合，那么
<span class=fallback-latex>A \cup B
</span>等于
<span class=fallback-latex>A \cup B'
</span>。因此，求并运算遵守替换公理，从而该运算在集合上是定义明确的。</p><p>现在我们给出并集的一些基本性质。</p><p><strong>引理 3.1.13</strong> 如果
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>都是对象，那么
<span class=fallback-latex>\{a, b\} = \{a\} \cup \{b\}
</span>。如果
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>和
<span class=fallback-latex>C
</span>都是集合，那么求并运算是可交换的（即
<span class=fallback-latex>A \cup B = B \cup A
</span>），而且也是可结合的（即
<span class=fallback-latex>(A \cup B) \cup C = A \cup (B \cup C)
</span>）。另外，我们有
<span class=fallback-latex>A \cup A = A \cup \emptyset = \emptyset \cup A = A
</span>。</p><p><strong>证明：</strong> 首先证明 <strong>结合律
<span class=fallback-latex>(A \cup B) \cup C = A \cup (B \cup C)
</span></strong>。</p><p>根据定义 3.1.4 （集合的相等）可知，我们需要证明
<span class=fallback-latex>(A \cup B) \cup C
</span>中的任意一个元素
<span class=fallback-latex>x
</span>都是集合
<span class=fallback-latex>A \cup (B \cup C)
</span>中的元素，反之亦然。</p><p>于是，首先假设
<span class=fallback-latex>x
</span>是
<span class=fallback-latex>(A \cup B) \cup C
</span>中的一个元素，那么根据公理 3.4 （两集合并集）可知，这意味着
<span class=fallback-latex>x \in A \cup B
</span>和
<span class=fallback-latex>x \in C
</span>中至少有一个为真。现在我们分两种情况来讨论。</p><p>如果
<span class=fallback-latex>x \in C
</span>，则根据公理 3.4 可知
<span class=fallback-latex>x \in B \cup C
</span>，进而再次利用公理 3.4 可得，
<span class=fallback-latex>x \in A \cup (B \cup C)
</span>。</p><p>现在假设
<span class=fallback-latex>x \in A \cup B
</span>，那么由公理 3.4 可知
<span class=fallback-latex>x \in A
</span>或
<span class=fallback-latex>x \in B
</span>。一方面，如果
<span class=fallback-latex>x \in A
</span>，从公理 3.4 中可得
<span class=fallback-latex>x \in A \cup (B \cup C)
</span>；另一方面，如果
<span class=fallback-latex>x \in B
</span>，通过连续应用公理 3.4 可得
<span class=fallback-latex>x \in B \cup C
</span>，进而有
<span class=fallback-latex>x \in A \cup (B \cup C)
</span>。</p><p>因此我们得到，在所有可能的情况中，
<span class=fallback-latex>(A \cup B) \cup C
</span>中的每一个元素均包含在
<span class=fallback-latex>A \cup (B \cup C)
</span>中。同理可以推出
<span class=fallback-latex>A \cup (B \cup C)
</span>中的每一个元素也都包含在
<span class=fallback-latex>(A \cup B) \cup C
</span>中，于是我们证明了
<span class=fallback-latex>(A \cup B) \cup C = A \cup (B \cup C)
</span>。□</p><p>第二，对于求并运算的可交换性，<strong>
<span class=fallback-latex>A \cup B=B \cup A
</span></strong>.</p><ol><li>证明
<span class=fallback-latex>A \cup B \subseteq B \cup A
</span>:</li></ol><p>假设
<span class=fallback-latex>x \in A \cup B
</span>。根据并集的定义，此时存在两种可能：</p><ul><li><span class=fallback-latex>x \in A</span></li><li><span class=fallback-latex>x \in B</span></li></ul><p>无论是上述哪种情况，都意味着
<span class=fallback-latex>x \in B \cup A
</span>（因为
<span class=fallback-latex>B \cup A
</span>定义与
<span class=fallback-latex>A \cup B
</span>相同，只是
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的位置对调，不影响“或”的逻辑关系）。</p><p>因此，当
<span class=fallback-latex>x \in A \cup B
</span>时，必有
<span class=fallback-latex>x \in B \cup A
</span>。由此得到
<span class=fallback-latex>A \cup B \subseteq B \cup A
</span>。</p><ol start=2><li>证明
<span class=fallback-latex>B \cup A \subseteq A \cup B
</span>:</li></ol><p>该部分的证明与上面完全对称。</p><p>假设
<span class=fallback-latex>x \in B \cup A
</span>。根据并集的定义，这意味着：</p><ul><li><span class=fallback-latex>x \in B</span></li><li>或者
<span class=fallback-latex>x \in A</span></li></ul><p>无论是哪种情况，都必然有
<span class=fallback-latex>x \in A \cup B
</span>。</p><p>因此，当
<span class=fallback-latex>x \in B \cup A
</span>时，必有
<span class=fallback-latex>x \in A \cup B
</span>。由此得到
<span class=fallback-latex>B \cup A \subseteq A \cup B
</span>。</p><ol start=4><li>合并结果：</li></ol><p>综合上述两个包含关系，我们有：</p><span class=fallback-latex>A \cup B \subseteq B \cup A \quad \text{且} \quad B \cup A \subseteq A \cup B</span><p>根据集合相等的判定标准（互相包含），得到：</p><span class=fallback-latex>A \cup B = B \cup A</span><p>第三，对于 <strong><span class=fallback-latex>A \cup A = A \cup \emptyset = \emptyset \cup A = A.
</span></strong>，使用与上两式同样的证明思路易得。</p><p>因为有了上面这个引理，我们就不需要利用括号来表示多个并集运算了。例如，我们可以用
<span class=fallback-latex>A \cup B \cup C
</span>来代替
<span class=fallback-latex>(A \cup B) \cup C
</span>和
<span class=fallback-latex>A \cup (B \cup C)
</span>。类似地，对于四个集合求并，我们可以写成
<span class=fallback-latex>A \cup B \cup C \cup D
</span>，等等。</p><p>这个公理使得我们可以定义三元素集、四元素集，以此类推。如果
<span class=fallback-latex>a, b, c
</span>是三个对象，那么定义
<span class=fallback-latex>\{a, b, c\} := \{a\} \cup \{b\} \cup \{c\}
</span>；如果
<span class=fallback-latex>a, b, c, d
</span>是四个对象，那么定义
<span class=fallback-latex>\{a, b, c, d\} := \{a\} \cup \{b\} \cup \{c\} \cup \{d\}
</span>，以此类推。另外，对任意给定的自然数
<span class=fallback-latex>n
</span>，我们目前尚无法定义由
<span class=fallback-latex>n
</span>个对象构成的集合；这需要把上述结构迭代 “
<span class=fallback-latex>n
</span>次”，然而
<span class=fallback-latex>n
</span>次迭代的概念还没有被严格定义。基于类似的原因，我们还无法定义由无穷多个对象所构成的集合概念，因为这需要对两集合并集公理迭代无穷多次，而且目前能否确保整个过程的严谨性尚不清楚。后面我们会介绍集合论的一些其他公理，这些公理将使我们能够构造出任意大甚至是无穷大的集合。</p><p>显然，某些集合看起来比其他集合要大。正式建立这种概念的一种方法是引入子集的概念。</p><p><strong>定义 3.1.15（子集）</strong> 设
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>都是集合，我们称
<span class=fallback-latex>A
</span>是
<span class=fallback-latex>B
</span>的子集，并记作
<span class=fallback-latex>A \subseteq B
</span>，当且仅当
<span class=fallback-latex>A
</span>的每一个元素都是
<span class=fallback-latex>B
</span>中的元素，即</p><span class=fallback-latex>\text{对任意的对象} x，x \in A \implies x \in B</span><p>如果
<span class=fallback-latex>A \subseteq B
</span>并且
<span class=fallback-latex>A \neq B
</span>，那么我们称
<span class=fallback-latex>A
</span>是
<span class=fallback-latex>B
</span>的真子集，记作
<span class=fallback-latex>A \subsetneq B
</span>。</p><p>注 3.1.16 因为上面的定义中只包含了相等的概念以及“是……的元素”的关系，而这两者都遵守替换公理，所以子集的概念也自动地遵守替换公理。于是，譬如若
<span class=fallback-latex>A \subseteq B
</span>并且
<span class=fallback-latex>A = A'
</span>，那么
<span class=fallback-latex>A' \subseteq B
</span>。</p><p>例 3.1.17 我们有
<span class=fallback-latex>\{1, 2, 4\} \subseteq \{1, 2, 3, 4, 5\}
</span>，这是因为
<span class=fallback-latex>\{1, 2, 4\}
</span>中的每一个元素都是
<span class=fallback-latex>\{1, 2, 3, 4, 5\}
</span>中的元素。事实上，我们也可以得到
<span class=fallback-latex>\{1, 2, 4\} \subsetneq \{1, 2, 3, 4, 5\}
</span>，因为集合
<span class=fallback-latex>\{1, 2, 4\}
</span>与
<span class=fallback-latex>\{1, 2, 3, 4, 5\}
</span>不相等。给定任意一个集合
<span class=fallback-latex>A
</span>，我们总有
<span class=fallback-latex>A \subseteq A
</span>和
<span class=fallback-latex>\varnothing \subseteq A
</span>。</p><p>正如下面这个命题所描述的那样，集合论中的子集概念类似于数系中“小于或等于”的概念（更精确的表述参见定义 8.5.1）。</p><p><strong>命题 3.1.18（集合的包含关系使集合是偏序的）</strong> 设
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>、
<span class=fallback-latex>C
</span>是集合。如果
<span class=fallback-latex>A \subseteq B
</span>并且
<span class=fallback-latex>B \subseteq C
</span>，那么
<span class=fallback-latex>A \subseteq C
</span>。如果
<span class=fallback-latex>A \subseteq B
</span>并且
<span class=fallback-latex>B \subseteq A
</span>，那么
<span class=fallback-latex>A = B
</span>。最后，如果
<span class=fallback-latex>A \subsetneq B
</span>并且
<span class=fallback-latex>B \subsetneq C
</span>，那么
<span class=fallback-latex>A \subsetneq C
</span>。</p><p><strong>证明：</strong></p><p><strong>第一个结论</strong>。假设
<span class=fallback-latex>A \subseteq B
</span>并且
<span class=fallback-latex>B \subseteq C
</span>。为了证明
<span class=fallback-latex>A \subseteq C
</span>，我们必须证明
<span class=fallback-latex>A
</span>中的每一个元素都是
<span class=fallback-latex>C
</span>中的元素。那么取
<span class=fallback-latex>A
</span>中任意一个元素
<span class=fallback-latex>x
</span>，因为
<span class=fallback-latex>A \subseteq B
</span>，所以
<span class=fallback-latex>x
</span>一定是
<span class=fallback-latex>B
</span>中的元素。又因为
<span class=fallback-latex>B \subseteq C
</span>，所以
<span class=fallback-latex>x
</span>是
<span class=fallback-latex>C
</span>中的元素。因此
<span class=fallback-latex>A
</span>中的每一个元素实际上都是
<span class=fallback-latex>C
</span>中的元素，结论得证。</p><p><strong>第二结论</strong> 证明显然。</p><p><strong>第三结论</strong> 其证明过程和第一结论的证明是完全相同的。</p><p><strong>习题</strong>： 设
<span class=fallback-latex>A
</span>,
<span class=fallback-latex>B
</span>,
<span class=fallback-latex>C
</span>都是集合，</p><ol><li>证明
<span class=fallback-latex>A \cap B \subseteq A
</span>和
<span class=fallback-latex>A \cap B \subseteq B
</span>。</li><li>更进一步地，证明
<span class=fallback-latex>C \subseteq A
</span>且
<span class=fallback-latex>C \subseteq B
</span>，当且仅当
<span class=fallback-latex>C \subseteq A \cap B
</span>。</li><li>类似地，证明
<span class=fallback-latex>A \subseteq A \cup B
</span>和
<span class=fallback-latex>B \subseteq A \cup B
</span>，</li><li>且进一步证明
<span class=fallback-latex>A \subseteq C
</span>且
<span class=fallback-latex>B \subseteq C
</span>，当且仅当
<span class=fallback-latex>A \cup B \subseteq C
</span>。</li></ol><p><strong>证明</strong>：</p><ol><li>证明
<span class=fallback-latex>A \cap B \subseteq A
</span>和
<span class=fallback-latex>A \cap B \subseteq B</span></li></ol><p>(1)
<span class=fallback-latex>A \cap B \subseteq A</span></p><p>证明：设任意
<span class=fallback-latex>x \in A \cap B
</span>。则根据交集的定义，
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in B
</span>。由此可见，
<span class=fallback-latex>x \in A
</span>，故
<span class=fallback-latex>A \cap B \subseteq A
</span>。</p><p>(2)
<span class=fallback-latex>A \cap B \subseteq B</span></p><p>证明与上面类似：设
<span class=fallback-latex>x \in A \cap B
</span>，则
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in B
</span>，因此
<span class=fallback-latex>x \in B
</span>，故
<span class=fallback-latex>A \cap B \subseteq B
</span>。</p><ol start=2><li>当且仅当条件：
<span class=fallback-latex>C \subseteq A \cap B \iff C \subseteq A \text{ 且 } C \subseteq B</span></li></ol><p>(1) 若
<span class=fallback-latex>C \subseteq A \cap B
</span>，则对任意
<span class=fallback-latex>x \in C
</span>，有
<span class=fallback-latex>x \in A \cap B
</span>。由交集定义，
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in B
</span>。由于
<span class=fallback-latex>x
</span>是
<span class=fallback-latex>C
</span>的任意元素，这意味着
<span class=fallback-latex>C \subseteq A
</span>且
<span class=fallback-latex>C \subseteq B
</span>。</p><p>(2) 反之，若
<span class=fallback-latex>C \subseteq A
</span>且
<span class=fallback-latex>C \subseteq B
</span>，则对于任意
<span class=fallback-latex>x \in C
</span>，有
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in B
</span>。由此可得
<span class=fallback-latex>x \in A \cap B
</span>。因为
<span class=fallback-latex>x
</span>是
<span class=fallback-latex>C
</span>的任意元素，所以
<span class=fallback-latex>C \subseteq A \cap B
</span>。</p><p>结合(1)和(2)，可得</p><p><span class=fallback-latex>C \subseteq A \cap B \iff C \subseteq A \text{ 且 } C \subseteq B
</span>.</p><ol start=3><li>证明
<span class=fallback-latex>A \subseteq A \cup B
</span>和
<span class=fallback-latex>B \subseteq A \cup B</span></li></ol><p>(1)
<span class=fallback-latex>A \subseteq A \cup B</span></p><p>证明：若任意
<span class=fallback-latex>x \in A
</span>，则根据并集定义
<span class=fallback-latex>x \in A \cup B
</span>（因为
<span class=fallback-latex>x \in A
</span>即满足“或”条件）。由此
<span class=fallback-latex>A \subseteq A \cup B
</span>。</p><p>(2)
<span class=fallback-latex>B \subseteq A \cup B</span></p><p>证明与上类似：若
<span class=fallback-latex>x \in B
</span>，则
<span class=fallback-latex>x \in A \cup B
</span>，故
<span class=fallback-latex>B \subseteq A \cup B
</span>。</p><ol start=4><li>当且仅当条件：
<span class=fallback-latex>A \cup B \subseteq C \iff A \subseteq C \text{ 且 } B \subseteq C</span></li></ol><p>(1) 若
<span class=fallback-latex>A \cup B \subseteq C
</span>，则对任意
<span class=fallback-latex>x \in A
</span>，因为
<span class=fallback-latex>A \subseteq A \cup B
</span>，所以
<span class=fallback-latex>x \in A \cup B \subseteq C
</span>，故
<span class=fallback-latex>A \subseteq C
</span>。同理，对任意
<span class=fallback-latex>x \in B
</span>，有
<span class=fallback-latex>x \in A \cup B \subseteq C
</span>，故
<span class=fallback-latex>B \subseteq C
</span>。综合得到
<span class=fallback-latex>A \subseteq C \text{ 且 } B \subseteq C
</span>。</p><p>(2) 反之，若
<span class=fallback-latex>A \subseteq C \text{ 且 } B \subseteq C
</span>，则对任意
<span class=fallback-latex>x \in A \cup B
</span>，必然
<span class=fallback-latex>x \in A \text{ 或 } x \in B
</span>，进而
<span class=fallback-latex>x \in C
</span>，因此
<span class=fallback-latex>A \cup B \subseteq C
</span>。</p><p>综上，</p><p><span class=fallback-latex>A \cup B \subseteq C \iff A \subseteq C \text{ 且 } B \subseteq C
</span>.</p><p>注 3.1.20 子集关系
<span class=fallback-latex>\subsetneq
</span>和小于关系
<span class=fallback-latex><
</span>之间存在一个重要的区别。给定任意两个不同的自然数
<span class=fallback-latex>n
</span>和
<span class=fallback-latex>m
</span>，我们知道其中一个会比另外一个小（命题2.2.13 自然数的序的三歧性）；但是给定两个不同的集合，说其中一个是另外一个集合的子集这种命题通常不为真。例如，令
<span class=fallback-latex>A := \{2n : n \in \mathbb{N}\}
</span>是由所有偶自然数构成的集合，令
<span class=fallback-latex>B := \{2n + 1 : n \in \mathbb{N}\}
</span>是由所有奇自然数构成的集合，那么
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>彼此互不为对方的子集。这就是我们为什么说集合仅仅是 <strong>偏序</strong> 的，而自然数却是 <strong>全序</strong> 的（参见定义8.5.1和定义8.5.3）。</p><p>注 3.1.21 我们也应该注意到子集关系
<span class=fallback-latex>\subseteq
</span>与元素的属于关系
<span class=fallback-latex>\in
</span>是不一样的。数字
<span class=fallback-latex>2
</span>是集合
<span class=fallback-latex>\{1, 2, 3\}
</span>中的一个元素，而不是它的一个子集，因此
<span class=fallback-latex>2 \in \{1, 2, 3\}
</span>，但是
<span class=fallback-latex>2 \nsubseteq \{1, 2, 3\}
</span>。事实上，
<span class=fallback-latex>2
</span>本身就不是一个集合。反过来，
<span class=fallback-latex>\{2\}
</span>是集合
<span class=fallback-latex>\{1, 2, 3\}
</span>的一个子集，而不是元素，所以
<span class=fallback-latex>\{2\} \subseteq \{1, 2, 3\}
</span>，但是
<span class=fallback-latex>\{2\} \notin \{1, 2, 3\}
</span>。这里的关键在于数字
<span class=fallback-latex>2
</span>和集合
<span class=fallback-latex>\{2\}
</span>是不同的对象。</p><p>把集合与集合中的元素区分开来非常重要，因为 <strong>集合和元素具有不同的性质</strong>。譬如，能够找到一个含有无穷多个元素的集合，其中每一个元素都是有穷数字（自然数集
<span class=fallback-latex>\mathbb{N}
</span>就是这样的例子），也能够找到这样一个集合，它的元素个数是有限的，但是每个元素都是由无穷多个元素构成的集合（例如，考虑集合
<span class=fallback-latex>\{\mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{R}\}
</span>，该集合共有四个元素且每一个元素都是由无穷多个元素构成的集合）。</p><p>现在我们给出一个公理，它能够让我们轻松地构造出一个较大集合的子集。</p><p><strong>公理 3.5（分类公理）</strong> 设
<span class=fallback-latex>A
</span>是一个集合，对任意的
<span class=fallback-latex>x \in A
</span>，令
<span class=fallback-latex>P(x)
</span>表示关于
<span class=fallback-latex>x
</span>的一个性质（即
<span class=fallback-latex>P(x)
</span>要么是真命题，要么是假命题）。那么存在一个集合，记作
<span class=fallback-latex>\{x \in A : P(x) \text{ 为真}\}
</span>（或者简记为
<span class=fallback-latex>\{x \in A : P(x)\}
</span>），该集合恰好是由
<span class=fallback-latex>A
</span>中那些使得
<span class=fallback-latex>P(x)
</span>为真的元素
<span class=fallback-latex>x
</span>构成的。换言之，对任意的对象
<span class=fallback-latex>y
</span>，</p><span class=fallback-latex>y \in \{x \in A : P(x) \text{ 为真}\} \iff (y \in A \text{ 并且 } P(y) \text{ 为真})</span><p>这个公理也被称为 <strong>分离公理</strong>。注意，
<span class=fallback-latex>\{x \in A : P(x) \text{ 为真}\}
</span>一定是集合
<span class=fallback-latex>A
</span>的一个子集，尽管它可能与
<span class=fallback-latex>A
</span>一样大，也可能与空集一样小。我们能够证明替换公理适用于分类，所以如果
<span class=fallback-latex>A = A'
</span>，则有
<span class=fallback-latex>\{x \in A : P(x)\} = \{x \in A' : P(x)\}
</span>。（因为，替换公理保证若
<span class=fallback-latex>A = A'
</span>，则我们可以在任意公式中将
<span class=fallback-latex>A
</span>替换为
<span class=fallback-latex>A'
</span>而不改变命题的真值，因此分离公理满足替换公理）</p><blockquote><p>另外，我们在此处所述的替换公理，实际上是一阶逻辑中的替换性。</p><p>逻辑中的替换原则（等式替代性）：</p><p>在一阶逻辑中，如果我们知道
<span class=fallback-latex>x = y
</span>，那么无论在什么性质
<span class=fallback-latex>P(x)
</span>或函数
<span class=fallback-latex>f(x)
</span>中，都可以把
<span class=fallback-latex>x
</span>换成
<span class=fallback-latex>y
</span>而不会改变陈述的真值或函数的值。这是逻辑本身的一个基本定律，也常被翻译为“替换规则”或“替代律”。有时，有些教材或笔记中也会将其称为“替换公理”或“替换规律”，这是在逻辑层面上的用法。这种替换不涉及集合的构造，只是逻辑上允许你将相等的对象互相替代。</p><p>而在 ZF<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 公理系统中也存在一个替换公理，其表述为</p><p><strong>替换公理模式（Replacement Schema）</strong> 是 ZF 集合论的一组 <strong>公理模式</strong>，用以保证由函数式定义的类从集合中“替换”元素形成的新类依然是集合。其一般形式如下：</p><p>给定一个公式
<span class=fallback-latex>\phi(x, y, \vec{p})
</span>，其中
<span class=fallback-latex>\vec{p}
</span>是若干参数，
<span class=fallback-latex>\phi
</span>在集合论语言中构成一个谓词。如果满足下列条件：</p><ol><li><p>对任意集合
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>x'
</span>，如果对某个
<span class=fallback-latex>\vec{p}
</span>有
<span class=fallback-latex>\phi(x, y, \vec{p})
</span>且
<span class=fallback-latex>\phi(x', y', \vec{p})
</span>成立，那么若
<span class=fallback-latex>x = x'
</span>则必定
<span class=fallback-latex>y = y'
</span>。也就是说，对于固定的参数
<span class=fallback-latex>\vec{p}
</span>和每个集合
<span class=fallback-latex>x
</span>，
<span class=fallback-latex>\phi
</span>充当一个定义良好的“类函数”——从
<span class=fallback-latex>x
</span>唯一确定一个
<span class=fallback-latex>y
</span>。</p></li><li><p>对任意集合
<span class=fallback-latex>A
</span>，定义
<span class=fallback-latex>B = \{y : \exists x \in A, \phi(x, y, \vec{p})\}
</span>。那么替换公理断言：
<span class=fallback-latex>B
</span>也是一个集合。</p></li></ol><p>简而言之，替换公理模式可以表述为：</p><p>如果
<span class=fallback-latex>\phi
</span>定义了从任意集合
<span class=fallback-latex>A
</span>到集合的一个类函数（即对
<span class=fallback-latex>A
</span>中每个元素
<span class=fallback-latex>x
</span>唯一定义一个
<span class=fallback-latex>y
</span>使
<span class=fallback-latex>\phi(x, y)
</span>成立），那么
<span class=fallback-latex>\{y : \exists x \in A, \phi(x, y)\}
</span>也是一个集合。</p></blockquote><blockquote><p>两者的根本区别在于：替换性保证在逻辑推理中，可自由地在公式中用相等的对象互代，以维持公式的真值不变。这是一种语义上的逻辑规则，用来 <strong>确保逻辑推理的正确性和一致性</strong>。替换公理保证给定某种定义良好的类函数，可以“替换”集合中的每个元素为其对应像值，从而产生新集合的存在性。这是关于 <strong>从集合理论中已有的集合构造出新集合的存在性命题</strong>。因此，在平常的使用中，我们必须区别两者。</p></blockquote><p>有时我们用
<span class=fallback-latex>\{x \in A | P(x)\}
</span>来代替
<span class=fallback-latex>\{x \in A : P(x)\}
</span>，当用冒号 “:” 表示其他含义时，这种新写法就有用了。例如，用冒号来表示一个函数
<span class=fallback-latex>f : X \to Y
</span>的值域和定义域。</p><p>我们可以利用分类公理去进一步定义集合上的一些运算，即求交集和差集。</p><p><strong>定义 3.1.23（交集）</strong> 两个集合的交集
<span class=fallback-latex>S_1 \cap S_2
</span>被定义为下面这样一个集合：</p><span class=fallback-latex>S_1 \cap S_2 := \{x \in S_1 : x \in S_2\}</span><p>即
<span class=fallback-latex>S_1 \cap S_2
</span>是由所有同时属于
<span class=fallback-latex>S_1
</span>和
<span class=fallback-latex>S_2
</span>的元素构成的。于是对任意的对象
<span class=fallback-latex>x
</span>，</p><span class=fallback-latex>x \in S_1 \cap S_2 \iff x \in S_1 \text{ 且 } x \in S_2</span><p>注 3.1.24 注意，这个定义是明确的（也就是说，该定义遵守替换公理）因为定义中仅仅使用到了属于关系以及更为原始的“满足..的性质”这一概念，因此它是遵循替换公理（替换性）的。</p><p>注 3.1.26 顺便提一下，对于词语中的“和”我们要小心使用。根据上下文，它有时候表示并集，而有时候表示交集，非常容易混淆。例如，如果有人谈到“男孩和女孩”的集合，那么他的意思是男孩组成的集合与女孩组成的集合的并集，但是如果有人提到同时满足单身和男性这两个条件的人组成的集合，那么他的意思就是单身人士组成的集合与男性组成的集合的交集。另一个问题是“和”也表示相加，例如，我们可以说“2 与 3 的和是 5”，也可以说“集合 {2} 的元素和集合 {3} 的元素构成了集合 {2, 3}”，还有“在 {2} 和 {3} 中的元素构成了集合 ∅”。这确实容易混淆！原因之一在于我们用数学符号来代替像“和”这样的词语。数学符号总是能够准确清晰地表述意思，而想要真正了解某个词语所表达的涵义，我们必须非常仔细地阅读上下文才行。</p><p><strong>定义 3.1.27（差集）</strong> 给定两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>，我们定义集合
<span class=fallback-latex>A - B
</span>或
<span class=fallback-latex>A \setminus B
</span>是由
<span class=fallback-latex>A
</span>中所有不属于
<span class=fallback-latex>B
</span>的元素组成的集合。</p><span class=fallback-latex>A \setminus B := \{ x \in A : x \notin B \}</span><p>例如，
<span class=fallback-latex>\{1, 2, 3, 4\} \setminus \{2, 4, 6\} = \{1, 3\}
</span>。在很多情况下，
<span class=fallback-latex>B
</span>是
<span class=fallback-latex>A
</span>的一个子集，但并非必须如此。</p><p>现在我们给出并集、交集和差集的一些基本性质。</p><p><strong>命题 3.1.28（集合构成布尔代数）</strong> 设
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>、
<span class=fallback-latex>C
</span>都是集合，令
<span class=fallback-latex>X
</span>表示包含
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>、
<span class=fallback-latex>C
</span>作为其子集的集合。</p><p>(a)（最小元）我们有
<span class=fallback-latex>A \cup \emptyset = A
</span>和
<span class=fallback-latex>A \cap \emptyset = \emptyset
</span>。</p><p>(b)（最大元）我们有
<span class=fallback-latex>A \cup X = X
</span>和
<span class=fallback-latex>A \cap X = A
</span>。</p><p>(c)（恒等式）我们有
<span class=fallback-latex>A \cap A = A
</span>和
<span class=fallback-latex>A \cup A = A
</span>。</p><p>(d)（交换律）我们有
<span class=fallback-latex>A \cup B = B \cup A
</span>和
<span class=fallback-latex>A \cap B = B \cap A
</span>。</p><p>(e)（结合律）我们有
<span class=fallback-latex>(A \cup B) \cup C = A \cup (B \cup C)
</span>和
<span class=fallback-latex>(A \cap B) \cap C = A \cap (B \cap C)
</span>。</p><p>(f)（分配律）我们有
<span class=fallback-latex>A \cap (B \cup C) = (A \cap B) \cup (A \cap C)
</span>和
<span class=fallback-latex>A \cup (B \cap C) = (A \cup B) \cap (A \cup C)
</span>。</p><p>(g)（分拆法）我们有
<span class=fallback-latex>A \cup (X \setminus A) = X
</span>和
<span class=fallback-latex>A \cap (X \setminus A) = \emptyset
</span>。</p><p>(h)（德摩根定律）我们有
<span class=fallback-latex>X \setminus (A \cup B) = (X \setminus A) \cap (X \setminus B)
</span>和
<span class=fallback-latex>X \setminus (A \cap B) = (X \setminus A) \cup (X \setminus B)
</span>。</p><p>注 3.1.29 德摩根定律是以逻辑学家奥古斯塔斯·德摩根（1806—1871）的名字来命名的，他把这些定律确定为集合论的基本定律之一。</p><blockquote><ol><li>什么是布尔代数 (Boolean Algebra)?</li></ol><p>布尔代数是一种抽象代数结构，用来刻画经典逻辑以及集合运算的代数性质。它由一个带有两个二元运算（通常记为
<span class=fallback-latex>\land
</span>和
<span class=fallback-latex>\lor
</span>或者
<span class=fallback-latex>\cap
</span>和
<span class=fallback-latex>\cup
</span>）、一个一元运算（补操作），以及特定恒等元所组成的代数系统。满足布尔代数的结构必须符合以下公理特性：</p><ul><li><p><strong>交换律 (Commutativity)</strong>：</p></li><li><span class=fallback-latex>a \land b = b \land a</span></li><li><span class=fallback-latex>a \lor b = b \lor a</span></li><li><p><strong>结合律 (Associativity)</strong>：</p></li><li><span class=fallback-latex>(a \land b) \land c = a \land (b \land c)</span></li><li><span class=fallback-latex>(a \lor b) \lor c = a \lor (b \lor c)</span></li><li><p><strong>分配律 (Distributivity)</strong>：</p></li><li><span class=fallback-latex>a \land (b \lor c) = (a \land b) \lor (a \land c)</span></li><li><span class=fallback-latex>a \lor (b \land c) = (a \lor b) \land (a \lor c)</span></li></ul><p><strong>恒等元存在 (Identity Elements)</strong>：
存在两个特殊元素：</p><ul><li>单位元 1 以及零元 0，满足：</li><li><span class=fallback-latex>a \land 1 = a</span></li><li><span class=fallback-latex>a \lor 0 = a</span></li></ul><p><strong>补元存在 (Complements)</strong>：
对每个 a 存在补元 a&rsquo; 使：</p><ul><li><span class=fallback-latex>a \land a' = 0</span></li><li><span class=fallback-latex>a \lor a' = 1</span></li></ul><p>典型的布尔代数例子包括：</p><ul><li>真值代数：{true, false} 构成的代数结构</li><li>任一集合的幂集（其子集组成的集合），在并集、交集和补集下形成的结构</li></ul><ol start=2><li>为什么“集合构成布尔代数”这个命题重要到成为集合论的基本定律？</li></ol><p>集合论在很大程度上被视为现代数学的基础框架。当我们发现任意集合的幂集在并、交和补这三种操作下构成了一个布尔代数时，这意味着经典命题逻辑的代数结构（逻辑运算：与、或、非）有了一个精确而自然的集合论刻画。换言之，<strong>逻辑命题间的真值结构与集合之间的包含关系及运算结构完全同构</strong>。这种对应为数学基础的统一提供了坚实的理论支撑，让我们能够在集合论基础上讨论逻辑系统的性质，从而使得集合论不仅仅是“描述数学对象的语言”，还是“描述逻辑结构和推理过程的语言”。</p></blockquote><p>虽然现在我们已经积累了有关集合的大量公理和结果，但是还有许多事情没办法做到。关于集合，我们想要做的一件最基本的事就是取出集合中的每一个元素，并按照某种方式把每一个元素都转换成另外的新对象。例如，我们希望从一个数集
<span class=fallback-latex>\{3, 5, 9\}
</span>开始，把该集合中的每个元素进行增长，从而构造出一个新集合
<span class=fallback-latex>\{4, 6, 10\}
</span>。直接利用之前学过的公理是无法做到这件事的，因此我们需要一个新公理。</p><p><strong>公理 3.6 (替代)</strong> 设
<span class=fallback-latex>A
</span>是一个集合，对任意的
<span class=fallback-latex>x\in A
</span>和任意的一个对象
<span class=fallback-latex>y
</span>，假设存在一个关于
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>y
</span>的命题
<span class=fallback-latex>P(x,y)
</span>使得对任意的
<span class=fallback-latex>x\in A
</span>，最多能够找到一个
<span class=fallback-latex>y
</span>使得
<span class=fallback-latex>P(x,y)
</span>为真。那么存在一个集合
<span class=fallback-latex>\{y:P(x,y)对某x\in A为真\}
</span>使得对任意的对象
<span class=fallback-latex>z
</span>，</p><span class=fallback-latex>z\in\{y:P(x,y)对某x\in A为真\}\iff 对某x\in A,P(x,z)为真</span><p>例 3.1.31 令
<span class=fallback-latex>A:=\{3,5,9\}
</span>，并且设
<span class=fallback-latex>P(x,y)
</span>表示命题
<span class=fallback-latex>y=x++
</span>，即
<span class=fallback-latex>y
</span>是紧跟在
<span class=fallback-latex>x
</span>之后的那个数。观察可知，对任意一个
<span class=fallback-latex>x\in A
</span>，只有一个
<span class=fallback-latex>y
</span>使得
<span class=fallback-latex>P(x,y)
</span>为真。具体地，就是紧跟在
<span class=fallback-latex>x
</span>之后的那个数。于是，上面的公理断定集合
<span class=fallback-latex>\{y:y=x++对某x\in\{3,5,9\}为真\}
</span>是存在的。此时，上述集合显然就是
<span class=fallback-latex>\{4,6,10\}
</span>。</p><p>例 3.1.32 令
<span class=fallback-latex>A:=\{3,5,9\}
</span>，设
<span class=fallback-latex>P(x,y)
</span>表示命题
<span class=fallback-latex>y=1
</span>。那么同样，对任意的
<span class=fallback-latex>x\in A
</span>，只有一个
<span class=fallback-latex>y
</span>使得
<span class=fallback-latex>P(x,y)
</span>为真。具体地，就是数字1。此时，
<span class=fallback-latex>\{y:y=1对某x\in\{3,5,9\}为真\}
</span>就是单元素集
<span class=fallback-latex>\{1\}
</span>，我们已经把原始集合
<span class=fallback-latex>A
</span>中的每一个元素3、5、9都用同一个元素1来代替。因此，这个相当无聊的例子告诉我们，通过上述公理得到的集合可以比原始集合更"小"。</p><p>我们经常把形式如<br><span class=fallback-latex>\{ y : \text{ 对某些 } x \in A \text{ 有 } y = f(x) \}</span><br>的集合简写为
<span class=fallback-latex>\{ f(x) : x \in A \}
</span>或者
<span class=fallback-latex>\{ f(x) | x \in A \}
</span>。例如，若
<span class=fallback-latex>A = \{3, 5, 9\}
</span>，那么<br><span class=fallback-latex>\{ x++ : x \in A \}
</span>就是集合
<span class=fallback-latex>\{4, 6, 10\}
</span>。我们当然可以把代数和分类公理合并在一起使用。例如，按照下面的过程构造类似<br><span class=fallback-latex>\{ f(x) : x \in A \text{ 且 } P(x) \text{ 为真} \}
</span>的集合。<br>从集合 A 开始，利用分类公理构造集合
<span class=fallback-latex>\{ x \in A : P(x) \text{ 为真} \}
</span>，然后使用替代公理构造集合<br><span class=fallback-latex>\{ f(x) : x \in A \text{ 且 } P(x) \text{ 为真} \}
</span>。于是可以有<br><span class=fallback-latex>\{ n++ : n \in \{3, 5, 9\} \text{ 且 } n < 6\}=\{4,6\}
</span>。</p><p>在我们的许多例子中，都隐含地假设了自然数实际上就是对象。对此我们给出下面的正式叙述。</p><p><strong>公理 3.7 (无穷大)</strong> 存在一个集合
<span class=fallback-latex>\mathbb{N}
</span>，它的元素被称为自然数。对象 0 在
<span class=fallback-latex>\mathbb{N}
</span>中，且每一个自然数
<span class=fallback-latex>n \in \mathbb{N}
</span>所指定的满足皮亚诺公理（公理 2.1～2.5）的对象
<span class=fallback-latex>n++
</span>也在
<span class=fallback-latex>\mathbb{N}
</span>中。</p><p>这是假设 2.6 更加正式的表达。它被称为无穷大公理，因为它引入了无穷大集合一个最基本的例子，也就是自然数集
<span class=fallback-latex>\mathbb{N}
</span>（我们将在 3.6 节正式阐述有穷大和无穷大的意思）。我们从无穷大公理中能够看到，像 3, 5, 7 等这样的数确实是集合论中的对象，从而（根据双元素集合公理和两集合并集公理）我们的确可以合法构造如
<span class=fallback-latex>\{ 3, 5, 9 \}
</span>这样的集合，就像在之前的例子中我们做过的那样。</p><p>我们必须区分清楚“集合”的概念以及“集合中元素”的概念。例如，集合
<span class=fallback-latex>\{ n + 3 : n \in \mathbb{N}, 0 \leq n \leq 5 \}
</span>与表达式或函数
<span class=fallback-latex>n + 3
</span>并不相同。我们通过下面的例子来强调这一点。</p><p>例 3.1.33 （非正式的）这个例子需要用到减法的概念，但是目前我们还没有正式介绍减法。下面两个命题<br><span class=fallback-latex>\{ n + 3 : n \in \mathbb{N}, 0 \leq n \leq 5 \} = \{ 8 - n : n \in \mathbb{N}, 0 \leq n \leq 5 \} \tag{3.1}</span><br>成立（见下文），尽管对任意的自然数
<span class=fallback-latex>n
</span>，表达式
<span class=fallback-latex>n + 3
</span>和
<span class=fallback-latex>8 - n
</span>都绝对不可能相等。<br>所以当你谈论集合时，记得要使用大括号
<span class=fallback-latex>\{ \}
</span>，这样可以避免你偶然地把集合与其元素混淆。<br>这种看似简单的原因之一是字符
<span class=fallback-latex>n
</span>在式 (3.1) 的两端是以两种不同的方式使用的。为了阐明这种情况，我们把字符
<span class=fallback-latex>n
</span>替换成字母
<span class=fallback-latex>m
</span>来重新书写集合<br><span class=fallback-latex>\{ 8 - n : n \in \mathbb{N}, 0 \leq n \leq 5 \}
</span>，于是我们得到<br><span class=fallback-latex>\{ 8 - m : m \in \mathbb{N}, 0 \leq m \leq 5 \}
</span>。它与之前的集合完全相等。因此我们能够把式 (3.1) 重新写成：</p><span class=fallback-latex>\{ n + 3 : n \in \mathbb{N}, 0 \leq n \leq 5 \} = \{ 8 - m : m \in \mathbb{N}, 0 \leq m \leq 5 \}</span><p>现在很容易看出（利用定义 3.1.4）为什么该等式为真：每一个形式如
<span class=fallback-latex>n + 3
</span>的数（其中
<span class=fallback-latex>n
</span>表示 0 与 5 之间的自然数）也可以写成
<span class=fallback-latex>8 - m
</span>的形式，其中
<span class=fallback-latex>m := 5 - n
</span>（注意
<span class=fallback-latex>m
</span>也是 0 到 5 之间的自然数）。反过来，每一个形式
<span class=fallback-latex>8 - m
</span>的数（其中
<span class=fallback-latex>m
</span>表示 0 到 5 之间的自然数）也可以写成
<span class=fallback-latex>n + 3
</span>的形式，其中
<span class=fallback-latex>n := 5 - m
</span>（注意
<span class=fallback-latex>n
</span>也是 0 到 5 之间的自然数）。观察一下，如果我们没有事先把
<span class=fallback-latex>n
</span>替换成
<span class=fallback-latex>m
</span>，那么上面对式 (3.1) 的解释将会让人困惑！</p><p><strong>原因与分析：</strong></p><p>在最初的写法中，集合通通过类似的表达式构造，例如<br><span class=fallback-latex>\{ n + 3 : n \in \mathbb{N}, 0 \leq n \leq 5 \} = \{ 8 - n : n \in \mathbb{N}, 0 \leq n \leq 5 \}
</span>。</p><p>这里两边都使用了相同的记号
<span class=fallback-latex>n
</span>，但在左侧和右侧实际上是两次独立引入的【哑变量】（dummy variable）。从逻辑上讲，这些变量在各自的集合构造中是局部的，不应该相互混淆。然而，当两侧同时使用同一个字母
<span class=fallback-latex>n
</span>时，该符号可能会被误认为是一个全局的变量，从而产生误解，以为这两个定义式右边一层正用同一个值描述元素。因此会让人困惑：为什么
<span class=fallback-latex>n+3
</span>的元素集会等于
<span class=fallback-latex>8-n
</span>的元素集，难道左边两个表达式中
<span class=fallback-latex>n
</span>是同一回事吗？</p><p><strong>如何解决混淆：</strong></p><p>通过将右侧的
<span class=fallback-latex>n
</span>改成
<span class=fallback-latex>m
</span>，得到<br><span class=fallback-latex>\{ n + 3 : n \in \mathbb{N}, 0 \leq n \leq 5 \} = \{ 8 - m : m \in \mathbb{N}, 0 \leq m \leq 5 \}
</span>。</p><p>现在，这看一眼就能看出：左边用
<span class=fallback-latex>n
</span>来构造集合，右边用
<span class=fallback-latex>m
</span>来构造集合，它们是两个独立的参数，各自有独立定义的集合。这样就可以清晰地观察到，左边集合里的每个元素都能通过一个适当的
<span class=fallback-latex>m
</span>（或在集合里的元素都能通过一个合适的
<span class=fallback-latex>n
</span>）来匹配上。换句话说，改变了字母作为变量之后，变量不会误地将两侧的集合混为一谈，而能顺利理解两个集合事实上是不同的参数化得到的元集合。</p><h2 id=3习题>3.习题</h2><ol><li>设
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是集合，证明 <strong>吸收率</strong>
<span class=fallback-latex>A \cap (A \cup B) = A \quad \text{和} \quad A \cup (A \cap B) = A.</span></li></ol><p>证明
<span class=fallback-latex>A \cap (A \cup B) = A</span></p><ol><li>证明
<span class=fallback-latex>A \cap (A \cup B) \subseteq A
</span>:</li></ol><p>设
<span class=fallback-latex>x \in A \cap (A \cup B)
</span>。<br>根据集合定义：
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in A \cup B
</span>。<br>由于
<span class=fallback-latex>x \in A
</span>，故有
<span class=fallback-latex>x \in A \cap (A \cup B) \subseteq A
</span>。</p><ol start=2><li>证明
<span class=fallback-latex>A \subseteq (A \cap (A \cup B))
</span>:</li></ol><p>设
<span class=fallback-latex>x \in A
</span>。<br>因为
<span class=fallback-latex>x \in A
</span>所以显然
<span class=fallback-latex>x \in A \cup B
</span>（因为
<span class=fallback-latex>x \in A
</span>即满足“或”条件）。<br>因此
<span class=fallback-latex>x \in A \cap (A \cup B)
</span>。</p><p>综上，两方面的包涵都得证，故有
<span class=fallback-latex>A \cap (A \cup B) = A
</span>。</p><p>证明
<span class=fallback-latex>A \cup (A \cap B) = A</span></p><ol><li><p>证明
<span class=fallback-latex>A \cup (A \cap B) \subseteq A
</span>:<br>设
<span class=fallback-latex>x \in A \cup (A \cap B)
</span>。<br>根据并集定义，
<span class=fallback-latex>x \in A
</span>或
<span class=fallback-latex>x \in A \cap B
</span>。<br>若
<span class=fallback-latex>x \in A
</span>，则显然
<span class=fallback-latex>x \in A
</span>成立。<br>若
<span class=fallback-latex>x \in A \cap B
</span>，根据交集定义，
<span class=fallback-latex>x \in A
</span>且
<span class=fallback-latex>x \in B
</span>。此时依然有
<span class=fallback-latex>x \in A
</span>。<br>故
<span class=fallback-latex>A \cup (A \cap B) \subseteq A
</span>。</p></li><li><p>证明
<span class=fallback-latex>A \subseteq (A \cup (A \cap B))
</span>:<br>设
<span class=fallback-latex>x \in A
</span>。<br>由于
<span class=fallback-latex>x \in A
</span>，显然有
<span class=fallback-latex>x \in A \cup (A \cap B)
</span>。<br>故
<span class=fallback-latex>A \subseteq (A \cup (A \cap B))
</span>。</p></li></ol><p>综上，两方面的包涵都得证，故有
<span class=fallback-latex>A \cup (A \cap B) = A
</span>。</p><ol start=2><li>令
<span class=fallback-latex>A, B, X
</span>表示集合，并且它们满足
<span class=fallback-latex>A \cup B = X
</span>和
<span class=fallback-latex>A \cap B = \emptyset
</span>。证明
<span class=fallback-latex>A = X \setminus B
</span>和
<span class=fallback-latex>B = X \setminus A</span></li></ol><p>证明
<span class=fallback-latex>A = X \setminus B</span></p><ol><li>证明
<span class=fallback-latex>A \subseteq X \setminus B
</span>:</li></ol><p>任取
<span class=fallback-latex>x \in A
</span>，因为
<span class=fallback-latex>A \subseteq A \cup B = X
</span>，可知
<span class=fallback-latex>x \in X
</span>。<br>又因为
<span class=fallback-latex>A \cap B = \emptyset
</span>，所以
<span class=fallback-latex>x \notin B
</span>。<br>因此
<span class=fallback-latex>x \in X \setminus B
</span>，故
<span class=fallback-latex>A \subseteq X \setminus B
</span>。</p><ol start=2><li>证明
<span class=fallback-latex>X \setminus B \subseteq A
</span>:</li></ol><p>任取
<span class=fallback-latex>x \in X \setminus B
</span>，则
<span class=fallback-latex>x \in X
</span>且
<span class=fallback-latex>x \notin B
</span>。<br>已知
<span class=fallback-latex>X = A \cup B
</span>，且
<span class=fallback-latex>x \in A \cup B
</span>，则
<span class=fallback-latex>x \in A
</span>或
<span class=fallback-latex>x \in B
</span>。<br>由于
<span class=fallback-latex>x \notin B
</span>，则只能有
<span class=fallback-latex>x \in A
</span>，故
<span class=fallback-latex>X \setminus B \subseteq A
</span>。</p><p>综上，两方面的包涵都得证，故有
<span class=fallback-latex>A = X \setminus B
</span>。</p><p>证明
<span class=fallback-latex>B = X \setminus A
</span>的过程与上完全相同，只需将
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的角色对调：</p><ol><li><span class=fallback-latex>x \in B \Rightarrow x \in X \text{ 且 } x \notin A, \text{ 故 } B \subseteq X \setminus A.</span></li><li><span class=fallback-latex>x \in X \setminus A \Rightarrow x \in X \text{ 且 } x \notin A, \text{ 由 } X = A \cup B \text{ 且 } x \notin A, \text{ 得 } x \in B, \text{ 故 } X \setminus A \subseteq B.</span></li></ol><p>综上可得
<span class=fallback-latex>B = X \setminus A
</span>。</p><p>其余习题已于正文中给出。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>策梅洛-弗兰克尔集合论（英语：Zermelo-Fraenkel Set Theory），是数学基础中最常用的一阶公理化集合论。含选择公理时常简写为ZFC，不含选择公理的则简写为ZF。它是二十世纪早期为了建构一个不会导致类似罗素悖论的矛盾的集合理论所提出的一个公理系统。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><aside class=sidebar><div class=card><h2>摘要</h2><p>1.摘要 本文公理一览：
公理 3.1（集合是对象） 相等公理、替换公理 公理 3.2 (空集) 公理 3.3（单元素集与双元素集） 公理 3.4（两集合并集） 公理 3.5（分类公理） 公理 3.6 …</p></div><div class=card><h2>阅读时长</h2><p>18 min</p></div><div class=card><h2>总字数</h2><p>≈ 3689</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
数学分析</a></p></div></aside></div></div></main><div id=related><h2>Related Pages</h2><ul class=posts><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/3.1.2/><h2>3.1.2 序列极限的性质</h2><article>a.一般性质 我们在这里总结数列的一组性质，但将来可以看到，这些性质并非数列所独有。只取一个值的数列称为常数列。
定义 4. 数列 \{x_n\} 称为 最终常数列，如果存在数 A 与序号 N ，使得对于任意 n > N ，均有 x_n = A 。
1. ε-接近性 (ε-approximation)：
定义 4.3.4 中表述的是：给定 \epsilon > 0 ，两个实数 x, y 当 |x - y| \leq \epsilon 时称为 ε-接近的。
这一层面只有两点之间的距离概念，是最基本的“接近”定义。
2. ε-稳定性 (ε-stability)：
定义 5.1.3 中谈到序列 (a_n)_{n=0}^\infty 的 ε-稳定。序列是 ε-稳定的，意味着该序列中的任意两个元素 a_j, a_k （无论下标多大），都有 |a_j - a_k| \leq \epsilon 。
换句话说，一个 ε-稳定的序列整体上“被压缩在一个 ε-宽度的间隔中”。不仅仅是相邻项或者后期的项接近，而是整数序列的任意两项都足够接近。这是一个很强的条件，通常只有非常特殊的序列才能全局达到这一点（例如常数序列）。
注意：ε-稳定性并没有提及“从某项开始”或“最终”这种概念，它是对整个序列的要求。
3. 最终ε-稳定性 (eventual ε-stability)：
定义 5.1.6 提到了最终 ε-稳定的概念。一个序列最终 ε-稳定是指：存在某个 N 使得序列从第 N 项开始（即尾部子序列 a_N, a_{N+1}, a_{N+2}, \dots ）是 ε-稳定的。</article><div>Read More</div></a></li><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/3.1/><h2>3.1 序列的极限</h2><article>定义 1.（序列） 定义域为自然数集的函数 f : \mathbb{N} \to X 称为序列。
函数 f(n) 的值 f(n) 称为 序列的项。通常用集合 X 的元素所对应的符号来表示序列的项，并让自变量对应的符号作为其下标： x_n := f(n) 。因此，我们用符号 \{ x_n \} 来表示序列本身，有时也把它写为 x_1, x_2, \dots, x_n, \dots 的形式，并称之为 集合 X 中的序列 或 集合 X 的元素序列。
元素 x_n 称为序列的第 n 项。
在下面几节中，我们只讨论实数列 f : \mathbb{N} \to \mathbb{R} 。
定义 2.（序列的极限） 数 A\in \mathbb{R} 数列 \{ x_n \} 的极限，如果对于点 A 的任何一个领域 V(A) ，都存在序号 N （其选取与 V(A) 有关），使得数列中所有序号大于 N 的项都包含在点 A 的上述邻域 V(A) 中。</article><div>Read More</div></a></li></ul></div><div class=comments data-articleurl=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><script src=/js/footnotes.js></script><footer class=dark><nav><ul><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li><li><a href></a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>