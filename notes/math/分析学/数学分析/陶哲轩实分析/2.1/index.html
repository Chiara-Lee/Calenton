<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content="定义 3.1.1（非正式的）（集合）
我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \{3,8,5,2\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\in A ，否则，记作 x\notin A 。
这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。
首先阐明一个观点：我们把集合本身看作一类对象。
公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。
到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \in A 是无定义的。例如， 3 \in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。）
接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合 \{3, 8, 5, 2\} 与 \{2, 3, 5, 8\} 看作同一个集合。另外， \{3, 8, 5, 2\} 与 \{3, 8, 5, 2, 1\} 是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素 1 。基于类似的原因， \{3, 8, 5, 2\} 与 \{3, 8, 5\} 也是不同的集合。我们把这部分内容作为一个定义。"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>3.1 基础知识</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/computer-science-and-technology/>Cst</a></li><li><a href=/notes/math/>Math</a></li><li><a href=/notes/physcis/>Physics</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>3.1 基础知识</h1><h2>Table of Contents</h2><nav id=TableOfContents></nav><div class=content-wrapper><div class=content><p><strong>定义 3.1.1（非正式的）</strong>（集合）</p><p>我们把 <strong>集合 A</strong> 定义为任意的一堆没有次序的对象。例如，
<span class=fallback-latex>\{3,8,5,2\}
</span>是一个集合。如果
<span class=fallback-latex>x
</span>是这堆对象中的一个，那么我们称 <strong><span class=fallback-latex>x
</span>是
<span class=fallback-latex>A
</span>中的一个元素</strong> ，记作
<span class=fallback-latex>x\in A
</span>，否则，记作
<span class=fallback-latex>x\notin A
</span>。</p><p>这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。</p><p>首先阐明一个观点：我们把集合本身看作一类对象。</p><p><strong>公理 3.1（集合是对象）</strong> 如果
<span class=fallback-latex>A
</span>是一个集合，那么
<span class=fallback-latex>A
</span>也是一个对象。特别地，给定两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>，问
<span class=fallback-latex>A
</span>是不是
<span class=fallback-latex>B
</span>中的元素是有意义的。</p><p>到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果
<span class=fallback-latex>x
</span>是一个对象，
<span class=fallback-latex>A
</span>是一个集合，那么
<span class=fallback-latex>x \in A
</span>要么为真，要么为假。（如果
<span class=fallback-latex>A
</span>不是集合，则我们认为
<span class=fallback-latex>x \in A
</span>是无定义的。例如，
<span class=fallback-latex>3 \in 4
</span>既非真也非假，该命题是无意义的，因为
<span class=fallback-latex>4
</span>不是一个集合。）</p><p>接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{2, 3, 5, 8\}
</span>看作同一个集合。另外，
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{3, 8, 5, 2, 1\}
</span>是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素
<span class=fallback-latex>1
</span>。基于类似的原因，
<span class=fallback-latex>\{3, 8, 5, 2\}
</span>与
<span class=fallback-latex>\{3, 8, 5\}
</span>也是不同的集合。我们把这部分内容作为一个定义。</p><p><strong>定义 3.1.4（集合的相等）</strong> 称两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>是相等的，即
<span class=fallback-latex>A = B
</span>，当且仅当
<span class=fallback-latex>A
</span>中的每个元素都是
<span class=fallback-latex>B
</span>中的元素并且
<span class=fallback-latex>B
</span>中的每一个元素也都是
<span class=fallback-latex>A
</span>中的元素。也就是说，
<span class=fallback-latex>A = B
</span>，当且仅当
<span class=fallback-latex>A
</span>中的任一元素
<span class=fallback-latex>x
</span>属于
<span class=fallback-latex>B
</span>，同时
<span class=fallback-latex>B
</span>中的任一元素
<span class=fallback-latex>y
</span>也属于
<span class=fallback-latex>A
</span>，这记为
<span class=fallback-latex>(\forall x \in A, x \in B),(\forall y \in B, y \in A)</span></p><p>相等是如何定义的取决于所考察对象的类型，而且从某种程度上来说，这只不过是一个关于下定义的问题而已。然而，从逻辑学的角度来说，我们要求相等遵守下面四条 <strong>相等公理</strong> ：</p><ul><li><strong>（自反公理）</strong> 给定任意的对象
<span class=fallback-latex>x
</span>，我们有
<span class=fallback-latex>x = x
</span>。</li><li><strong>（对称公理）</strong> 给定任意两个同类型的对象
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>y
</span>，如果
<span class=fallback-latex>x = y
</span>，那么
<span class=fallback-latex>y = x
</span>。</li><li><strong>（传递公理）</strong> 给定任意三个同类型的对象
<span class=fallback-latex>x
</span>、
<span class=fallback-latex>y
</span>和
<span class=fallback-latex>z
</span>，若
<span class=fallback-latex>x = y
</span>且
<span class=fallback-latex>y = z
</span>，则
<span class=fallback-latex>x = z
</span>。</li><li><strong>（替换公理）</strong> 给定任意两个同类型的对象
<span class=fallback-latex>x
</span>和
<span class=fallback-latex>y
</span>，如果
<span class=fallback-latex>x = y
</span>，那么对任意一个函数或者运算
<span class=fallback-latex>f
</span>都有
<span class=fallback-latex>f(x) = f(y)
</span>。类似地，对任意一个关于
<span class=fallback-latex>x
</span>的性质
<span class=fallback-latex>P(x)
</span>，如果
<span class=fallback-latex>x = y
</span>，那么
<span class=fallback-latex>P(x)
</span>和
<span class=fallback-latex>P(y)
</span>就是等价的命题。</li></ul><p>容易验证，定义3.1.4满足自反、对称、传递三个性质。</p><p><strong>自反性（Reflexive）:</strong>
<span class=fallback-latex>(\forall x \in A, x \in A) \Rightarrow A = A</span></p><p><strong>对称性（Symmetric）:</strong>
<span class=fallback-latex>(A = B) \Rightarrow (\forall x \in A, x \in B) \land (\forall x \in B, x \in A) \Rightarrow B = A</span></p><p><strong>传递性（Transitive）:</strong>
<span class=fallback-latex>(A = B) \land (B = C) \Rightarrow (\forall x \in A, x \in B) \land (\forall x \in B, x \in C) \Rightarrow (\forall x \in A, x \in C)</span></p><span class=fallback-latex>(A = B) \land (B = C) \Rightarrow (\forall x \in B, x \in A) \land (\forall x \in C, x \in B) \Rightarrow (\forall x \in C, x \in A)
</span><span class=fallback-latex>\text{以上两种情况同时成立，这意味着 } A = C</span><p>根据定义 3.1.4 观察可知，如果
<span class=fallback-latex>x \in A
</span>并且
<span class=fallback-latex>A = B
</span>，那么
<span class=fallback-latex>x \in B
</span>。于是 “是……的元素” 这种
<span class=fallback-latex>\in
</span>关系遵守替换公理。正因如此，只要我们能够把定义在集合上的新运算仅用
<span class=fallback-latex>\in
</span>的语言来描述，这个新运算就会遵守替换公理。例如，对于本节中剩下的定义，情况就是这样。（另外，在良好的定义方式中，我们不能使用集合中 “第一个” 或者 “最后一个” 元素这样的概念，因为这将违背替换公理。例如，虽然集合
<span class=fallback-latex>\{1, 2, 3, 4, 5\}
</span>与
<span class=fallback-latex>\{3, 4, 2, 1, 5\}
</span>表示同一个集合，但是它们的第一个元素是不一样的。）</p><p>面我们来讨论到底什么样的对象是集合，什么样的对象不是集合。</p><p>这与上一章中我们如何定义自然数相类似。我们从单个的自然数
<span class=fallback-latex>0
</span>开始，利用增量运算从
<span class=fallback-latex>0
</span>中构造出更多的数。</p><p>这里我们将尝试做类似的事情，从单个集合（空集）开始，利用各种运算从空集中构造出更多的集合。我们首先假定空集的存在性。</p><p><strong>公理 3.2 (空集)</strong> 存在一个集合
<span class=fallback-latex>\varnothing
</span>，被称为<strong>空集</strong>，它不包含任何元素。也就是说，对于任意的对象
<span class=fallback-latex>x
</span>均有
<span class=fallback-latex>x\notin\varnothing
</span>。</p><p>空集也记作
<span class=fallback-latex>{}
</span>。注意只能有一个空集，如果存在两个集合
<span class=fallback-latex>\varnothing
</span>和
<span class=fallback-latex>\varnothing'
</span>都是空集，那么根据定义3.1.4 （集合的相等）可知，它们必定相等。</p><p>如果一个集合不等于空集，那么称该集合是非空的。下面这个命题非常简单，却值得叙述。</p><p><strong>引理 3.1.6（单个选取）</strong> 设
<span class=fallback-latex>A
</span>是一个非空集合，那么存在一个对象
<span class=fallback-latex>x
</span>使得
<span class=fallback-latex>x \in A
</span>。</p><p><strong>证明：</strong> 我们用反证法来证明。假设不存在任何对象
<span class=fallback-latex>x
</span>使得
<span class=fallback-latex>x \in A
</span>，那么对任意一个对象
<span class=fallback-latex>x
</span>而言，有
<span class=fallback-latex>x \notin A
</span>。另外根据公理 3.2 (空集)可知：
<span class=fallback-latex>x \notin \varnothing
</span>。于是
<span class=fallback-latex>x \in A \iff x \in \varnothing
</span>（这两个命题均为假），进而根据定义 3.1.4 (集合的相等)有
<span class=fallback-latex>A = \varnothing
</span>，显然这与已知条件“
<span class=fallback-latex>A
</span>是一个非空集合”相矛盾。</p><p>注 3.1.7 上述引理断言，给定任意一个非空集合
<span class=fallback-latex>A
</span>，我们可以“选取”
<span class=fallback-latex>A
</span>中的一个元素
<span class=fallback-latex>x
</span>，以此来证实
<span class=fallback-latex>A
</span>的非空性。</p><p>后面（在引理 3.5.12 中）我们将证明对于给定的任意有限多个非空集合
<span class=fallback-latex>A_1, \cdots, A_n
</span>，能够从每个集合
<span class=fallback-latex>A_1, \cdots, A_n
</span>中分别选取一个元素
<span class=fallback-latex>x_1, \cdots, x_n
</span>，这称作“有限选取”。**但是如果想要从无穷多个集合中选取元素，我们就需要另一个公理，即选择公理。**关于选择公理的讨论将留到 8.4 节。</p><p>如果公理 3.2 （空集）是集合论中唯一一个公理，那么集合论必然相当乏味，因为在这种情况下，只有唯一一个集合存在，那就是空集。现在我们给出更深层次的公理来丰富可用集合的种类。</p><p><strong>公理 3.3（单元素集与双元素集）</strong></p><p>如果
<span class=fallback-latex>a
</span>是一个对象，那么存在一个集合
<span class=fallback-latex>\{a\}
</span>并且该集合中唯一的一个元素就是
<span class=fallback-latex>a
</span>。也就是说，对于任意一个对象
<span class=fallback-latex>y
</span>，我们有
<span class=fallback-latex>y \in \{a\}
</span>，当且仅当
<span class=fallback-latex>y=a
</span>；我们称
<span class=fallback-latex>\{a\}
</span>是元素为
<span class=fallback-latex>a
</span>的 <strong>单元素集</strong>。</p><p>更进一步地，如果
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>都是对象，那么存在一个集合
<span class=fallback-latex>\{a, b\}
</span>，并且该集合的元素只有
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>。换言之，对于任何一个对象
<span class=fallback-latex>y
</span>，有
<span class=fallback-latex>y \in \{a,b\}
</span>，当且仅当，
<span class=fallback-latex>y=a
</span>或者
<span class=fallback-latex>y=b
</span>，我们称该集合是由
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>所组成的<strong>双元素集。</strong></p><p>注 3.1.9 正如只存在唯一一个空集那样，根据定义 3.1.4 （集合的相等）可知，元素为
<span class=fallback-latex>a
</span>的单元素集也只有一个。类似地，给定任意两个对象
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>，那么只存在唯一一个由
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>构成的双元素集。同样，定义 3.1.4 （集合的相等）也能确保
<span class=fallback-latex>\{a, b\} = \{b, a\}
</span>以及
<span class=fallback-latex>\{a, a\} = \{a\}
</span>。于是，单元素集公理事实上是多余的，因为它是从双元素集公理中推导出的一个结论。反过来，双元素集公理可以由单元素集公理以及后面的两集合并集公理推出（参见引理 3.1.13）。人们可能会问为什么我们不继续构造三元素集公理、四元素集公理等；然而，一旦我们引入下面的两集合并集公理，就没有必要再去构造这些公理了。</p><p>目前为止，我们构造的每一个集合所包含的元素个数都不超过两个。接下来这个公理将让我们能够构造出比之前稍大一些的集合。</p><p>**公理 3.4（两集合并集）**给定任意两个集合
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>，存在一个集合
<span class=fallback-latex>A \cup B
</span>被称为
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的 <strong>并集</strong>，该集合的元素由属于
<span class=fallback-latex>A
</span>的或者属于
<span class=fallback-latex>B
</span>的或者同时属于
<span class=fallback-latex>A
</span>和
<span class=fallback-latex>B
</span>的所有元素共同构成。换言之，对任意的对象
<span class=fallback-latex>x
</span>，</p><span class=fallback-latex>x \in A \cup B \iff (x \in A \text{ 或 } x \in B)</span><p>回忆一下，“或”在数学中默认表示 <strong>包含</strong>，也可以说，<strong>“
<span class=fallback-latex>X
</span>或
<span class=fallback-latex>Y
</span>为真”</strong> 是指 <strong>“要么
<span class=fallback-latex>X
</span>为真，要么
<span class=fallback-latex>Y
</span>为真，要么
<span class=fallback-latex>X
</span>和
<span class=fallback-latex>Y
</span>都为真”。</strong> 参见 A.1 节。</p><p>例 3.1.11 集合
<span class=fallback-latex>\{1,2\} \cup \{2,3\}
</span>中的元素是由属于
<span class=fallback-latex>\{1,2\}
</span>的或者属于
<span class=fallback-latex>\{2,3\}
</span>的或者同时属于这两个集合的一切元素共同构成的；换言之，这个集合的元素就是 1、2 和 3。因此，我们把该集合记作
<span class=fallback-latex>\{1,2\} \cup \{2,3\} = \{1,2,3\}
</span>。</p><p>注 3.1.12 如果
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>和
<span class=fallback-latex>A'
</span>都是集合并且
<span class=fallback-latex>A
</span>等于
<span class=fallback-latex>A'
</span>，那么
<span class=fallback-latex>A \cup B
</span>等于
<span class=fallback-latex>A' \cup B
</span>。</p><p><strong>证明：</strong></p><p>步骤 1: 证明
<span class=fallback-latex>A \cup B \subseteq A' \cup B</span></p><p>假设
<span class=fallback-latex>x \in A \cup B
</span>。根据并集的定义，
<span class=fallback-latex>x \in A \cup B
</span>意味着
<span class=fallback-latex>x \in A
</span>或者
<span class=fallback-latex>x \in B
</span>。</p><ul><li>如果
<span class=fallback-latex>x \in A
</span>，由于
<span class=fallback-latex>A = A'
</span>，因此
<span class=fallback-latex>x \in A'
</span>，所以
<span class=fallback-latex>x \in A' \cup B
</span>。</li><li>如果
<span class=fallback-latex>x \in B
</span>，显然
<span class=fallback-latex>x \in A' \cup B
</span>（因为
<span class=fallback-latex>x \in B
</span>）。</li></ul><p>因此，
<span class=fallback-latex>x \in A' \cup B
</span>。从而，我们得出
<span class=fallback-latex>A \cup B \subseteq A' \cup B
</span>。</p><p>步骤 2: 证明
<span class=fallback-latex>A' \cup B \subseteq A \cup B</span></p><p>假设
<span class=fallback-latex>x \in A' \cup B
</span>。根据并集的定义，
<span class=fallback-latex>x \in A' \cup B
</span>意味着
<span class=fallback-latex>x \in A'
</span>或者
<span class=fallback-latex>x \in B
</span>。</p><ul><li>如果
<span class=fallback-latex>x \in A'
</span>，由于
<span class=fallback-latex>A = A'
</span>，因此
<span class=fallback-latex>x \in A
</span>，所以
<span class=fallback-latex>x \in A \cup B
</span>。</li><li>如果
<span class=fallback-latex>x \in B
</span>，显然
<span class=fallback-latex>x \in A \cup B
</span>（因为
<span class=fallback-latex>x \in B
</span>）。</li></ul><p>因此，
<span class=fallback-latex>x \in A \cup B
</span>。从而，我们得出
<span class=fallback-latex>A' \cup B \subseteq A \cup B
</span>。</p><p>结论:</p><p>由步骤 1 和步骤 2，我们得出
<span class=fallback-latex>A \cup B = A' \cup B
</span>。
<span class=fallback-latex>\square</span></p><p>虽然以上证明显式的写出了尚未定义的集合之间的属于关系，但实际上，我们完全可以删掉这些属于号，而只使用
<span class=fallback-latex>(\forall x \in A, x \in B),(\forall y \in B, y \in A)
</span>这种写法，上述证明过程仍然成立，因此，该证明过程使用到的只有集合相等定义和并集公理。</p><p>类似地，如果
<span class=fallback-latex>B'
</span>是与
<span class=fallback-latex>B
</span>相等的集合，那么
<span class=fallback-latex>A \cup B
</span>等于
<span class=fallback-latex>A \cup B'
</span>。因此，求并运算遵守替换公理，从而该运算在集合上是定义明确的。</p><p>现在我们给出并集的一些基本性质。</p><p>引理 3.1.13 如果
<span class=fallback-latex>a
</span>和
<span class=fallback-latex>b
</span>都是对象，那么
<span class=fallback-latex>\{a, b\} = \{a\} \cup \{b\}
</span>。如果
<span class=fallback-latex>A
</span>、
<span class=fallback-latex>B
</span>和
<span class=fallback-latex>C
</span>都是集合，那么求并运算是可交换的（即
<span class=fallback-latex>A \cup B = B \cup A
</span>），而且也是可结合的（即
<span class=fallback-latex>(A \cup B) \cup C = A \cup (B \cup C)
</span>）。另外，我们有
<span class=fallback-latex>A \cup A = A \cup \emptyset = \emptyset \cup A = A
</span>。</p></div><aside class=sidebar><div class=card><h2>摘要</h2><p>定义 3.1.1（非正式的）（集合）
我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \{3,8,5,2\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A …</p></div><div class=card><h2>阅读时长</h2><p>5 min</p></div><div class=card><h2>总字数</h2><p>≈ 895</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
数学分析</a></p></div></aside></div></div></main><div id=related><h2>Related Pages</h2><ul class=posts><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.3/><h2>2.3 乘法</h2><article>在上一节中，我们已经证明了所知道的所有关于加法和序的基本事实。为了节省篇幅以及避免赘述那些显然的事情，接下来我们将允许使用所熟悉的关于加法和序的代数法则，而不加进一步的说明。于是我们可以写出 a+b+c=c+b+a 这样的内容，不需要进一步解释说明。现在我们引入乘法。正如加法是重复的增量运算一样，乘法是重复的加法运算。
定义 2.3.1（自然数的乘法）
令 m 表示任意一个自然数，
我们定义 0\times m:= 0 来表示将 0 乘到 m 上。现在归纳假设我们已经定义了 n\times m （即把 n 乘到 m 上）。
那么，我们可以定义
(n++)\times m:= (n\times m)+m 以上，我们就定义好了自然数的乘法规则。
引理 2.3.2 （乘法是可交换的） 令 n 和 m 表示任意两个自然数，那么有 n\times m=m\times n 成立。
证明： 使用数学归纳法。
首先我们需要证明 m\times 0= 0 。当 m=0 时，我们有
0\times 0:= 0 归纳假设当 m=m 时 m\times 0= 0 是成立的，那么现在我们来证明 m=m++ 时等式成立。
\begin{align} (m++)\times 0&=(m\times 0)+0[(n++)\times m:= (n\times m)+m]\\ &=0 \end{align} 以上，我们就得到了基础情况 0\times m=m\times 0 。</article><div>Read More</div></a></li><li class=post><a href=https://chiara-lee.netlify.app/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/><h2>2.2 加法和归纳原理的两个变体</h2><article>目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。
具体做法如下：
5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。
定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：
0+m:=m 现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为
(n++)+m:=(n+m)++ 于是， 0+m 就是 m， 1+m 就是 (0++)+m=(0+m)++=m++ ， 2+m 就是 (1++)+m=(1+m)++=(m++)++ ，以此类推。例如：
2+m=(1++)+m=(1+m)++=(m++)++\\ 2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\ 根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。</article><div>Read More</div></a></li></ul></div><div class=comments data-articleurl=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><footer class=dark><nav><ul><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li><li><a href></a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>