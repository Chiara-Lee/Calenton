<!doctype html><html lang=zh><head><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><meta charset=UTF-8><meta name=description content="在学习实数分析之前，我们首先要回溯数的概念以及数的性质。
我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?
实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。
现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。
自然数集定义 定义 2.1.1 （非正式的）自然数是集合
N := \{ 0, 1, 2, 3, \cdots \} 的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。
注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \{1, 2, 3, \cdots \} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。
从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：
N 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？
我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？
我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：
a^3 = a \cdot a \cdot a 。
乘法运算只不过是对加法运算的重复迭代：
3 \cdot a = a + a + a 。"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png href=https://chiara-lee.netlify.app/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=/css/categories.css><link rel=stylesheet href=/css/comment.css><link rel=stylesheet href=/css/page-main.css><link rel=stylesheet href=/css/pagination.css><link rel=stylesheet href=/css/profile-card.css><link rel=stylesheet href=/css/relative.css><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/about.css><link rel=stylesheet href=/css/post-card.css><link rel=stylesheet href=/css/markdown.css><link rel=stylesheet href=/css/friends.css><link rel=stylesheet href=/css/latex.css><title>2.1 皮亚诺公理</title>
<script type=text/javascript src=/index.js defer></script></head><body class=page><header><a href=/><img src=https://chiara-lee.netlify.app//image/logo.png alt="Calenton Logo" style=width:180px;height:160px>
Caleton Academy
</a><span id=search><input type=search placeholder=Search><div></div></span><nav><button class=hamburger>&#9776;</button><ul><li><a href=/notes>笔记</a><ul><li><a href=/notes/physcis/>Physics</a></li><li><a href=/notes/math/>Math</a></li><li><a href=/notes/computer-science-and-technology/>Cst</a></li></ul></li><li><a href=/thoughts>思考碎片</a></li><li><a href=/friends>友人帐</a></li><li><a href=/about>关于</a></li></ul></nav></header><main><h1>2.1 皮亚诺公理</h1><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#自然数集定义>自然数集定义</a></li><li><a href=#加法和增量运算>加法和增量运算</a></li><li><a href=#公理21--定义213-定义自然数集的具体元素>公理2.1 ~ 定义2.1.3 定义自然数集的具体元素</a></li><li><a href=#公理23--公理25-定义自然数系的具体性质>公理2.3 ~ 公理2.5 定义自然数系的具体性质</a></li><li><a href=#递归定义>递归定义</a></li><li><a href=#总结>总结</a><ul><li><a href=#公理假设>公理假设</a></li><li><a href=#五条皮亚诺公理>五条皮亚诺公理</a></li><li><a href=#解释与扩展>解释与扩展</a></li><li><a href=#递归定义-1>递归定义</a></li><li><a href=#数学基础中的地位>数学基础中的地位</a></li></ul></li></ul></nav><div class=content-wrapper><div class=content><p>在学习实数分析之前，我们首先要回溯数的概念以及数的性质。</p><p>我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于
<span class=fallback-latex>a(b+c)=ab+ac
</span>为什么总是成立的?</p><p>实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题<strong>为什么</strong>是显然的。</p><hr><p>现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。</p><h2 id=自然数集定义>自然数集定义</h2><p><strong>定义 2.1.1 （非正式的）自然数是集合</strong></p><span class=fallback-latex>N := \{ 0, 1, 2, 3, \cdots \}</span><p>的元素。其中，集合是从
<span class=fallback-latex>0
</span>开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称
<span class=fallback-latex>N
</span>为自然数集。</p><p><strong>注 2.1.2</strong> 在有些教材中，自然数被定义为从
<span class=fallback-latex>1
</span>而不是
<span class=fallback-latex>0
</span>开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合
<span class=fallback-latex>\{1, 2, 3, \cdots \}
</span>为<strong>正整数集</strong>，并记为
<span class=fallback-latex>Z^+
</span>，而不是自然数集。自然数有时候也被称为<strong>完整数</strong>（whole number）。</p><p>从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合
<span class=fallback-latex>N
</span>中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：</p><p><strong><span class=fallback-latex>N
</span>到底是什么？</strong>“从
<span class=fallback-latex>0
</span>开始，无休止的计数”看起来好像是对
<span class=fallback-latex>N
</span>的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到
<span class=fallback-latex>0
</span>的情景？我们应当怎样在上述定义之下构造出一个系列的计算？</p><p>我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？</p><p>我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：<br><span class=fallback-latex>a^3 = a \cdot a \cdot a
</span>。<br>乘法运算只不过是对加法运算的重复迭代：<br><span class=fallback-latex>3 \cdot a = a + a + a
</span>。<br>（由于减法和除法运算并不完全适用于自然数的运算，因此我们暂不讨论。我们在整数数和有理数对应的章节时，会对这些运算进行讨论。）</p><h2 id=加法和增量运算>加法和增量运算</h2><p>那么<strong>加法</strong>又是怎么定义的呢？加法就是<strong>重复往前计数</strong>或者<strong>不断增加的运算</strong>。</p><p>如果你把
<span class=fallback-latex>5
</span>加上
<span class=fallback-latex>3
</span>，也就是使得
<span class=fallback-latex>5
</span>增长了三次。另外，增长看起来是一个基本的运算，它不能再被拆解为更加简单的运算。</p><p>于是，为了定义自然数，我们将使用如下两个基本概念：<strong>数
<span class=fallback-latex>0
</span>和增量运算</strong>。我们使用
<span class=fallback-latex>n++
</span>来表示
<span class=fallback-latex>n
</span>的增量或者紧跟在
<span class=fallback-latex>n
</span>后面的数字。例如：
<span class=fallback-latex>3++ = 4, (3++)++ = 5
</span>。<br>注意，这与计算机的语言不同，在数学中，我们对一个变量只赋值一次。</p><p>因此，这看起来就似乎说明
<span class=fallback-latex>N
</span>是由
<span class=fallback-latex>0
</span>以及所有能通过增量运算由
<span class=fallback-latex>0
</span>得到的数构成的。这就是
<span class=fallback-latex>N
</span>应该如下对象构成的：</p><span class=fallback-latex>0, 0++, (0++)++, \cdots</span><p>如果我们把自然数用上述对象来表示，那么得到了如下关于
<span class=fallback-latex>0
</span>和增量运算的公理。</p><h2 id=公理21--定义213-定义自然数集的具体元素>公理2.1 ~ 定义2.1.3 定义自然数集的具体元素</h2><p><strong>公理 2.1</strong>
<span class=fallback-latex>0
</span>是自然数。</p><p><strong>公理 2.2</strong> 如果
<span class=fallback-latex>n
</span>是自然数，那么
<span class=fallback-latex>n++
</span>也是自然数。</p><p>于是，举例来说，我们能通过公理2.1和公理2.2，可以推的
<span class=fallback-latex>(0++)++
</span>是一个自然数。为了计数书写的方便，我们又有如下的定义。</p><p><strong>定义 2.1.3</strong><br>我们定义1为数
<span class=fallback-latex>0++
</span>，2为数
<span class=fallback-latex>(0++)++
</span>等等。</p><p>于是，举例来说，我们有：</p><p><strong>命题 2.1.4</strong> 3 是一个自然数</p><p><strong>proof</strong>:<br>根据公理2.1可知，
<span class=fallback-latex>0
</span>是一个自然数。根据公理2.2，
<span class=fallback-latex>0++ = 1
</span>是一个自然数。又根据公理2.2，
<span class=fallback-latex>1++ = 2
</span>也是自然数，那么再通过依序公理2.2，
<span class=fallback-latex>2++ = 3
</span>自然也是自然数。</p><p>目前看来，我们对自然数已经有了充分的描述，但对于
<span class=fallback-latex>N
</span>的性质尚未彻底厘清。</p><h2 id=公理23--公理25-定义自然数系的具体性质>公理2.3 ~ 公理2.5 定义自然数系的具体性质</h2><p>虽然我们定义了
<span class=fallback-latex>0
</span>和增量运算，并打算以此来构建自然数系，但是我们并没有对自然数系的性质做出规定。例如我们目前没有方法确定定义的自然数系会不会出现循环的情况，即</p><span class=fallback-latex>0++ = 1, \, 1++ = 2, \, 2++ = 3, \, 3++ = 0</span><p>为了防止以上这种循环情况的产生，我们将引入另外的公理。</p><p><strong>公理 2.3</strong><br><span class=fallback-latex>0
</span>不紧跟在任何自然数之后。换言之，对于任意一个自然数
<span class=fallback-latex>n
</span>，
<span class=fallback-latex>n++ \neq 0
</span>均成立。</p><p>如此一来，我们就有防止循环情况出现的工具了。</p><p><strong>命题 2.1.6</strong>
<span class=fallback-latex>4 \neq 0</span></p><p><strong>proof</strong>:<br>根据定义
<span class=fallback-latex>4 = 3++
</span>，根据公理2.1和公理2.2，可知
<span class=fallback-latex>3
</span>是一个自然数，故根据公理2.2，
<span class=fallback-latex>4
</span>也是一个自然数，再根据公理2.3，我们就有
<span class=fallback-latex>3++ = 4 \neq 0
</span>。</p><p>除此之外，我们还需要对其他的性质进行研究和规定，否则我们的数系仍然会存在很多病态的性质。</p><p><strong>例 2.1.7</strong><br>考虑由
<span class=fallback-latex>0, 1, 2, 3, 4
</span>构成的数系。在这个数系里，增量运算在遇到
<span class=fallback-latex>4
</span>时达到了运算的极限。换言之，在这个数系里<br><span class=fallback-latex>0++ = 1, \, 1++ = 2, \, 2++ = 3, \, 3++ = 4, \, 4++ = 4</span><br>（换言之，也就是
<span class=fallback-latex>5 = 4++ = 4, 7 = 4++ = 4
</span>）。这种情况并不违背我们上面规定的任何公理或者定义，甚至，我们虽然防止了我们的自然数系出现绕回到
<span class=fallback-latex>0
</span>的情况，但它仍然可以绕回到
<span class=fallback-latex>1, 2
</span>等其他自然数。</p><p>有许多的方法可以阻止这些情况发生，最简单的方法是设定下面的公理成立。</p><p><strong>公理 2.4</strong><br>对于不同的自然数而言，紧跟在它们之后的数字也必然不同。也就是说，如果
<span class=fallback-latex>n
</span>和
<span class=fallback-latex>m
</span>都是自然数，并且
<span class=fallback-latex>n \neq m
</span>，那么
<span class=fallback-latex>n++ \neq m++
</span>。<br>等价地说，如果
<span class=fallback-latex>n++ = m++
</span>，则
<span class=fallback-latex>n = m
</span>。</p><p><strong>命题 2.1.8</strong> 6 不等于 2</p><p><strong>proof</strong>:<br><strong>使用反证法</strong>，假设
<span class=fallback-latex>6 = 2
</span>，那么有
<span class=fallback-latex>5++ = 1++
</span>。根据公理2.4，有
<span class=fallback-latex>5 = 1
</span>，进而有
<span class=fallback-latex>4++ = 0++
</span>。再次利用公理2.4，也就有
<span class=fallback-latex>4 = 0
</span>。在我们的数系中，只有
<span class=fallback-latex>0 \sim 4
</span>这几个数是被定义好的，所有根据我们的规定，
<span class=fallback-latex>4 = 0
</span>与命题2.1.6矛盾，所有我们有结论
<span class=fallback-latex>6 \neq 2
</span>。</p><p>规定了上述的公理后，我们还需要考虑这样的自然数系的元素问题，目前来看，好像所有的自然数都是两两不同的，我们已经确定
<span class=fallback-latex>0, 1, 2, 3, 4, \cdots
</span>是自然数系的不同对象，但是它们之间是否有其他形式的数字存在呢？</p><p><strong>例 2.1.9</strong> （非正式的）<br>假设我们的数系
<span class=fallback-latex>N
</span>是由如下的整数和半整数共同构成的：</p><span class=fallback-latex>N := \{0, 0.5, 1, 1.5, 2, 2.5, \cdots\}</span><p>（该例之所以是非正式的是因为，我们提前使用了实数，但我们现在还没有定义实数。）容易验证，这个例子仍然满足公理2.1~公理2.4。</p><p>为此我们希望有这样一个公理，它告诉我们自然数系的所有元素都可以通过对
<span class=fallback-latex>0
</span>进行增量运算来得到，从而能够从
<span class=fallback-latex>N
</span>中排除像
<span class=fallback-latex>0.5
</span>这种形式的元素。幸运的是，我们有一种巧妙的解决办法达到前述要求：</p><p><strong>公理 2.5 （数学归纳法）</strong><br>令
<span class=fallback-latex>P(n)
</span>表示自然数
<span class=fallback-latex>n
</span>满足的一种任意的性质，如果
<span class=fallback-latex>P(0)
</span>为真并且
<span class=fallback-latex>P(n)
</span>为真时
<span class=fallback-latex>P(n++)
</span>也为真，则对于任意的自然数
<span class=fallback-latex>n
</span>，
<span class=fallback-latex>P(n)
</span>一定为真。</p><p>隐藏在这个公理中的通俗的直观的说明如下：假设
<span class=fallback-latex>P(n)
</span>满足以下条件：
<span class=fallback-latex>P(0)
</span>为真，且
<span class=fallback-latex>P(n)
</span>为真时
<span class=fallback-latex>P(n++)
</span>也为真，那么由于
<span class=fallback-latex>P(0)
</span>为真，所以
<span class=fallback-latex>P(0++) = P(1)
</span>也为真，进而
<span class=fallback-latex>P(1++) = P(2)
</span>也为真，以此类推我们可以得到
<span class=fallback-latex>P(0), P(1), P(2), P(3), \cdots
</span>均为真。</p><p>然而根据这样的规定，我们根本没有定义
<span class=fallback-latex>0.5
</span>这样的元素，因此公理2.5对
<span class=fallback-latex>P(0.5)
</span>是失效的，从而我们就避免了自然数系中出现附带的奇怪对象。</p><p>在公理2.5之上，我们将在习题中给出关于它的其他形式，它们分别是：逆向归纳法、强化归纳法和超限归纳法*（这名字好酷对吧）。</p><p>公理2.1 ~ 公理2.5被称为<strong>皮亚诺公理</strong>，这套公理系统就是定义自然数系的方法之一。为了定义自然数系，我们假设存在一个数系
<span class=fallback-latex>N
</span>，我们称
<span class=fallback-latex>N
</span>中的元素为自然数，而且公理2.1 ~ 公理2.5对
<span class=fallback-latex>N
</span>均成立。</p><p>根据前面的所有规定，我们可以得到以下的这个结论：现在我们可以<strong>递归</strong>的定义序列。</p><hr><h2 id=递归定义>递归定义</h2><p>假设我们通过以下方式来构造数列
<span class=fallback-latex>a_0, a_1, a_2, \cdots
</span>：首先定义
<span class=fallback-latex>a_0
</span>的基值。例如，令
<span class=fallback-latex>a_0 = c
</span>，其中
<span class=fallback-latex>c
</span>是一个固定的数字。然后令
<span class=fallback-latex>a_1
</span>为关于
<span class=fallback-latex>a_0
</span>的某个函数：
<span class=fallback-latex>a_1 := f_0(a_0)
</span>，令
<span class=fallback-latex>a_2
</span>为关于
<span class=fallback-latex>a_1
</span>的某个函数：
<span class=fallback-latex>a_2 := f_1(a_1)
</span>。以此类推，一般地，我们记
<span class=fallback-latex>a_{n++} := f_n(a_n)
</span>，其中
<span class=fallback-latex>f_n
</span>是
<span class=fallback-latex>N \to N
</span>的某个函数。利用前面的公理可以推出，对于任意给定的自然数
<span class=fallback-latex>n
</span>，上述过程将对应数列中的元素
<span class=fallback-latex>a_n
</span>给出唯一的值。</p><p>更准确的说：</p><p><strong>命题 2.1.10 （递归定义）</strong><br>假设对于任何自然数
<span class=fallback-latex>n
</span>，都存在从自然数系到自然数系的函数
<span class=fallback-latex>f_n: N \to N
</span>，令
<span class=fallback-latex>c
</span>为某个固定的自然数，那么对于任意的自然数
<span class=fallback-latex>n
</span>，都可以唯一确定自然数
<span class=fallback-latex>a_n
</span>，使得
<span class=fallback-latex>a_0 = c
</span>以及
<span class=fallback-latex>a_{n++} = f_n(a_n)
</span>恒成立。</p><p><strong>proof</strong>:<br>利用归纳法。首先，根据题设，我们有
<span class=fallback-latex>a_0 = c
</span>。假设，题设的过程对
<span class=fallback-latex>a_m
</span>赋予了单一的值，由于公理2.3（
<span class=fallback-latex>n++ \neq 0
</span>）和公理2.4（
<span class=fallback-latex>n++ \neq m++ \iff n \neq m
</span>），可知上述过程
<span class=fallback-latex>a_{n++} := f_n(a_n)
</span>对
<span class=fallback-latex>a_n
</span>来说是不会改变
<span class=fallback-latex>a_n
</span>的赋值的，因此可知上述过程也同样使得
<span class=fallback-latex>a_{n++}
</span>被唯一赋值了。那么根据数学归纳法，对于任意的自然数
<span class=fallback-latex>n
</span>，
<span class=fallback-latex>a_n
</span>都被定义了，并且每个
<span class=fallback-latex>a_n
</span>都赋予了唯一的值。</p><p>注意所有的公理在这个过程中是如何被应用的。在一个数系中，如果存在某种类型的<strong>绕回状况</strong>，那么递归定义就不适用于该数系。这是因为序列中的某些元素将会连续不断地被重新定义。例如，在例2.1.5中，因为
<span class=fallback-latex>3++ = 0
</span>，所以
<span class=fallback-latex>a_0
</span>（至少）存在两种相矛盾的定义，
<span class=fallback-latex>c
</span>或者
<span class=fallback-latex>f_3(a_3)
</span>。在一个含有多余元素（比如
<span class=fallback-latex>0.5
</span>）的数系中，元素
<span class=fallback-latex>a_{0.5}
</span>将永远不会被定义。</p><p>对于递归定义，我（笔记书写者）的理解是，我们首先固定了
<span class=fallback-latex>a_0 = c
</span>，然后递归的过程是<br><span class=fallback-latex>\begin{aligned}
a_1 & := f_0(a_0), \\
a_2 & := f_1(a_1), \\
a_3 & := f_2(a_2), \\
\text{也就是 } a_3 & := f_2(f_1(f_0(a_0))).
\end{aligned}</span></p><p>所以它就是固定一个对象，然后通过一系列函数的嵌套运算过程给出另一个对象的唯一赋值，通过对递归定义的重复应用，我们就可以定义出一系列对象，从而组成一个序列。</p><p>一个简单的示例就是泰勒展开：</p><p>我们知道导数的定义是</p><span class=fallback-latex>\frac{dy}{dx} = \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}</span><p>从图像上讲，也就是说在曲线上的两点
<span class=fallback-latex>(x_0, f(x_0)), (x_0 + \Delta x, f(x_0 + \Delta x))
</span>当横坐标无限靠近时，导数曲线上两点的点成也无限靠近，此时连接两点的直线成为曲线上的切线，两点成为一个切点。在这个切点上，切线与曲线的斜率就是导数的值。</p><p>二阶导数是</p><span class=fallback-latex>\frac{d^2y}{dx^2} = \lim_{\Delta x \to 0} \frac{df(x_0 + \Delta x) - df(x_0)}{\Delta x}.</span><p>也就是说对于原函数<em>曲线</em>，一阶导组成的曲线在
<span class=fallback-latex>(x_0, df(x_0))
</span>,
<span class=fallback-latex>(x_0 + \Delta x, df(x_0 + \Delta x))
</span>切点处的导数，
<span class=fallback-latex>df(x_0)
</span>就是原函数曲线在
<span class=fallback-latex>x_0
</span>和
<span class=fallback-latex>x_0 + \Delta x (\Delta x \to 0)
</span>处的导数，
<span class=fallback-latex>df(x_0 + \Delta x)
</span>就是原函数曲线在
<span class=fallback-latex>x_0 + \Delta x
</span>和
<span class=fallback-latex>x_0 + 2\Delta x (\Delta x \to 0)
</span>处的导数，这在原函数曲线上表现为
<span class=fallback-latex>f(x_0) \sim f(x_0 + \Delta x)(\Delta x \to 0)
</span>，
<span class=fallback-latex>f(x_0 + \Delta x) \sim f(x_0 + 2\Delta x)(\Delta x \to 0)
</span>。这两段相连的曲线，我们知道因为
<span class=fallback-latex>\Delta x \to 0
</span>所以这两段曲线都缩略了两个点，而二阶导就是对这两点之间曲线段的拟合度的衡量。</p><p>以此类推，
<span class=fallback-latex>x_0
</span>处的三阶导、四阶导实际上就是通过对求导这个操作把原函数曲线在
<span class=fallback-latex>x_0
</span>的邻域内的曲线段一遍遍的放大，然后用切线来拟合曲线。</p><p>所以泰勒展开</p><span class=fallback-latex>f(x) = f(x_0) + \frac{f'(x_0)}{1!}(x - x_0) + \frac{f''(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n, \, R_n(x) = o\left((x - x_0)^n\right)</span><p>就是函数
<span class=fallback-latex>f(x)
</span>在
<span class=fallback-latex>x_0
</span>处，通过
<span class=fallback-latex>n
</span>次求导迭代得到的最终拟合的结果。而根据迭代的定义，我们知道这个迭代的拟合的过程中给出的赋值是唯一的，并且我们可以根据迭代次数来构造一个不同次迭代赋值得到的函数值的序列。</p><h2 id=总结>总结</h2><p>总而言之，以下是皮亚诺公理的全部内容：</p><h3 id=公理假设>公理假设</h3><p>皮亚诺公理假设存在一个集合
<span class=fallback-latex>\mathbb{N}
</span>，其元素被称为<strong>自然数</strong>，以及一个称为“后继函数”的映射
<span class=fallback-latex>S: \mathbb{N} \to \mathbb{N}
</span>，满足以下五条公理：</p><h3 id=五条皮亚诺公理>五条皮亚诺公理</h3><ol><li><p><strong>零是自然数</strong>：<br><span class=fallback-latex>0 \in \mathbb{N}.</span><br>（注：有些表述中将
<span class=fallback-latex>0
</span>换为
<span class=fallback-latex>1
</span>，视具体情况而定。）</p></li><li><p><strong>每个自然数都有一个后继</strong>：<br><span class=fallback-latex>\forall n \in \mathbb{N}, S(n) \in \mathbb{N}.</span><br>后继函数
<span class=fallback-latex>S
</span>为每个自然数定义一个唯一的“下一个”自然数。</p></li><li><p><strong>零不是任何自然数的后继</strong>：<br><span class=fallback-latex>\forall n \in \mathbb{N}, S(n) \neq 0.</span><br>这保证了自然数序列是以
<span class=fallback-latex>0
</span>为起点、向后无限延伸的，且没有“前驱”。</p></li><li><p><strong>不同的自然数有不同的后继</strong>（后继函数是单射）：<br><span class=fallback-latex>\forall m, n \in \mathbb{N}, \, S(m) = S(n) \implies m = n.</span><br>这保证了后继函数不会将两个不同的自然数映射到同一个自然数。</p></li><li><p><strong>数学归纳原理</strong>：<br>若一个性质
<span class=fallback-latex>P
</span>满足以下两点：</p><ul><li><span class=fallback-latex>P(0)
</span>成立；</li><li>对任何
<span class=fallback-latex>n \in \mathbb{N}
</span>，如果
<span class=fallback-latex>P(n)
</span>成立，则
<span class=fallback-latex>P(S(n))
</span>也成立，</li></ul><p>则
<span class=fallback-latex>P(n)
</span>对所有
<span class=fallback-latex>n \in \mathbb{N}
</span>成立。</p><p>数学归纳原理确保可以对自然数集合进行递归定义和归纳证明。</p></li></ol><hr><h3 id=解释与扩展>解释与扩展</h3><p>皮亚诺公理定义了自然数的基本结构，其中
<span class=fallback-latex>S
</span>通常被解释为“加 1”操作。例如：</p><ul><li><span class=fallback-latex>S(0)
</span>通常表示
<span class=fallback-latex>1
</span>，</li><li><span class=fallback-latex>S(S(0))
</span>表示
<span class=fallback-latex>2
</span>，以此类推。</li></ul><h3 id=递归定义-1>递归定义</h3><p>通过皮亚诺公理可以递归定义自然数的加法和乘法等运算：</p><ol><li><p><strong>加法定义</strong>：<br><span class=fallback-latex>n + 0 = n, \quad n + S(m) = S(n + m).</span></p></li><li><p><strong>乘法定义</strong>：<br><span class=fallback-latex>n \cdot 0 = 0, \quad n \cdot S(m) = (n \cdot m) + n.</span></p></li></ol><hr><h3 id=数学基础中的地位>数学基础中的地位</h3><p>皮亚诺公理在数学基础中占有重要地位，为数理逻辑、集合论以及模型论等领域提供了形式化的支柱。</p></div><aside class=sidebar><div class=card><h2>摘要</h2><p>在学习实数分析之前，我们首先要回溯数的概念以及数的性质。
我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如， …</p></div><div class=card><h2>阅读时长</h2><p>5 min</p></div><div class=card><h2>总字数</h2><p>≈ 862</p></div><div class=card><h2>标签</h2><p><a href=#><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tag" viewBox="0 0 16 16"><path d="M3 2A1 1 0 002 3v4.586a1 1 0 00.293.707l7 7a1 1 0 001.414.0l4.586-4.586a1 1 0 000-1.414l-7-7A1 1 0 008.586 2H3zm1 1h4.586L14 8.414 9.414 13l-6-6V3z"/><path d="M5.5 5.5a1.5 1.5.0 11-3 0 1.5 1.5.0 013 0z"/></svg>
数学分析</a></p></div></aside></div></div></main><div class=comments data-articleurl=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/><h2>Comments</h2><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832040899-795 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:27:23</span></div><div class=message>评论测试</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832040899-795>Reply</button></div></div><div class=child-comment data-depth=1 style=margin-left:50px!important data-parent=1731832040899-795 data-custom=1731832122014-150 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:28:45</span></div><div class=message>子评论测试</div><button class=reply-button data-parent=1731832040899-795 data-name=Chiara-lee data-custom=1731832122014-150>Reply</button></div></div><div style=clear:both></div><div class=comment data-depth=0 style=margin-left:0!important data-parent data-custom=1731832210679-902 data-articleurl=/notes/test-page/><div class=comment-content style=border-radius:10px;padding:10px><img src="https://www.gravatar.com/avatar/d9dab474cfdb4e177b10b36e239d6fb2?s=100&d=wavatar" alt="Chiara-lee Avatar" style=border-radius:50%;width:50px;height:50px;margin-right:15px><div class=comment-text style=flex:1><div style=display:flex;align-items:center><div class=author style=font-weight:700>Chiara-lee</div><span class=time style=margin-left:10px;color:#888>2024-11-17 08:30:13</span></div><div class=message>评论测试 2.0</div><button class=reply-button data-parent data-name=Chiara-lee data-custom=1731832210679-902>Reply</button></div></div><template id=comment-success><div class=success>您的评论已成功提交审核。(´｡• ᵕ •｡`)</div></template><template id=comment-error><div class=error>啊，好像出了些问题，请您调整后重试。(；′⌒`)</div></template><form id=comment-form data-dynamic-form data-success=#comment-success data-error=#comment-error netlify=true name=Comments method=POST style=margin-top:20px><div id=reply-to style=display:none;color:#6c757d;margin-bottom:10px></div><input type=hidden name=url value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/>
<input type=hidden name=parent id=parent>
<input type=hidden name=custom id=custom>
<input type=hidden name=depth id=depth value=0>
<input type=hidden name=articleurl value=/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/>
<label class=comment-label for=name>Name:</label>
<input class=comment-input type=text id=name name=name required autocomplete=name>
<label class=comment-label for=email>Email:</label>
<input class=comment-input type=email id=email name=email required autocomplete=email>
<label class=comment-label for=comment>Comment:</label>
<textarea class=comment-textarea id=comment name=comment rows=5 required autocomplete=off></textarea>
<button class=comment-button type=submit>Send</button></form></div><script>function generateUniqueId(){return`${Date.now()}-${Math.floor(Math.random()*1e3)}`}document.querySelectorAll(".reply-button").forEach(e=>{e.addEventListener("click",function(){const n=this.closest(".comment"),e=this.getAttribute("data-custom"),s=this.getAttribute("data-name"),o=parseInt(n.getAttribute("data-depth"))||0;document.getElementById("parent").value=e||"",console.log("Parent ID set to:",e);const i=o+1;document.getElementById("depth").value=i;const t=document.getElementById("reply-to");t.style.display="block",t.innerText=`回复 @${s}`,document.querySelectorAll(".comment").forEach(e=>{e.classList.remove("highlight")}),this.closest(".comment").classList.add("highlight")}),document.getElementById("comment-form").scrollIntoView({behavior:"smooth"})}),document.getElementById("comment-form").addEventListener("submit",function(){const t=document.getElementById("custom");t.value||(t.value=generateUniqueId(),console.log("Custom ID set to:",t.value))}),window.onload=function(){const e=document.querySelector(".comments"),n=e.dataset.articleurl.replace(/\/$/,"").toLowerCase(),s=document.querySelector("#comment-form"),o=document.querySelector("footer"),i=Array.from(document.querySelectorAll(".comment, .child-comment")),t=i.filter(e=>{const t=e.dataset.articleurl.replace(/\/$/,"").toLowerCase();return t===n});e.innerHTML="";const a=t.filter(e=>e.dataset.depth==="0");a.forEach(n=>{e.appendChild(n);const s=t.filter(e=>e.dataset.parent===n.dataset.custom);s.forEach(t=>{t.classList.add("child-comment"),e.appendChild(t)})}),e.appendChild(s),e.appendChild(o),e.style.display="none",e.offsetHeight,e.style.display=""}</script><script src=/js/footnotes.js></script><footer class=dark><nav><ul><li><a href=/reference>引用资料列表</a></li><li><a href=/categories>教材索引</a></li><li><a href></a></li></ul></nav><ul><li><a href=https://facebook.com/example aria-label=Facebook><i class=icon-facebook></i></a></li><li><a href=https://x.com/i/flow/login aria-label=Twitter><i class=icon-twitter></i></a></li><li><a href=mailto:chiaralee953@foxmail.com aria-label=email><i class=icon-email></i></a></li></ul><div>Copyright © 2024 Caleton Academy of Magic.</div></footer></body></html>