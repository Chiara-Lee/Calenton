<!DOCTYPE html>
<html lang="zh">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    
      <meta name="description" content="在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：
1 2 3 4 5 6 7 8 /* 示例代码，仅用于展示 */ .example h1 { color: maroon; /* 改变一级标题颜色 */ } .example body { background: yellow; /* 设置背景颜色 */ } 诸如此类的样式共同构成了样式表的主体。
规则的结构 为了更详细的说明规则的概念，让我们分解下代码的结构。
每条规则由两个基本部分组成：选择器（selector）和声明块（declaration block）。声明块包含一个或多个声明（declaration），而每个声明由一个属性（property）和一个值（value）组成。每个样式表都是由这样的一系列规则构成的。图 1-1 展示了规则的各个部分。 选择器位于规则的左侧，用于定义文档中哪些部分将被选中进行样式应用。在图 1-1 中，选择器为 &lt;h1&gt;，表示选择所有一级标题（heading level 1）元素。如果选择器是 p，那么所有段落（&lt;p&gt;）元素将被选中。
规则的右侧是声明块，由一个或多个声明组成。每个声明由一个 CSS 属性和该属性的值组成。在图 1-1 中，声明块包含两个声明。第一个声明指定规则会将文档的某些部分设置为红色文本，第二个声明指定文档的某些部分将有一个黄色背景。因此，文档中的所有 &lt;h1&gt; 元素（由选择器定义）将被设置为红色文本，并带有黄色背景。
供应商前缀（Vendor Prefixing） 有时，您会看到 CSS 的某些部分带有连字符和标签，例如：-o-border-image。这些供应商前缀是浏览器供应商用来标记某些属性、值或其他 CSS 部分为实验性或专有功能（或者两者兼有）的一种方式。截至 2023 年初，仍有一些供应商前缀在使用，其中最常见的如表 1-1 所示。 如表1-1所示，供应商前缀的通用格式通常是连字符、标签和连字符，尽管有几个前缀错误地省略了第一个连字符。
供应商前缀的使用与滥用历史悠久、复杂且超出了本书的范围。简单来说，它们最初的目的是为浏览器供应商提供测试新功能的方式，从而加速互操作性的发展，同时避免被与其他浏览器不兼容的遗留行为所束缚。这避免了一类几乎在 CSS 初期扼杀其发展的问题。然而，不幸的是，这些带前缀的属性随后被网页作者广泛使用，最终导致了全新的一类问题。
截至 2023 年初，带有供应商前缀的 CSS 功能几乎已经不存在，旧的前缀属性和值正被浏览器实现逐步且稳定地移除。您可能永远不需要编写带前缀的 CSS，但可能会在实际项目中遇到，或者从遗留代码库中继承以下类似的代码：">
    
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/png" href="http://localhost:1313/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png">
      
      <link rel="stylesheet" href="/css/index.css">
      
      <link rel="stylesheet" href="/css/categories.css">
      
      <link rel="stylesheet" href="/css/comment.css">
      
      <link rel="stylesheet" href="/css/page-main.css">
      
      <link rel="stylesheet" href="/css/pagination.css">
      
      <link rel="stylesheet" href="/css/profile-card.css">
      
      <link rel="stylesheet" href="/css/relative.css">
      
      <link rel="stylesheet" href="/css/search.css">
      
      <link rel="stylesheet" href="/css/about.css">
      
      <link rel="stylesheet" href="/css/post-card.css">
      
      <link rel="stylesheet" href="/css/markdown.css">
      
      <link rel="stylesheet" href="/css/friends.css">
      
      <link rel="stylesheet" href="/css/latex.css">
      
    
    <title>1.2 样式表内容</title>
    
    
    <script type="text/javascript" src="/index.js" defer></script>
  </head>
  <body class=" page ">
    
      <header>
      <a href="/">
      <img src="http://localhost:1313//image/logo.png" alt="Calenton Logo" 
      style="width: 180px;height:160px;" />
      Caleton Academy
      </a>
      <span id="search">
        <input type="search" placeholder="Search">
      <div></div>
      </span>
       
  <nav>
    
      <button class="hamburger">&#9776;</button>
    
    <ul>
    
      <li>
        <a href="/notes">笔记</a>
        
          <ul>
            
              <li><a href="/notes/computer-science-and-technology/">Cst</a></li>
            
              <li><a href="/notes/math/">Math</a></li>
            
              <li><a href="/notes/physcis/">Physics</a></li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/thoughts">思考碎片</a>
        
      </li>
    
      <li>
        <a href="/friends">友人帐</a>
        
      </li>
    
      <li>
        <a href="/about">关于</a>
        
      </li>
    
    </ul> 
  </nav>


      </header>
      
    
<main>
  
  
  
    <h1>
      1.2 样式表内容
    </h1>
  
  
    <h2>Table of Contents</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#规则的结构">规则的结构</a></li>
    <li><a href="#供应商前缀vendor-prefixing">供应商前缀（Vendor Prefixing）</a></li>
    <li><a href="#空白符处理">空白符处理</a></li>
    <li><a href="#css-中的注释">CSS 中的注释</a></li>
    <li><a href="#标记markup">标记（Markup）</a></li>
  </ul>
</nav>
  
<div class="content-wrapper">
  <div class="content">
    <p>在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-css" data-lang="css"><span style="display:flex;"><span><span style="color:#75715e">/* 示例代码，仅用于展示 */</span>
</span></span><span style="display:flex;"><span>.<span style="color:#a6e22e">example</span> <span style="color:#f92672">h1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">color</span>: <span style="color:#66d9ef">maroon</span>; <span style="color:#75715e">/* 改变一级标题颜色 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.<span style="color:#a6e22e">example</span> <span style="color:#f92672">body</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">background</span>: <span style="color:#66d9ef">yellow</span>; <span style="color:#75715e">/* 设置背景颜色 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>诸如此类的样式共同构成了样式表的主体。</p>
<h2 id="规则的结构">规则的结构</h2>
<p>为了更详细的说明规则的概念，让我们分解下代码的结构。</p>
<p>每条规则由两个基本部分组成：选择器（selector）和声明块（declaration block）。声明块包含一个或多个声明（declaration），而每个声明由一个属性（property）和一个值（value）组成。每个样式表都是由这样的一系列规则构成的。图 1-1 展示了规则的各个部分。
<img src="/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/1.png">
选择器位于规则的左侧，用于定义文档中哪些部分将被选中进行样式应用。在图 1-1 中，选择器为 <code>&lt;h1&gt;</code>，表示选择所有一级标题（heading level 1）元素。如果选择器是 p，那么所有段落（<code>&lt;p&gt;</code>）元素将被选中。</p>
<p>规则的右侧是声明块，由一个或多个声明组成。每个声明由一个 CSS 属性和该属性的值组成。在图 1-1 中，声明块包含两个声明。第一个声明指定规则会将文档的某些部分设置为红色文本，第二个声明指定文档的某些部分将有一个黄色背景。因此，文档中的所有 <code>&lt;h1&gt;</code> 元素（由选择器定义）将被设置为红色文本，并带有黄色背景。</p>
<h2 id="供应商前缀vendor-prefixing">供应商前缀（Vendor Prefixing）</h2>
<p>有时，您会看到 CSS 的某些部分带有连字符和标签，例如：-o-border-image。这些供应商前缀是浏览器供应商用来标记某些属性、值或其他 CSS 部分为实验性或专有功能（或者两者兼有）的一种方式。截至 2023 年初，仍有一些供应商前缀在使用，其中最常见的如表 1-1 所示。
<img src="/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/2.png">
如表1-1所示，供应商前缀的通用格式通常是连字符、标签和连字符，尽管有几个前缀错误地省略了第一个连字符。</p>
<p>供应商前缀的使用与滥用历史悠久、复杂且超出了本书的范围。简单来说，它们最初的目的是为浏览器供应商提供测试新功能的方式，从而加速互操作性的发展，同时避免被与其他浏览器不兼容的遗留行为所束缚。这避免了一类几乎在 CSS 初期扼杀其发展的问题。然而，不幸的是，这些带前缀的属性随后被网页作者广泛使用，最终导致了全新的一类问题。</p>
<p>截至 2023 年初，带有供应商前缀的 CSS 功能几乎已经不存在，旧的前缀属性和值正被浏览器实现逐步且稳定地移除。您可能永远不需要编写带前缀的 CSS，但可能会在实际项目中遇到，或者从遗留代码库中继承以下类似的代码：</p>
<pre tabindex="0"><code>/* 示例代码，演示供应商前缀 */
.example {
    -webkit-transform: rotate(45deg); /* WebKit 内核浏览器 */
    -moz-transform: rotate(45deg);   /* Gecko 内核浏览器 */
    -ms-transform: rotate(45deg);    /* Trident 内核浏览器 */
    -o-transform: rotate(45deg);     /* 旧版 Opera 浏览器 */
    transform: rotate(45deg);        /* 标准 CSS 写法 */
}
</code></pre><p>这段代码实际上表达了同样的内容四次：分别为 WebKit（如 Safari、Chrome）、Gecko（如 Firefox）和 Opera 浏览器的前缀版本，最后是符合 CSS 标准的写法。再次强调，这种写法已经不再必要。我们在此仅包含它是为了让您对其可能的外观有一个概念，以备将来遇到类似情况时能够识别。</p>
<h2 id="空白符处理">空白符处理</h2>
<p>CSS 基本上对规则之间的空白符不敏感，对规则内部的空白符也不太敏感，尽管存在一些例外情况。</p>
<p>通常，CSS 处理空白字符的方式与 HTML 相同：任何连续的空白字符序列都会在解析时折叠为一个空格。因此，你可以以下列方式格式化这个假设的彩虹规则：</p>
<p><code>rainbow: infrared red orange yellow green blue indigo violet ultraviolet;</code></p>
<pre tabindex="0"><code>rainbow:
 infrared
 red
 orange
 yellow
 green
 blue
 indigo
 violet
 ultraviolet
 ;
</code></pre><p>以及你能想到的任何其他分隔模式。唯一的限制是分隔字符必须是空白字符：空格、制表符或换行符，单独使用或组合使用，数量不限。</p>
<p>类似地，你可以以任何喜欢的方式用空格格式化一系列规则。以下这些都是这只是无数可能性中的五个例子：</p>
<pre tabindex="0"><code>/* 示例代码，演示空白符处理 */
/* 示例样式仅应用于 .example 类范围 */
.example html {color: black;} /* 黑色文字 */
.example body {background: white;} /* 白色背景 */
.example p {color: gray;} /* 灰色段落文字 */
.example h2 {color: silver;} /* 银色标题 */
.example ol {
    color: silver; /* 银色有序列表 */
}
</code></pre><p>正如你从第一条规则中看到的，空白字符在很大程度上可以省略。实际上，这通常是压缩 CSS 的情况，压缩 CSS 是指移除了所有多余空白字符的 CSS，通常由某种自动化的服务器端脚本完成。第一条规则之后的规则逐步使用了更多的空白字符，直到最后一条规则，几乎每个可以分开到单独一行的部分都被分开了。</p>
<p>所有这些方法都是有效的，所以您应该选择最有意义的格式——也就是最容易读懂的格式，并坚持使用它。</p>
<h2 id="css-中的注释">CSS 中的注释</h2>
<p>CSS允许注释。这些注释与 C/C++ 注释非常相似，它们被/* 和 */包围：</p>
<p>/* This is a CSS comment */</p>
<p>注释可以跨越多行，就像 C++ 一样。</p>
<p>/* This is a CSS comment, and it
can be several lines long without
any problem whatsoever. */</p>
<p>重要的是要记住，CSS 注释不能嵌套。例如，这是不正确的：</p>
<pre tabindex="0"><code>/* This is a comment, in which we find
 another comment, which is WRONG
 /* Another comment */
and back to the first comment, which is not a comment.*/
</code></pre><p>一种意外创建“嵌套”注释的情况是暂时注释掉包含注释的大块样式表。由于 CSS 不允许嵌套注释，“外层”注释会在“内层”注释结束的地方结束。</p>
<p>不幸的是，CSS 中没有像 // 或 # 这样的“单行注释”模式（其中 # 已经被保留用于 ID 选择器）。CSS 中唯一的注释模式是 /* */。因此，如果您希望在与标记相同行中添加注释，需要注意放置的方式。例如，这是正确的做法：</p>
<pre tabindex="0"><code>/* 示例代码，演示 CSS 单行注释的正确用法 */
.example h1 {color: gray;} /* 一级标题为灰色 */
.example h2 {color: silver;} /* 二级标题为银色 */
.example p {color: white;} /* 段落文字为白色 */
.example pre {color: gray;} /* 预格式化文字为灰色 */
</code></pre><p>以下示例中，因为有四行注释都没有正确标注，大部分样式表将成为注释的一部分，因此将无法生效：</p>
<pre tabindex="0"><code>.example h1 {color: gray;} /* This CSS comment is several lines
.example h2 {color: silver;} long, but since it is not wrapped
.example p {color: white;} in comment markers, the last three
.example pre {color: gray;} styles are part of the comment. */
</code></pre><p>在此示例中，只有第一条规则（h1 {color: gray;}）会应用到文档中。其余规则作为注释的一部分，被浏览器的渲染引擎忽略。</p>
<p>CSS 注释被 CSS 解析器视为完全不存在，因此在解析时不算作空白字符。这意味着我们可以将它们放在规则的中间，甚至直接插入到声明中！</p>
<h2 id="标记markup">标记（Markup）</h2>
<p>样式表中没有标记（markup）。唯一的例外是 HTML 注释标记，由于历史原因，它被允许出现在 <code>&lt;style&gt;</code> 元素中：</p>
<pre tabindex="0"><code>&lt;!-- 示例代码，用于展示历史标记 --&gt;
&lt;style&gt;
/* 这种写法仅为历史兼容性展示 */
.example h1 {color: maroon;} /* 一级标题为栗色 */
.example body {background: yellow;} /* 背景为黄色 */
&lt;/style&gt;
</code></pre><p>就像这样，不过即使是以上这样的代码也不再被推荐；需要它的浏览器已经几乎被遗忘了。</p>
<p>说到标记，现在是时候稍微绕一下弯路来讨论 CSS 将用于设置样式的元素，以及 CSS 如何以最基本的方式影响这些元素。</p>
<p>特别提示：在 Markdown 文档中嵌入示例代码块时，请注意添加诸如 .example 这类的名称来规避代码块对页面的影响。例如，如果我们在本文的第一个示例中忽略 .example 而直接书写 p 等选择器时，由于恰好示例代码是 css 代码，且示例代码恰好是全局选择器，因此我们新添加的属性值就会更改原来的页面样式。</p>

  </div>
      
      <aside class="sidebar">
        <div class="card">
          <h2>摘要</h2>
          <p>在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：
1 2 3 4 5 6 7 8 /* 示例代码，仅用于展示 */ .example h1 { color: maroon; /* …</p> 
        </div>
        <div class="card">
          <h2>阅读时长</h2>
          <p>2 min</p> 
        </div>
        <div class="card">
          <h2>总字数</h2>
          <p>≈ 411</p> 
        </div>
        <div class="card">
          <h2>标签</h2>
          <p>
            
              <a href="#">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-tag" viewBox="0 0 16 16">
                  <path d="M3 2a1 1 0 0 0-1 1v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 8.586 2H3zm1 1h4.586L14 8.414l-4.586 4.586-6-6V3z"/>
                  <path d="M5.5 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                </svg>
                前端开发
              </a>
            
          </p>
        </div>
      </aside>
    </div>
</div>
</main>

<div id="related">
  <h2>Related Pages</h2>
  <ul class="posts">
    
      <li class="post">
  
  <a href="http://localhost:1313/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.1/">
    <h2>
      1.1 (web)style 简史
    </h2>
    <article>
      层叠样式表（Cascading Style Sheets，CSS）是一种强大的编程语言，可用于改变文档或文档集合的呈现方式，它几乎已经渗透到网络的每个角落以及许多表面上非网络的环境中。例如，嵌入式设备的显示通常使用 CSS 来设计其用户界面，许多 RSS 客户端允许你对订阅源和订阅条目应用 CSS，一些即时消息客户端使用 CSS 来格式化聊天窗口。CSS 的某些方面甚至可以在 JavaScript (JS) 框架的语法中以及 JS 本身中找到。它无处不在！
CSS 最早在 1994 年被提出，当时正值互联网开始真正流行之际。当时，浏览器赋予用户大量的样式控制能力——例如，NCSA Mosaic 的显示偏好允许用户定义每种元素的字体系列、大小和颜色。而文档作者却没有任何这样的能力；他们只能将内容标记为段落、某一级别的标题、预格式化文本或其他十几种元素类型之一。如果用户将其浏览器配置为使所有一级标题变得又小又粉红，而所有六级标题变得又大又红，那完全是用户自己的选择。
CSS 正是在这种环境中被引入的。其目标是为网页作者提供一种简单的声明式样式语言，既灵活又强大，最重要的是，能够同时为作者和用户提供样式控制能力。通过层叠机制，这些样式可以被组合和优先排序，使网站作者和读者都能表达自己的需求——尽管最终的决定权始终在读者手中。
工作迅速推进，到 1996 年底，CSS1 已经完成。尽管新成立的 CSS 工作组继续推进 CSS2 的开发，但浏览器在以互操作性方式实现 CSS1 时遇到了困难。尽管 CSS 的每个部分本身都相对简单，但它们的组合却产生了一些令人意想不到的复杂行为。不幸的是，还出现了一些问题，比如臭名昭著的盒模型实现差异。这些问题一度威胁到 CSS 的发展，但幸运的是，一些巧妙的提议被实施，浏览器开始趋于一致。在接下来的几年里，随着互操作性的增强以及像《Wired》杂志基于 CSS 的重新设计和 CSS Zen Garden 等高调发展项目的推动，CSS 开始流行起来。
在这一切发生之前，CSS 工作组于 1998 年初完成了 CSS2 规范。CSS2 甫一完成，随即开始了 CSS3 的开发以及一个经过澄清的版本 CSS2.1 的工作。与当时的潮流一致，最初称为 CSS3 的规范被设计为一系列（理论上）独立的模块，而不是一个庞大的整体规范。这种方法反映了当时活跃的 XHTML 规范，它也因类似的原因被分解为模块。
对 CSS 进行模块化的理由是，每个模块可以按照自己的节奏进行开发，特别是重要或流行的模块可以沿着万维网联盟（W3C）的进展路径快速推进，而不会被其他模块拖延。事实上，这种方式确实奏效了。截至 2012 年初，已有三个 CSS Level 3 模块（以及 CSS1 和 CSS 2. 
    </article>
    <div>Read More</div>
  </a>
</li>

    
      <li class="post">
  
  <a href="http://localhost:1313/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.3/">
    <h2>
      1.3 Viewing Markup Locally
    </h2>
    <article>
      使用简单的文本编辑器，输入前面的任一示例并以文件名保存，如 helloworld.html 或 helloworld.htm；你可以选择使用 .htm 或 .html 文件扩展名，但无论你选择哪个进行开发，都要保持一致。这本书的所有文件都使用 .html。
将示例文件保存到本地文件系统后，在 Web 浏览器中打开它，方法是打开文件菜单，然后根据你的浏览器选择打开、打开页面或打开文件： 一旦您的浏览器读取了该文件，它就应该呈现如下所示的页面： 如果由于某种原因没有使用适当的扩展名保存文件，则浏览器不会尝试解释 HTML 标记。例如，请注意当你尝试以 .txt 扩展名打开内容时: 如果要对文档进行更改，可以更新标记，保存文件，返回浏览器，然后单击重新加载或刷新按钮。有时，浏览器仍会从其缓存中重新加载页面；如果页面在重新加载时没有正确更新，请在按住 Shift 键的同时单击重新加载按钮，浏览器应该会刷新该页面。
在编写标记时，保持浏览器和编辑器同时打开是一个非常好的主意，以避免不断地重新打开其中之一。许多 Web 编辑器将帮助您将 Web 页面加载到各种浏览器中，甚至直接预览标记的可视化。图1-1显示了 Adobe 广受欢迎的 Dreamweaver 程序[]。  
    </article>
    <div>Read More</div>
  </a>
</li>

    
  </ul>
</div>

<div class="comments" data-articleurl="/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/">
  <h2>Comments</h2>
  
  
  
    
  

  
  
  
  

    <template id="comment-success">
      <div class="success">
        您的评论已成功提交审核。(´｡• ᵕ •｡`)
      </div>
    </template>
    <template id="comment-error">
      <div class="error">
        啊，好像出了些问题，请您调整后重试。(；′⌒`)
      </div>
    </template>

    <form id="comment-form" data-dynamic-form data-success="#comment-success" data-error="#comment-error" netlify="true" name="Comments" method="POST" style="margin-top: 20px;">
  
      <div id="reply-to" style="display: none; color: #6c757d; margin-bottom: 10px;"></div> 
      
      <input type="hidden" name="url" value="/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/">
      <input type="hidden" name="parent" id="parent" value="">
      <input type="hidden" name="custom" id="custom">
      <input type="hidden" name="depth" id="depth" value="0">
      <input type="hidden" name="articleurl" value="/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/">

      
      <label class="comment-label" for="name">Name:</label>
      <input class="comment-input" type="text" id="name" name="name" required autocomplete="name">
      
      <label class="comment-label" for="email">Email:</label>
      <input class="comment-input" type="email" id="email" name="email" required autocomplete="email">
      
      <label class="comment-label" for="comment">Comment:</label>
      <textarea class="comment-textarea" id="comment" name="comment" rows="5" required autocomplete="off"></textarea>
      
      <button class="comment-button" type="submit">Send</button>
    </form>
    
  
</div>
<script>
  
  
  function generateUniqueId() {
    return `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }



document.querySelectorAll(".reply-button").forEach(button => {
  button.addEventListener("click", function() {
    
    const parentComment = this.closest('.comment');

    
    const parentId = this.getAttribute('data-custom');
    const parentName = this.getAttribute('data-name');

    
    const parentDepth = parseInt(parentComment.getAttribute('data-depth')) || 0;

    
    document.getElementById('parent').value = parentId || "";
    console.log("Parent ID set to:", parentId); 

    
    const newDepth = parentDepth + 1;

    
    document.getElementById('depth').value = newDepth;

    
    const replyToElement = document.getElementById('reply-to');
    replyToElement.style.display = 'block';
    replyToElement.innerText = `回复 @${parentName}`;

    
    document.querySelectorAll('.comment').forEach(comment => {
      comment.classList.remove('highlight');
    });
    this.closest('.comment').classList.add('highlight');
  });

    
    document.getElementById('comment-form').scrollIntoView({ behavior: 'smooth' });
  });


  
  document.getElementById("comment-form").addEventListener("submit", function(event) {
    
    const customIdField = document.getElementById("custom");
    if (!customIdField.value) {
        customIdField.value = generateUniqueId();
        console.log("Custom ID set to:", customIdField.value); 
    }
});

window.onload = function() {
    
    const commentsContainer = document.querySelector('.comments'); 
    const articleurl = commentsContainer.dataset.articleurl.replace(/\/$/, '').toLowerCase(); 
    const commentForm = document.querySelector('#comment-form'); 
    const footer = document.querySelector('footer'); 

    
    const allComments = Array.from(document.querySelectorAll('.comment, .child-comment'));

    
    const filteredComments = allComments.filter(comment => {
    const commentArticleUrl = comment.dataset.articleurl.replace(/\/$/, '').toLowerCase();
    return commentArticleUrl === articleurl;
});

    
    commentsContainer.innerHTML = '';

    
    const topLevelComments = filteredComments.filter(comment => comment.dataset.depth === '0');
    topLevelComments.forEach(topLevelComment => {
        commentsContainer.appendChild(topLevelComment);

        
        const childComments = filteredComments.filter(comment => comment.dataset.parent === topLevelComment.dataset.custom);
        childComments.forEach(childComment => {
            childComment.classList.add('child-comment'); 
            commentsContainer.appendChild(childComment);
        });
    });

    
    commentsContainer.appendChild(commentForm);
    commentsContainer.appendChild(footer);

    
    commentsContainer.style.display = 'none';
    commentsContainer.offsetHeight; 
    commentsContainer.style.display = '';

    
    
};

  </script>




<script src="/js/footnotes.js"></script>

    
      <footer class="dark">
         
  <nav>
    
    <ul>
    
      <li>
        <a href="/reference">引用资料列表</a>
        
      </li>
    
      <li>
        <a href="/categories">教材索引</a>
        
      </li>
    
      <li>
        <a href=""></a>
        
      </li>
    
    </ul> 
  </nav>


        <ul>
          
            <li>
              <a href="https://facebook.com/example" aria-label="Facebook">
                <i class="  icon-facebook"></i>
              </a>
            </li>
          
          
            <li>
              <a href="https://x.com/i/flow/login" aria-label="Twitter">
                <i class="icon-twitter"></i>
              </a>
            </li>
          
          
            <li>
              <a href="mailto:chiaralee953@foxmail.com" aria-label="email">
                <i class="icon-email"></i>
              </a>
            </li>
          
        </ul>
        <div>Copyright © 2024 Caleton Academy of Magic.</div>
    </footer>
  
  </body>
</html>
