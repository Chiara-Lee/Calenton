<!DOCTYPE html>
<html lang="zh">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    
      <meta name="description" content="目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。
具体做法如下：
5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。
定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：
0&#43;m:=m现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n&#43;&#43; 定义为
(n&#43;&#43;)&#43;m:=(n&#43;m)&#43;&#43;于是， 0&#43;m 就是 m， 1&#43;m 就是 (0&#43;&#43;)&#43;m=(0&#43;m)&#43;&#43;=m&#43;&#43; ， 2&#43;m 就是 (1&#43;&#43;)&#43;m=(1&#43;m)&#43;&#43;=(m&#43;&#43;)&#43;&#43; ，以此类推。例如：
2&#43;m=(1&#43;&#43;)&#43;m=(1&#43;m)&#43;&#43;=(m&#43;&#43;)&#43;&#43;\\2&#43;3=(1&#43;&#43;)&#43;3=(1&#43;3)&#43;&#43;=(3&#43;&#43;)&#43;&#43;=4&#43;&#43;=5\\根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n&#43;m。">
    
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/png" href="http://localhost:1313/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png">
      
      <link rel="stylesheet" href="/css/index.css">
      
      <link rel="stylesheet" href="/css/categories.css">
      
      <link rel="stylesheet" href="/css/comment.css">
      
      <link rel="stylesheet" href="/css/page-main.css">
      
      <link rel="stylesheet" href="/css/pagination.css">
      
      <link rel="stylesheet" href="/css/profile-card.css">
      
      <link rel="stylesheet" href="/css/relative.css">
      
      <link rel="stylesheet" href="/css/search.css">
      
      <link rel="stylesheet" href="/css/about.css">
      
      <link rel="stylesheet" href="/css/post-card.css">
      
      <link rel="stylesheet" href="/css/markdown.css">
      
      <link rel="stylesheet" href="/css/friends.css">
      
      <link rel="stylesheet" href="/css/latex.css">
      
    
    <title>2.2 加法和归纳原理的两个变体</title>
    
    
    <script type="text/javascript" src="/index.js" defer></script>
  </head>
  <body class=" page ">
    
      <header>
      <a href="/">
      <img src="http://localhost:1313//image/logo.png" alt="Calenton Logo" 
      style="width: 180px;height:160px;" />
      Caleton Academy
      </a>
      <span id="search">
        <input type="search" placeholder="Search">
      <div></div>
      </span>
       
  <nav>
    
      <button class="hamburger">&#9776;</button>
    
    <ul>
    
      <li>
        <a href="/notes">笔记</a>
        
          <ul>
            
              <li><a href="/notes/computer-science-and-technology/">Cst</a></li>
            
              <li><a href="/notes/math/">Math</a></li>
            
              <li><a href="/notes/physcis/">Physics</a></li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/thoughts">思考碎片</a>
        
      </li>
    
      <li>
        <a href="/friends">友人帐</a>
        
      </li>
    
      <li>
        <a href="/about">关于</a>
        
      </li>
    
    </ul> 
  </nav>


      </header>
      
    
<main>
  
  
  
    <h1>
      2.2 加法和归纳原理的两个变体
    </h1>
  
  
    <h2>Table of Contents</h2>
    <nav id="TableOfContents"></nav>
  
<div class="content-wrapper">
  <div class="content">
    <p>目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。</p>
<p>具体做法如下：</p>
<p>5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。</p>
<p><strong>定义 2.2.1 (自然数的加法)</strong> 令 m 为一个自然数，我们定义 m 加 0 为：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
0+m:=m

       </span>
     
     
     
<p>现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
(n++)+m:=(n+m)++

       </span>
     
     
     
<p>于是，
     
     
       
     
     
     
       <span class="fallback-latex">
         0+m
       </span>
     
     
     就是 m，
     
     
       
     
     
     
       <span class="fallback-latex">
         1+m
       </span>
     
     
     就是
     
     
       
     
     
     
       <span class="fallback-latex">
         (0++)+m=(0+m)++=m++
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         2+m
       </span>
     
     
     就是
     
     
       
     
     
     
       <span class="fallback-latex">
         (1++)+m=(1+m)++=(m++)++
       </span>
     
     
     ，以此类推。例如：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
2+m=(1++)+m=(1+m)++=(m++)++\\
2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\

       </span>
     
     
     
<p>根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。</p>
<p>现在，我们将之前一般化的讨论特殊化为，
     
     
       
     
     
     
       <span class="fallback-latex">
         a_n=n+m
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         f_n(a_n)=a_n++
       </span>
     
     
     的情景。</p>
<p>注意：我们以上定义的自然数加法是不对称的：
     
     
       
     
     
     
       <span class="fallback-latex">
         3+5
       </span>
     
     
      表明将 3 增长了 5 次，而
     
     
       
     
     
     
       <span class="fallback-latex">
         5+3
       </span>
     
     
     表明将 5 增加了 3 次。不过，它们生成的值是一样的。更一般，对于任意自然数 m、n。有</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
m+n=n+m

       </span>
     
     
     
<p>均成立。（我们将稍后给出其证明）</p>
<p><strong>引理 2.2.2</strong> 对任意自然数 n，
     
     
       
     
     
     
       <span class="fallback-latex">
         n+0=n
       </span>
     
     
     恒成立。</p>
<p>注意，我们的定义是
     
     
       
     
     
     
       <span class="fallback-latex">
         0+m:=m
       </span>
     
     
     ，由于我们尚未证明
     
     
       
     
     
     
       <span class="fallback-latex">
         m+n=n+m
       </span>
     
     
     对于任意自然数 n、m 均成立，因此我们不可以直接通过交换律得到
     
     
       
     
     
     
       <span class="fallback-latex">
         n+0=n
       </span>
     
     
     。</p>
<p><strong>证明</strong>:<br>
采用归纳法来证明。因为
     
     
       
     
     
     
       <span class="fallback-latex">
         0 + m = m
       </span>
     
     
     对任意自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     均成立并且
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     是一个自然数，所以我们能得到最基本的情况
     
     
       
     
     
     
       <span class="fallback-latex">
         0 + 0 = 0
       </span>
     
     
     。</p>
<p>现在归纳性地假设
     
     
       
     
     
     
       <span class="fallback-latex">
         n + 0 = n
       </span>
     
     
     成立。我们希望证明
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + 0 = n++
       </span>
     
     
     。</p>
<p>根据加法的定义，
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + 0 = (n + 0)++
       </span>
     
     
     ；<br>
又根据
     
     
       
     
     
     
       <span class="fallback-latex">
         n + 0 = n
       </span>
     
     
     可以推导出
     
     
       
     
     
     
       <span class="fallback-latex">
         (n + 0)++ = n++
       </span>
     
     
     。</p>
<p>至此整个归纳过程就结束了。
     
     
       
     
     
     
       <span class="fallback-latex">
         \Box
       </span>
     
     
     </p>
<p><strong>引理 2.2.3</strong>  对任意的自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，有<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
n + (m++) = (n + m)++  

       </span>
     
     
     <br>
成立。</p>
<p>同样，因为目前我们还不知道有
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = b + a
       </span>
     
     
     ，所以不能从
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + m = (n + m)++
       </span>
     
     
     中推导出本结论。</p>
<p><strong>证明</strong>:<br>
将
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     设为定值，对
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     采用归纳法。首先考虑最基本的情况，
     
     
       
     
     
     
       <span class="fallback-latex">
         n = 0
       </span>
     
     
     。此时我们必须证明<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
0 + (m++) = (0 + m)++  

       </span>
     
     
     </p>
<p>根据加法定义，左侧等于
     
     
       
     
     
     
       <span class="fallback-latex">
         m++
       </span>
     
     
     ，再次根据加法定义，显然右侧也为
     
     
       
     
     
     
       <span class="fallback-latex">
         m++
       </span>
     
     
     ，因此等式成立。</p>
<p>现在归纳性地假定
     
     
       
     
     
     
       <span class="fallback-latex">
         n + (m++) = (n + m)++
       </span>
     
     
     成立，那么我们必须证明<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(n++) + (m++) = ((n++) + m)++  

       </span>
     
     
     <br>
根据加法的定义，上式左端等于
     
     
       
     
     
     
       <span class="fallback-latex">
         (n + (m++))++
       </span>
     
     
     又由归纳假设可得

     
     
       
     
     
     
       <span class="fallback-latex">
         
(n+(m++))++ = ((n + m)++)++

       </span>
     
     
     。
类似地，根据加法的定义可得，
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + m = (n + m)++
       </span>
     
     
     ，从而等式的右端也等于
     
     
       
     
     
     
       <span class="fallback-latex">
         ((n + m)++)++
       </span>
     
     
     。</p>
<p>因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。
     
     
       
     
     
     
       <span class="fallback-latex">
         \Box
       </span>
     
     
     </p>
<p>作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
n++ = n + 1。  

       </span>
     
     
     </p>
<p>因为
     
     
       
     
     
     
       <span class="fallback-latex">
         n+1=n+(0++)=(n+0)++=n++
       </span>
     
     
     。</p>
<p>如之前承诺的，现在，我们来证明
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = b + a
       </span>
     
     
     。</p>
<p><strong>命题 2.2.4 （加法是可交换的）</strong><br>
对任意的自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，有<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
n + m = m + n  

       </span>
     
     
     <br>
成立。</p>
<p><strong>证明</strong>:<br>
将
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     设为定值，对
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     采用归纳法。首先证明当
     
     
       
     
     
     
       <span class="fallback-latex">
         n = 0
       </span>
     
     
     时结论成立，也就是说证明
     
     
       
     
     
     
       <span class="fallback-latex">
         0 + m = m + 0
       </span>
     
     
     。</p>
<p>一方面，根据加法的定义可以推出
     
     
       
     
     
     
       <span class="fallback-latex">
         0 + m = m
       </span>
     
     
     ；<br>
另一方面，根据引理 2.2.2 可得
     
     
       
     
     
     
       <span class="fallback-latex">
         m + 0 = m
       </span>
     
     
     。<br>
于是
     
     
       
     
     
     
       <span class="fallback-latex">
         n = 0
       </span>
     
     
     时结论成立。</p>
<p>现在归纳性地假设
     
     
       
     
     
     
       <span class="fallback-latex">
         n + m = m + n
       </span>
     
     
     成立，那么我们要证明<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(n++) + m = m + (n++)  

       </span>
     
     
     <br>
来完成归纳。</p>
<p>根据加法的定义，
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + m = (n + m)++
       </span>
     
     
     ；<br>
根据引理 2.2.3，
     
     
       
     
     
     
       <span class="fallback-latex">
         m + (n++) = (m + n)++
       </span>
     
     
     ；<br>
但由归纳假设
     
     
       
     
     
     
       <span class="fallback-latex">
         n + m = m + n
       </span>
     
     
     可知
     
     
       
     
     
     
       <span class="fallback-latex">
         (m + n)++ = (n + m)++
       </span>
     
     
     。<br>
因此
     
     
       
     
     
     
       <span class="fallback-latex">
         (n++) + m = m + (n++)
       </span>
     
     
     ，进而归纳过程结束。
     
     
       
     
     
     
       <span class="fallback-latex">
         \Box
       </span>
     
     
     </p>
<p><strong>命题 2.2.5 （加法是可结合的）</strong><br>
对任意三个自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     、
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
     、
     
     
       
     
     
     
       <span class="fallback-latex">
         c
       </span>
     
     
     ，有<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a + b) + c = a + (b + c)  

       </span>
     
     
     <br>
成立。</p>
<p><strong>证明</strong>:<br>
固定 
     
     
       
     
     
     
       <span class="fallback-latex">
         a, c \in N
       </span>
     
     
     , 对 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      进行归纳讨论.</p>
<p><strong>设定当 
     
     
       
     
     
     
       <span class="fallback-latex">
         b = 0
       </span>
     
     
     </strong>:<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a + 0) + c = a + c = a + (c + 0) = a + (0 + c)  

       </span>
     
     
     </p>
<p>现在归纳假设 
     
     
       
     
     
     
       <span class="fallback-latex">
         b=n
       </span>
     
     
      时命题成立, 需要证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         b=n++
       </span>
     
     
      时命题成立:<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
\begin{align}  
(a + (n++)) + c &= ((a + n)++) + c \\  
&= c + ((a + n)++) \\  
&= (c + a + n)++ \\  
&= ((a + n) + c)++ \\  
&= (a + (n + c))++ \\  
&= a + (n + c)++ \\  
&= a + ((n++) + c)  
\end{align}  

       </span>
     
     
     </p>
<p>根据数学归纳法，命题对所有自然数均成立。</p>
<p>正是因为有了这条结合律，我们可以把
     
     
       
     
     
     
       <span class="fallback-latex">
         a, b, c
       </span>
     
     
     的和写成
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b + c
       </span>
     
     
     的形式，而无需顾虑它们是按照什么样的次序加起来的。</p>
<p>下面，我们给出消去律。</p>
<p><strong>命题 2.2.6 （消去律）</strong><br>
令
     
     
       
     
     
     
       <span class="fallback-latex">
         a, b, c
       </span>
     
     
     为任意三个自然数并且满足<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
a + b = a + c,  

       </span>
     
     
     <br>
那么
     
     
       
     
     
     
       <span class="fallback-latex">
         b = c
       </span>
     
     
     成立。</p>
<p><strong>注意</strong>:<br>
由于目前我们还没有给出减法和负数的概念，所以这里不能利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及了一种“虚拟减法”。</p>
<p><strong>证明</strong>:<br>
我们通过对
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     进行归纳来证明该命题。<br>
首先考虑最基本的情况
     
     
       
     
     
     
       <span class="fallback-latex">
         a = 0
       </span>
     
     
     ，我们有<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
0 + b = 0 + c,  

       </span>
     
     
     <br>
那么根据加法的定义，由
     
     
       
     
     
     
       <span class="fallback-latex">
         0 + b = 0 + c
       </span>
     
     
     可以得到
     
     
       
     
     
     
       <span class="fallback-latex">
         b = c
       </span>
     
     
     ，故命题成立。</p>
<p>现在归纳性假设关于
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     的消去律成立（进而从
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = a + c
       </span>
     
     
     中可以得到
     
     
       
     
     
     
       <span class="fallback-latex">
         b = c
       </span>
     
     
     ），接下来我们要证明关于
     
     
       
     
     
     
       <span class="fallback-latex">
         a++
       </span>
     
     
     的消去律也成立。换言之，就是在假设<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a++) + b = (a++) + c  

       </span>
     
     
     <br>
成立时，去证明
     
     
       
     
     
     
       <span class="fallback-latex">
         b = c
       </span>
     
     
     成立。根据加法的定义，我们有<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a++) + b = (a + b)++  

       </span>
     
     
     <br>
和<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a++) + c = (a + c)++,  

       </span>
     
     
     <br>
从而可以得到<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
(a + b)++ = (a + c)++.  

       </span>
     
     
     <br>
根据公理 2.4（任意两个不同的自然数的后继也是不同的），我们进一步得到<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
a + b = a + c.  

       </span>
     
     
     <br>
显然上式为待证情况的充要条件。因为我们已知关于
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     的消去律成立，所以有
     
     
       
     
     
     
       <span class="fallback-latex">
         b = c
       </span>
     
     
     成立，结论得证。至此归纳法结束。<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
\Box  

       </span>
     
     
     </p>
<p>现在我们讨论加法与正性是如何相互作用的。</p>
<p><strong>定义 2.2.7 （正自然数）</strong>
称一个自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     是正的，当且仅当它不等于
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     。</p>
<p><strong>命题 2.2.8</strong>
如果
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     是正的并且
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
     是自然数，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b
       </span>
     
     
     是正的（从而根据命题2.2.4可知，
     
     
       
     
     
     
       <span class="fallback-latex">
         b + a
       </span>
     
     
     也是正的）。</p>
<p><strong>证明：</strong>
我们通过对
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
     进行归纳来证明该命题。如果
     
     
       
     
     
     
       <span class="fallback-latex">
         b = 0
       </span>
     
     
     ，那么<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
a + b = a + 0 = a  

       </span>
     
     
     <br>
显然是正的，从而
     
     
       
     
     
     
       <span class="fallback-latex">
         b = 0
       </span>
     
     
     时的结论得证。</p>
<p>现在归纳性地假设
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b
       </span>
     
     
     是正的。那么根据公理 2.3 (0 不是任何自然数的后继)可知，<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
a + (b++) = (a + b)++  

       </span>
     
     
     <br>
不等于零，从而
     
     
       
     
     
     
       <span class="fallback-latex">
         a + (b++)
       </span>
     
     
     是正的。至此归纳法结束。<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
\Box  

       </span>
     
     
     </p>
<p><strong>推论 2.2.9</strong><br>
如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      和 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      是自然数并且满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = 0
       </span>
     
     
     ，那么 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = 0
       </span>
     
     
      且 
     
     
       
     
     
     
       <span class="fallback-latex">
         b = 0
       </span>
     
     
     。</p>
<p><strong>证明</strong>：<br>
假设结论的反面 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \neq 0
       </span>
     
     
      或 
     
     
       
     
     
     
       <span class="fallback-latex">
         b \neq 0
       </span>
     
     
      成立。如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \neq 0
       </span>
     
     
     ，那么 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      是正的，从而根据 <strong>命题 2.2.8</strong> 可知，
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b
       </span>
     
     
      是正的，这显然与已知条件 
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = 0
       </span>
     
     
      相矛盾。类似地，如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         b \neq 0
       </span>
     
     
     ，那么 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      是正的，同样根据 <strong>命题 2.2.8</strong> 可知，
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b
       </span>
     
     
      是正的，这与 
     
     
       
     
     
     
       <span class="fallback-latex">
         a + b = 0
       </span>
     
     
      相矛盾。于是 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      和 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      必须同时为 
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     。□</p>
<p><strong>引理 2.2.10</strong>  令 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      表示一个正自然数，那么恰存在一个自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      使得 
     
     
       
     
     
     
       <span class="fallback-latex">
         b++ = a
       </span>
     
     
     。</p>
<p><strong>证明</strong>：
根据皮亚诺公理 3 （0 不是任何自然数的后继）和 4（不同自然数的后继互不相同）有

     
     
       
     
     
     
       <span class="fallback-latex">
         
\forall m, n \in \mathbb{N}, S(m) = S(n) \implies m = n.

       </span>
     
     
     
则，

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align}
&S(b)=a\\
&\forall n \in \mathbb{N},\text{if} S(n)=S(b)=a \implies n = b.
\end{align}

       </span>
     
     
     
至此命题成立。</p>
<p><strong>定义 2.2.11 （自然数的序）</strong><br>
令
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     表示任意两个自然数。我们称
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     大于等于
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，并且记作
     
     
       
     
     
     
       <span class="fallback-latex">
         n \geq m
       </span>
     
     
     或者
     
     
       
     
     
     
       <span class="fallback-latex">
         m \leq n
       </span>
     
     
     ，当且仅当存在自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     使得
     
     
       
     
     
     
       <span class="fallback-latex">
         n = m + a
       </span>
     
     
     。我们称
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     大于
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，并且记作
     
     
       
     
     
     
       <span class="fallback-latex">
         n > m
       </span>
     
     
     或者
     
     
       
     
     
     
       <span class="fallback-latex">
         m < n
       </span>
     
     
     ，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         n \geq m
       </span>
     
     
     且
     
     
       
     
     
     
       <span class="fallback-latex">
         n \neq m
       </span>
     
     
     。</p>
<p>于是，例如由于
     
     
       
     
     
     
       <span class="fallback-latex">
         8 = 5 + 3
       </span>
     
     
     并且
     
     
       
     
     
     
       <span class="fallback-latex">
         8 \neq 5
       </span>
     
     
     ，所以
     
     
       
     
     
     
       <span class="fallback-latex">
         8 > 5
       </span>
     
     
     。另外注意，对任意的
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     均有
     
     
       
     
     
     
       <span class="fallback-latex">
         n++ > n
       </span>
     
     
     ；因此不存在最大的自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     ，这是因为下一个数
     
     
       
     
     
     
       <span class="fallback-latex">
         n++
       </span>
     
     
     总是更大。</p>
<p><strong>命题 2.2.12 （自然数的序的基本性质）</strong><br>
令
     
     
       
     
     
     
       <span class="fallback-latex">
         a, b, c
       </span>
     
     
     为任意自然数，那么：<br>
(a) （序是自反的）
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq a
       </span>
     
     
     。<br>
(b) （序是可传递的）如果
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b
       </span>
     
     
     并且
     
     
       
     
     
     
       <span class="fallback-latex">
         b \geq c
       </span>
     
     
     ，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq c
       </span>
     
     
     。<br>
(c) （序是反对称的）如果
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b
       </span>
     
     
     并且
     
     
       
     
     
     
       <span class="fallback-latex">
         b \geq a
       </span>
     
     
     ，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     。
(d) （加法保持序不变）
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b
       </span>
     
     
     ，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         a + c \geq b + c
       </span>
     
     
     。<br>
(e) 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ \leq b
       </span>
     
     
     。<br>
(f) 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，当且仅当存在正自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         d
       </span>
     
     
     使得
     
     
       
     
     
     
       <span class="fallback-latex">
         b = a + d
       </span>
     
     
     。</p>
<p><strong>证明</strong>:</p>
<p><strong>(a)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq a
       </span>
     
     
     

     
     
       
     
     
     
       <span class="fallback-latex">
         a + 0 = a \rightarrow a \geq a
       </span>
     
     
     </p>
<p><strong>(b)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b,b \geq c
       </span>
     
     
     ，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq c
       </span>
     
     
     

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align}
a \geq b \rightarrow a = b + n,  n \in \mathbb{N}\\
b \geq c \rightarrow b = c + m,  m \in \mathbb{N}\\
\end{align}

       </span>
     
     
     
因此，

     
     
       
     
     
     
       <span class="fallback-latex">
         
a = b + n = c + m + n

       </span>
     
     
     
显然就可得结论，
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq c
       </span>
     
     
     </p>
<p><strong>(c)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b，b \geq a
       </span>
     
     
     ，则
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align}
a \geq b \rightarrow a = b + n,  n \in \mathbb{N}\\
b \geq a \rightarrow b = a + m,  m \in \mathbb{N}\\
\end{align}

       </span>
     
     
     
即

     
     
       
     
     
     
       <span class="fallback-latex">
         
a = a + m + n

       </span>
     
     
     
显然，
     
     
       
     
     
     
       <span class="fallback-latex">
         m = 0，n = 0
       </span>
     
     
     ，则
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     。</p>
<p><strong>(d)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \geq b
       </span>
     
     
      if and only if 
     
     
       
     
     
     
       <span class="fallback-latex">
         a + c \geq b + c
       </span>
     
     
     .

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align}
(a \geq b) &\iff a = b + m, \, m \in \mathbb{N} \\
          &\iff a + c = b + m + c = b + c + m, \, m \in \mathbb{N} \\
          &\iff a + c \geq b + c.
\end{align}

       </span>
     
     
     </p>
<p><strong>(e)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
      if and only if 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ \leq b
       </span>
     
     
     .</p>
<p>We have</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{align}(a < b) &\iff ((a \leq b) \land (a \neq b)) \\&\iff ((a + m = b, \, m \in \mathbb{N}) \land (a \neq b)) \\&\iff m \neq 0 \\&\iff \exists n \in \mathbb{N}, \, n++ = m \\&\iff a + (n++) = b, \, n \in \mathbb{N} \\&\iff (a++) + n = b, \, n \in \mathbb{N} (引理 2.2.3)\\&\iff a++ \leq b.\end{align}
       </span>
     
     
     
<p><strong>(f)</strong> 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
      if and only if 
     
     
       
     
     
     
       <span class="fallback-latex">
         b = a + d
       </span>
     
     
      for some positive number 
     
     
       
     
     
     
       <span class="fallback-latex">
         d
       </span>
     
     
     .</p>
<p>We have</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{align}(a < b) &\iff ((a \leq b) \land (a \neq b)) \\&\iff (a + d = b, \, d \in \mathbb{N}) \land (d \neq 0) \\&\iff a + d = b, \, d \text{ is positive.}\end{align}
       </span>
     
     
     
<p><strong>命题 2.2.13 （自然数的序的三歧性）</strong><br>
令 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      和 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      表示任意两个自然数，那么在下面三种表述中恰有一种表述为真：
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
     。</p>
<p><strong>证明</strong>：</p>
<p>首先我们证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
      以及 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
      这三种表述中同时为真的表述个数不超过一个。如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，那么根据定义可知 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \neq b
       </span>
     
     
     ；同样，如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
     ，根据定义可知 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \neq b
       </span>
     
     
     。如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
      并且 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，那么根据命题 2.2.12 可知 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     ，这显然与 
     
     
       
     
     
     
       <span class="fallback-latex">
         a \neq b
       </span>
     
     
      相矛盾。因此同时为真的表述个数不超过一个。</p>
<p>现在我们证明至少有一个表述为真。</p>
<p>保持 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      固定不变，对 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      进行归纳。当 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = 0
       </span>
     
     
      时，对所有的 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
      均有 
     
     
       
     
     
     
       <span class="fallback-latex">
         0 \leq b
       </span>
     
     
      （为什么？）因此我们得到 
     
     
       
     
     
     
       <span class="fallback-latex">
         0 = b
       </span>
     
     
      或者 
     
     
       
     
     
     
       <span class="fallback-latex">
         0 < b
       </span>
     
     
     ，从而 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = 0
       </span>
     
     
      时的结论得证。</p>
<p>现在归纳性地假设关于 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      的命题已经被证明是成立的，下面我们要证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++
       </span>
     
     
      也同样成立。</p>
<p>从关于 
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
      的三歧性中可知，存在三种可能的情况：
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
      以及 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
     。如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
     ，那么有 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ > b
       </span>
     
     
     。（为什么？）如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     ，那么 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ > b
       </span>
     
     
     。（为什么？）现在假设 
     
     
       
     
     
     
       <span class="fallback-latex">
         a < b
       </span>
     
     
     ，那么根据命题 2.2.12 可知 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ \leq b
       </span>
     
     
     。于是我们得到要么 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ = b
       </span>
     
     
     ，要么 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ < b
       </span>
     
     
     ，其中任何一种情况都符合我们的要求。至此归纳法结束。</p>
<p><strong>Why 1:</strong> When 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = 0
       </span>
     
     
     , we have 
     
     
       
     
     
     
       <span class="fallback-latex">
         0 \leq b
       </span>
     
     
      for all 
     
     
       
     
     
     
       <span class="fallback-latex">
         b
       </span>
     
     
     .</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
(0 + b = b, b \in \mathbb{N}) \Rightarrow (0 \leq b, b \in \mathbb{N})

       </span>
     
     
     
<hr>
<p><strong>Why 2:</strong> If 
     
     
       
     
     
     
       <span class="fallback-latex">
         a > b
       </span>
     
     
     , then 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ > b
       </span>
     
     
     .</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         (a > b) \Rightarrow (a = b + m, m \in \mathbb{N}) \land (a \neq b) \\ \Rightarrow a++ = b + (m++) \Rightarrow a++ > b 
       </span>
     
     
     
<hr>
<p><strong>Why 3:</strong> If 
     
     
       
     
     
     
       <span class="fallback-latex">
         a = b
       </span>
     
     
     , then 
     
     
       
     
     
     
       <span class="fallback-latex">
         a++ > b
       </span>
     
     
     .</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         (a = b) \Rightarrow a++ = b++ = (b + 0)++ = b + (0++) = b + 1 \\ \Rightarrow a++ > b 
       </span>
     
     
     
<p><strong>命题 2.2.14 （强归纳法原理）</strong><br>
令 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0
       </span>
     
     
      表示一个自然数，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      表示与任意自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      有关的性质。假设对任意满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \geq m_0
       </span>
     
     
      的自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，均有如下内容成立：若 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m')
       </span>
     
     
      对任意满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m' < m
       </span>
     
     
      的自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m'
       </span>
     
     
      均为真，那么 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      也为真。（特别地，这意味着 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0)
       </span>
     
     
      为真，因为当 
     
     
       
     
     
     
       <span class="fallback-latex">
         m = m_0
       </span>
     
     
      时，前提中的 
     
     
       
     
     
     
       <span class="fallback-latex">
         m'
       </span>
     
     
      取值范围为空。）于是我们能够断定，对于任意满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \geq m_0
       </span>
     
     
      的自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。</p>
<hr>
<p><strong>注 2.2.15</strong> 在应用强归纳法原理的时候，我们通常令 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 = 0
       </span>
     
     
      或者 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 = 1
       </span>
     
     
     。</p>
<p><strong>证明：</strong>
设 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      是一个与自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      相关的命题。如果满足以下条件：</p>
<ol>
<li><strong>基础情况</strong>：当 
     
     
       
     
     
     
       <span class="fallback-latex">
         m = m_0
       </span>
     
     
      时，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0)
       </span>
     
     
      为真。</li>
<li><strong>归纳假设</strong>：对于任意 
     
     
       
     
     
     
       <span class="fallback-latex">
         m > m_0
       </span>
     
     
     ，如果 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m')
       </span>
     
     
      对所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m' < m
       </span>
     
     
      都成立，则 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      也为真。</li>
</ol>
<p>则结论是：
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      对所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \geq m_0
       </span>
     
     
      成立。</p>
<p><strong>证明过程</strong></p>
<p><strong>1. 用普通归纳法重新定义问题</strong></p>
<p>设 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      表示如下命题：</p>
<blockquote>
<p>对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m < m_0 + n
       </span>
     
     
     ，命题 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      都为真。</p>
</blockquote>
<p>我们的目标是证明：对于所有正整数 
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      成立。这等价于强归纳原理，因为 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      的结论覆盖了 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      在 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \geq m_0
       </span>
     
     
      的所有情况。</p>
<p><strong>2. 验证基础情况</strong></p>
<p>当 
     
     
       
     
     
     
       <span class="fallback-latex">
         n = 1
       </span>
     
     
      时，
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(1)
       </span>
     
     
      的含义是：对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m < m_0 + 1
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。</p>
<p>因为能满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m < m_0 + 1
       </span>
     
     
      的自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      只有
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0
       </span>
     
     
     ，因此此情况下性质仅涉及 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0)
       </span>
     
     
     ，而强归纳原理假设，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0)
       </span>
     
     
      为真，因此 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(1)
       </span>
     
     
      为真。</p>
<p><strong>3. 验证归纳步骤</strong></p>
<p>假设 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      为真，即：<br>
对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m < m_0 + n
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。</p>
<p>需要证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n+1)
       </span>
     
     
      为真，即：<br>
对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m < m_0 + n + 1
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。</p>
<p>根据 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
     ，我们已经知道：</p>
<ul>
<li>
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m')
       </span>
     
     
      对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m' < m_0 + n
       </span>
     
     
      都成立。</li>
</ul>
<p>我们现在需要证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0 + n)
       </span>
     
     
      为真。这与基础情况的逻辑是相同的。</p>
<p>因为 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n+1)
       </span>
     
     
      的定义是

     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n+1) := \forall m(m_0 < m < m_0 + n + 1 \rightarrow P(m) \text{为真})
       </span>
     
     
     </p>
<p>根据归纳假设，
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      为真，即

     
     
       
     
     
     
       <span class="fallback-latex">
         P(m) \text{对于所有的} m_0 \le m < m_0 + n \text{都为真}
       </span>
     
     
     </p>
<p>所以我们有待验证的范围还剩下

     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 + n \le m < m_0 + n + 1
       </span>
     
     
     </p>
<p>而满足上述范围的自然数
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      只有
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 + n
       </span>
     
     
     。</p>
<p>综上，我们只需要证明 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0 + n)
       </span>
     
     
      为真，即可得到 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n+1)
       </span>
     
     
      为真。</p>
<p>根据强归纳原理假设，若 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m')
       </span>
     
     
      对所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m' < m
       </span>
     
     
      都成立，则 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。<br>
将 
     
     
       
     
     
     
       <span class="fallback-latex">
         m = m_0 + n
       </span>
     
     
      代入，这里 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m')
       </span>
     
     
      对所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m_0 \leq m' < m_0 + n
       </span>
     
     
      已经成立（由归纳假设 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
     ），因此 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m_0 + n)
       </span>
     
     
      为真。</p>
<p>结合归纳假设，我们得出 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n+1)
       </span>
     
     
      为真。</p>
<p><strong>4. 归纳完成</strong></p>
<p>通过普通数学归纳法，我们证明了 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      对所有正整数 
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
      都成立。这意味着：</p>
<ul>
<li>对于所有 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \geq m_0
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      为真。</li>
</ul>
<p><strong>逆向归纳法原理</strong></p>
<p>令 
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
      表示一个自然数，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      是关于自然数的一个性质并且满足：只要 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m++)
       </span>
     
     
      为真，
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      就为真。假设 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(n)
       </span>
     
     
      也为真，证明：
     
     
       
     
     
     
       <span class="fallback-latex">
         P(m)
       </span>
     
     
      对任意满足 
     
     
       
     
     
     
       <span class="fallback-latex">
         m \leq n
       </span>
     
     
      的自然数 
     
     
       
     
     
     
       <span class="fallback-latex">
         m
       </span>
     
     
      均为真；这被称为<strong>逆向归纳法原理</strong>。（提示：对变量 
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
      使用归纳法。）</p>
<p><strong>证明：</strong>
Induction on 
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     , let 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(n)
       </span>
     
     
      represent:<br>

     
     
       
     
     
     
       <span class="fallback-latex">
           
Q(n) := \{ P(m) \text{ is true, } \forall m \leq n \}  

       </span>
     
     
     </p>
<p><strong>Case 0</strong>: 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(0)
       </span>
     
     
      is true.</p>
<p>If 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(k)
       </span>
     
     
      is true, then consider 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(k++)
       </span>
     
     
     :<br>

     
     
       
     
     
     
       <span class="fallback-latex">
         Q(k++) = \{ P(m) \text{ is true, } \forall m \leq k++ \}
       </span>
     
     
     ,<br>
as 
     
     
       
     
     
     
       <span class="fallback-latex">
         P(k++)
       </span>
     
     
      is true. Hence, 
     
     
       
     
     
     
       <span class="fallback-latex">
         Q(k++)
       </span>
     
     
      is true.</p>
<p>The induction is valid.</p>

  </div>
      
      <aside class="sidebar">
        <div class="card">
          <h2>摘要</h2>
          <p>目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。
具体做法如下：
5 加上 3 与对 5 进行 3 次增量运算的结果是一 …</p> 
        </div>
        <div class="card">
          <h2>阅读时长</h2>
          <p>10 min</p> 
        </div>
        <div class="card">
          <h2>总字数</h2>
          <p>≈ 1975</p> 
        </div>
        <div class="card">
          <h2>标签</h2>
          <p>
            
              <a href="#">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-tag" viewBox="0 0 16 16">
                  <path d="M3 2a1 1 0 0 0-1 1v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 8.586 2H3zm1 1h4.586L14 8.414l-4.586 4.586-6-6V3z"/>
                  <path d="M5.5 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                </svg>
                数学分析
              </a>
            
          </p>
        </div>
      </aside>
    </div>
</div>
</main>

<div id="related">
  <h2>Related Pages</h2>
  <ul class="posts">
    
      <li class="post">
  
  <a href="http://localhost:1313/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.3/">
    <h2>
      2.3  乘法
    </h2>
    <article>
      在上一节中，我们已经证明了所知道的所有关于加法和序的基本事实。为了节省篇幅以及避免赘述那些显然的事情，接下来我们将允许使用所熟悉的关于加法和序的代数法则，而不加进一步的说明。于是我们可以写出 a+b+c=c+b+a 这样的内容，不需要进一步解释说明。现在我们引入乘法。正如加法是重复的增量运算一样，乘法是重复的加法运算。
定义 2.3.1（自然数的乘法）
令 m 表示任意一个自然数，
我们定义 0\times m:= 0 来表示将 0 乘到 m 上。现在归纳假设我们已经定义了 n\times m （即把 n 乘到 m 上）。
那么，我们可以定义
(n++)\times m:= (n\times m)+m 以上，我们就定义好了自然数的乘法规则。
引理 2.3.2 （乘法是可交换的） 令 n 和 m 表示任意两个自然数，那么有 n\times m=m\times n 成立。
证明： 使用数学归纳法。
首先我们需要证明 m\times 0= 0 。当 m=0 时，我们有
0\times 0:= 0 归纳假设当 m=m 时 m\times 0= 0 是成立的，那么现在我们来证明 m=m++ 时等式成立。
\begin{align}(m++)\times 0&=(m\times 0)+0[(n++)\times m:= (n\times m)+m]\\&=0\end{align}以上，我们就得到了基础情况 0\times m=m\times 0 。 
    </article>
    <div>Read More</div>
  </a>
</li>

    
      <li class="post">
  
  <a href="http://localhost:1313/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/">
    <h2>
      3.1  基础知识
    </h2>
    <article>
      1.摘要 本文公理一览：
公理 3.1（集合是对象） 相等公理、替换公理 公理 3.2 (空集) 公理 3.3（单元素集与双元素集） 公理 3.4（两集合并集） 公理 3.5（分类公理） 公理 3.6 (替代) 公理 3.7 (无穷大) 2.正文 定义 3.1.1（非正式的）（集合）
我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \{3,8,5,2\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\in A ，否则，记作 x\notin A 。
这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。
首先阐明一个观点：我们把集合本身看作一类对象。
公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。
到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \in A 是无定义的。例如， 3 \in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。） 
    </article>
    <div>Read More</div>
  </a>
</li>

    
  </ul>
</div>

<div class="comments" data-articleurl="/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/">
  <h2>Comments</h2>
  
  
  
    
  

  
  
  
  

    <template id="comment-success">
      <div class="success">
        您的评论已成功提交审核。(´｡• ᵕ •｡`)
      </div>
    </template>
    <template id="comment-error">
      <div class="error">
        啊，好像出了些问题，请您调整后重试。(；′⌒`)
      </div>
    </template>

    <form id="comment-form" data-dynamic-form data-success="#comment-success" data-error="#comment-error" netlify="true" name="Comments" method="POST" style="margin-top: 20px;">
  
      <div id="reply-to" style="display: none; color: #6c757d; margin-bottom: 10px;"></div> 
      
      <input type="hidden" name="url" value="/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/">
      <input type="hidden" name="parent" id="parent" value="">
      <input type="hidden" name="custom" id="custom">
      <input type="hidden" name="depth" id="depth" value="0">
      <input type="hidden" name="articleurl" value="/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/">

      
      <label class="comment-label" for="name">Name:</label>
      <input class="comment-input" type="text" id="name" name="name" required autocomplete="name">
      
      <label class="comment-label" for="email">Email:</label>
      <input class="comment-input" type="email" id="email" name="email" required autocomplete="email">
      
      <label class="comment-label" for="comment">Comment:</label>
      <textarea class="comment-textarea" id="comment" name="comment" rows="5" required autocomplete="off"></textarea>
      
      <button class="comment-button" type="submit">Send</button>
    </form>
    
  
</div>
<script>
  
  
  function generateUniqueId() {
    return `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }



document.querySelectorAll(".reply-button").forEach(button => {
  button.addEventListener("click", function() {
    
    const parentComment = this.closest('.comment');

    
    const parentId = this.getAttribute('data-custom');
    const parentName = this.getAttribute('data-name');

    
    const parentDepth = parseInt(parentComment.getAttribute('data-depth')) || 0;

    
    document.getElementById('parent').value = parentId || "";
    console.log("Parent ID set to:", parentId); 

    
    const newDepth = parentDepth + 1;

    
    document.getElementById('depth').value = newDepth;

    
    const replyToElement = document.getElementById('reply-to');
    replyToElement.style.display = 'block';
    replyToElement.innerText = `回复 @${parentName}`;

    
    document.querySelectorAll('.comment').forEach(comment => {
      comment.classList.remove('highlight');
    });
    this.closest('.comment').classList.add('highlight');
  });

    
    document.getElementById('comment-form').scrollIntoView({ behavior: 'smooth' });
  });


  
  document.getElementById("comment-form").addEventListener("submit", function(event) {
    
    const customIdField = document.getElementById("custom");
    if (!customIdField.value) {
        customIdField.value = generateUniqueId();
        console.log("Custom ID set to:", customIdField.value); 
    }
});

window.onload = function() {
    
    const commentsContainer = document.querySelector('.comments'); 
    const articleurl = commentsContainer.dataset.articleurl.replace(/\/$/, '').toLowerCase(); 
    const commentForm = document.querySelector('#comment-form'); 
    const footer = document.querySelector('footer'); 

    
    const allComments = Array.from(document.querySelectorAll('.comment, .child-comment'));

    
    const filteredComments = allComments.filter(comment => {
    const commentArticleUrl = comment.dataset.articleurl.replace(/\/$/, '').toLowerCase();
    return commentArticleUrl === articleurl;
});

    
    commentsContainer.innerHTML = '';

    
    const topLevelComments = filteredComments.filter(comment => comment.dataset.depth === '0');
    topLevelComments.forEach(topLevelComment => {
        commentsContainer.appendChild(topLevelComment);

        
        const childComments = filteredComments.filter(comment => comment.dataset.parent === topLevelComment.dataset.custom);
        childComments.forEach(childComment => {
            childComment.classList.add('child-comment'); 
            commentsContainer.appendChild(childComment);
        });
    });

    
    commentsContainer.appendChild(commentForm);
    commentsContainer.appendChild(footer);

    
    commentsContainer.style.display = 'none';
    commentsContainer.offsetHeight; 
    commentsContainer.style.display = '';

    
    
};

  </script>




<script src="/js/footnotes.js"></script>

    
      <footer class="dark">
         
  <nav>
    
    <ul>
    
      <li>
        <a href="/reference">引用资料列表</a>
        
      </li>
    
      <li>
        <a href="/categories">教材索引</a>
        
      </li>
    
      <li>
        <a href=""></a>
        
      </li>
    
    </ul> 
  </nav>


        <ul>
          
            <li>
              <a href="https://facebook.com/example" aria-label="Facebook">
                <i class="  icon-facebook"></i>
              </a>
            </li>
          
          
            <li>
              <a href="https://x.com/i/flow/login" aria-label="Twitter">
                <i class="icon-twitter"></i>
              </a>
            </li>
          
          
            <li>
              <a href="mailto:chiaralee953@foxmail.com" aria-label="email">
                <i class="icon-email"></i>
              </a>
            </li>
          
        </ul>
        <div>Copyright © 2024 Caleton Academy of Magic.</div>
    </footer>
  
  </body>
</html>
