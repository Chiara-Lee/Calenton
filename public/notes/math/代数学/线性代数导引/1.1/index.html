<!DOCTYPE html>
<html lang="zh">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    
      <meta name="description" content="在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。
1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。
数学中的语句按照分支被分为各自分支中的基本语句和复合语句。
具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\cdot7&#43;2\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 &lt; 来表征小于的线性序关系，那么 1&#43;2&lt;2&#43;3 、 5\cdot2&lt;5\cdot3 就都是基础语句。
复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如
\begin{array}{l}((5 \cdot 2&lt;3 \cdot 2) \rightarrow(0=1)) \\((5 \cdot 2&lt;3 \cdot 2) \leftrightarrow(0=1)) \\((5 \cdot 2&lt;3 \cdot 2) \vee(\neg(0=1))) \\((5 \cdot 2&lt;3 \cdot 2) \wedge(\neg(0=1)))\end{array}就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：
\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且) 其中，
1.符号&quot; \neg &quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”
2.符号&quot; \rightarrow &quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”
3.符号&quot; \leftrightarrow &quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思
4.符号&quot; \vee &quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”
5.符号&quot; \wedge &quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”
基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：
\begin{array}{l}5\cdot7&#43;2\cdot3=41\\5\cdot3=11\end{array}在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \{0,1\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。">
    
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/png" href="http://localhost:1313/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png">
      
      <link rel="stylesheet" href="/css/index.css">
      
      <link rel="stylesheet" href="/css/categories.css">
      
      <link rel="stylesheet" href="/css/comment.css">
      
      <link rel="stylesheet" href="/css/page-main.css">
      
      <link rel="stylesheet" href="/css/pagination.css">
      
      <link rel="stylesheet" href="/css/profile-card.css">
      
      <link rel="stylesheet" href="/css/relative.css">
      
      <link rel="stylesheet" href="/css/search.css">
      
      <link rel="stylesheet" href="/css/about.css">
      
      <link rel="stylesheet" href="/css/post-card.css">
      
      <link rel="stylesheet" href="/css/markdown.css">
      
      <link rel="stylesheet" href="/css/friends.css">
      
      <link rel="stylesheet" href="/css/latex.css">
      
    
    <title>1.1  逻辑基础</title>
    
    
    <script type="text/javascript" src="/index.js" defer></script>
  </head>
  <body class=" page ">
    
      <header>
      <a href="/">
      <img src="http://localhost:1313//image/logo.png" alt="Calenton Logo" 
      style="width: 180px;height:160px;" />
      Caleton Academy
      </a>
      <span id="search">
        <input type="search" placeholder="Search">
      <div></div>
      </span>
       
  <nav>
    
      <button class="hamburger">&#9776;</button>
    
    <ul>
    
      <li>
        <a href="/notes">笔记</a>
        
          <ul>
            
              <li><a href="/notes/computer-science-and-technology/">Cst</a></li>
            
              <li><a href="/notes/math/">Math</a></li>
            
              <li><a href="/notes/physcis/">Physics</a></li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/thoughts">思考碎片</a>
        
      </li>
    
      <li>
        <a href="/friends">友人帐</a>
        
      </li>
    
      <li>
        <a href="/about">关于</a>
        
      </li>
    
    </ul> 
  </nav>


      </header>
      
    
<main>
  
  
  
    <h1>
      1.1  逻辑基础
    </h1>
  
  
    <h2>Table of Contents</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#111-语句真假判定">1.1.1 语句真假判定</a>
      <ul>
        <li><a href="#基本语句的真假判定">基本语句的真假判定</a></li>
        <li><a href="#复合语句真假判定归结过程">复合语句真假判定归结过程</a></li>
      </ul>
    </li>
    <li><a href="#112-表达式及其语义解释">1.1.2 表达式及其语义解释</a>
      <ul>
        <li><a href="#基本表达式及其语义解释">基本表达式及其语义解释</a></li>
        <li><a href="#量词与表达式">量词与表达式</a></li>
        <li><a href="#自由变元与约束变元">自由变元与约束变元</a></li>
        <li><a href="#表达式语义解释与真假判定">表达式语义解释与真假判定</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
<div class="content-wrapper">
  <div class="content">
    <p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。</p>
<h2 id="111-语句真假判定">1.1.1 语句真假判定</h2>
<p>在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。</p>
<p>数学中的语句按照分支被分为各自分支中的<strong>基本语句</strong>和<strong>复合语句</strong>。</p>
<p>具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如
     
     
       
     
     
     
       <span class="fallback-latex">
         5\cdot7+2\cdot3=41
       </span>
     
     
     就是一个基本语句。如果还涉及到线性序，例如用
     
     
       
     
     
     
       <span class="fallback-latex">
         <
       </span>
     
     
     来表征小于的线性序关系，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         1+2<2+3
       </span>
     
     
     、
     
     
       
     
     
     
       <span class="fallback-latex">
         5\cdot2<5\cdot3
       </span>
     
     
     就都是基础语句。</p>
<p>复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1)))\end{array}
       </span>
     
     
     
<p>就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且)
       </span>
     
     
     
<p>其中，</p>
<p>1.符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \neg
       </span>
     
     
     &quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”</p>
<p>2.符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \rightarrow
       </span>
     
     
     &quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”</p>
<p>3.符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \leftrightarrow
       </span>
     
     
     &quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思</p>
<p>4.符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \vee
       </span>
     
     
     &quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”</p>
<p>5.符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \wedge
       </span>
     
     
     &quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”</p>
<h3 id="基本语句的真假判定">基本语句的真假判定</h3>
<p>在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
5\cdot7+2\cdot3=41\\
5\cdot3=11
\end{array}

       </span>
     
     
     
<p>在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域
     
     
       
     
     
     
       <span class="fallback-latex">
         \{0,1\}
       </span>
     
     
     上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。
在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。<strong>若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。</strong></p>
<h3 id="复合语句真假判定归结过程">复合语句真假判定归结过程</h3>
<p>复合语句的真假判定依赖于复合语句的布尔值计算规则。</p>
<p>同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。</p>
<p>我们约定用
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     来表示真，用
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     来表示假。并且
     
     
       
     
     
     
       <span class="fallback-latex">
         1\ne 0
       </span>
     
     
     。复合语句的真假赋值必须遵从以下五条计算等式规则：</p>
<p>1.否定词计算规则：‘并非’</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     是一个已经被赋值了的较低层次的逻辑命题，那么对于
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的否定式
     
     
       
     
     
     
       <span class="fallback-latex">
         (\neg A)
       </span>
     
     
     的赋值必须满足下述<strong>背反等式</strong>的要求：</p>
<p>对
     
     
       
     
     
     
       <span class="fallback-latex">
         (\neg A)
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     的充要条件是对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     ,对
     
     
       
     
     
     
       <span class="fallback-latex">
         (\neg A)
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     的充要条件是对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     
<img src="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/1.png"></p>
<p>2.蕴含词计算规则：‘如果，那么’</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式
     
     
       
     
     
     
       <span class="fallback-latex">
         (A\rightarrow B)
       </span>
     
     
     的真值赋值必须满足下述<strong>蕴含等式要求</strong>：对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A\rightarrow B)
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     的充分必要条件是 “(对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     ，对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     )”。
<img src="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/2.png"></p>
<p>在蕴含赋值计算表中，我们将蕴含式
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \to B)
       </span>
     
     
     放于最右侧是因为，
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \to B)
       </span>
     
     
     命题的层级比
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     都高，对于
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \to B)
       </span>
     
     
     的真值的赋值依赖于对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。</p>
<p>3.析取词计算规则：‘要么，要么’</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     是已经被赋值了的较低层级的逻辑命题，那么它们的析取式
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \lor B)
       </span>
     
     
     的赋值必须满足下述<strong>析取等式要求</strong>：对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \lor B)
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     的充分必要条件是 “（或对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     ，或对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     ）”，对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \lor B)
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     的充分必要条件是 “（或对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     ，并且对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值也为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     ）”。</p>
<p><img src="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/3.png"></p>
<p>4.合取词计算规则：‘不仅，而且’</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     是已经被赋值了的较低层级的逻辑命题，那么他们的合取式
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \land B)
       </span>
     
     
     的赋值必须满足以下<strong>合取等式要求</strong>：对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \land B)
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     的充分必要条件是 “（对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     ，并且对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值也为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     ）”，对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \land B)
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     的充分必要条件是 “（或对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     ，或对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     ）”。</p>
<p><img src="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/4.png"></p>
<p>5.对等词计算规则：‘当且仅当’</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     是已经被赋值了的较低层级的逻辑命题，那么它们的对等式
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \leftrightarrow B)
       </span>
     
     
     的赋值必须满足以下<strong>对等等式要求</strong>：对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \leftrightarrow B)
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         1
       </span>
     
     
     的充分必要条件是 “（对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值是相等的）”，对
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \leftrightarrow B)
       </span>
     
     
     赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         0
       </span>
     
     
     的充分必要条件是 “（对
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和对
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     的赋值是不相等的）”。</p>
<p><img src="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/5.png"></p>
<p>从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
1. \, A \, \text{与} \, (\neg(\neg A)) \, \text{等价} \\
2. \, (A \to B) \, \text{与} \, ((\neg B) \to (\neg A)) \, \text{等价} \\
3. \, (A \lor B) \, \text{与} \, (B \lor A) \, \text{等价} \\
4. \, (A \land B) \, \text{与} \, (B \land A) \, \text{等价} \\
5. \, (A \leftrightarrow B) \, \text{与} \, (B \leftrightarrow A) \, \text{等价}
\end{array}

       </span>
     
     
     
<p>另外两条规律也值得注意：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
6. \, \text{如果} \, (A \to B) \, \text{并且} \, (B \to C), \, \text{则} \, (A \to C) \\
7. \, \text{如果} \, (A \leftrightarrow B) \, \text{并且} \, (B \leftrightarrow C), \, \text{则} \, (A \leftrightarrow C)
\end{array}

       </span>
     
     
     
<p>在数学逻辑中，我们实际上可以只要一条基本的推导规则：由
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         (A \to B)
       </span>
     
     
     导出
     
     
       
     
     
     
       <span class="fallback-latex">
         B
       </span>
     
     
     来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。</p>
<p>另外还需要注意，人们时常使用
     
     
       
     
     
     
       <span class="fallback-latex">
         \Leftarrow
       </span>
     
     
     代替
     
     
       
     
     
     
       <span class="fallback-latex">
         \leftarrow
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         \Rightarrow
       </span>
     
     
     代替
     
     
       
     
     
     
       <span class="fallback-latex">
         \rightarrow
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         \Leftrightarrow
       </span>
     
     
     代替
     
     
       
     
     
     
       <span class="fallback-latex">
         \leftrightarrow
       </span>
     
     
     。</p>
<h2 id="112-表达式及其语义解释">1.1.2 表达式及其语义解释</h2>
<h3 id="基本表达式及其语义解释">基本表达式及其语义解释</h3>
<p>一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。</p>
<p>比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         x+(y+z)=(x+y)+z\\
       </span>
     
     
     
<p>当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。</p>
<p>前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如，
     
     
       
     
     
     
       <span class="fallback-latex">
         x+y=y+x
       </span>
     
     
     这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?</p>
<p>在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为<strong>论域</strong>。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的<strong>结构</strong>就是线性代数的基本对象。</p>
<p>因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。</p>
<p>第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         1，2，3\cdots2024\cdots\\
       </span>
     
     
     
<p>为一个<strong>项</strong>。</p>
<p>任何一个被用来表示任意个体的变量（符号），比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         x,y,z,A,B,C\cdots \\
       </span>
     
     
     
<p>也是一个<strong>项</strong>。</p>
<p>然后，由任意两个已有的项
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         t_2
       </span>
     
     
     经过加法、乘法运算就可以得到新的项</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         t_1+t_2,t_1\cdot t_2 \\
       </span>
     
     
     
<p>最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
a_1x_1+a_2x_2+\cdots+a_nx_n\\
x^m+b_1x^m+\cdots+b_{m-1}x_1
\end{array}

       </span>
     
     
     
<p>就是两个项。</p>
<p>第二，我们规定，任何一个<strong>基本表达式</strong>无非就是由两个项所组成的一个等式，比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
a_1x_1+a_2x_2+\cdots a_nx_n=1,\\
x_m+\cdots+b_m=0\\
\end{array}

       </span>
     
     
     
<p>如果我们还关心诸如实数的线性序（例如
     
     
       
     
     
     
       <span class="fallback-latex">
         <
       </span>
     
     
     就是被用来表达线性序的符号），那么任何一个涉及<strong>线性序的基本表达式</strong>就是由两个项所组成的不等式。比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}a_1x_1+\cdots+a_nx_n<0,\\b_1m_1+\cdots+b_2m_2>x_1+\cdots+x_n\\\end{array}
       </span>
     
     
     
<p>不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种<strong>基本表达式</strong>：<strong>项之间的等式、项之间的不等式</strong>。以上两种基本表达式我们就分别称之为基本等式和基本不等式。</p>
<p>第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。</p>
<p>第四，在前述的基础上，我们来解决基本表达式的真假判定问题。</p>
<p>给定一个基本表达式，令
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1(x_1, \cdots, x_n)
       </span>
     
     
     、
     
     
       
     
     
     
       <span class="fallback-latex">
         t_2(x_1, \cdots, x_n)
       </span>
     
     
     为所涉及的两个项，并且约定，无论是
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1
       </span>
     
     
     还是
     
     
       
     
     
     
       <span class="fallback-latex">
         t_2
       </span>
     
     
     ，在项中出现的所有自变量都出自变量
     
     
       
     
     
     
       <span class="fallback-latex">
         x_1, \cdots, x_n
       </span>
     
     
     中。那么这
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     个变量就可以彼此独立地在实数范围内取任何值。</p>
<p>我们规定任何一个实数的
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     -元组
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     就是上述
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     个变量的一组取值。我们称
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为
     
     
       
     
     
     
       <span class="fallback-latex">
         x_1, \cdots, x_n
       </span>
     
     
     的一组<strong>赋值</strong>或者<strong>解释</strong>。</p>
<p>并且，我们规定，记号
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1(a_1, \cdots, a_2)
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         t_2(a_1, \cdots, a_2)
       </span>
     
     
     分别用来标识由计算过程
     
     
       
     
     
     
       <span class="fallback-latex">
         t_i (i=1, 2)
       </span>
     
     
     以数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为输入所计算出来的结果，并且称
     
     
       
     
     
     
       <span class="fallback-latex">
         t_i
       </span>
     
     
     在数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     处的<strong>赋值</strong>或者<strong>解释</strong>。</p>
<p>在此基础上，我们称数值等式</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}

       </span>
     
     
     
<p>为基本等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 = t_2
       </span>
     
     
     在数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     处的<strong>语义解释</strong>。</p>
<p>类似的我们称数值不等式</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2)\end{array}
       </span>
     
     
     
<p>为基本不等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 < t_2
       </span>
     
     
     在数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     处的<strong>语义解释</strong>。</p>
<p>现在，我们就规定：</p>
<ol>
<li>基本等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 = t_2
       </span>
     
     
     相对于数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为真，当且仅当数值等式</li>
</ol>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}

       </span>
     
     
     
<p>的确成立。</p>
<ol start="2">
<li>基本等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 = t_2
       </span>
     
     
     相对于数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为假，当且仅当数值等式</li>
</ol>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
t_1(a_1, \cdots, a_2) = t_2(a_1, \cdots, a_2)
\end{array}

       </span>
     
     
     
<p>的确不成立。</p>
<ol start="3">
<li>基本不等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 < t_2
       </span>
     
     
     相对于数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为真，当且仅当数值不等式</li>
</ol>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2)\end{array}
       </span>
     
     
     
<p>的确成立。</p>
<ol start="4">
<li>基本不等式
     
     
       
     
     
     
       <span class="fallback-latex">
         t_1 < t_2
       </span>
     
     
     相对于数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     为假，当且仅当数值不等式</li>
</ol>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}t_1(a_1, \cdots, a_2) < t_2(a_1, \cdots, a_2)\end{array}
       </span>
     
     
     
<p>的确不成立。</p>
<h3 id="量词与表达式">量词与表达式</h3>
<p>前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入<strong>量词</strong>。</p>
<p>既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。</p>
<p>比如说考虑基本等式
     
     
       
     
     
     
       <span class="fallback-latex">
         x = y
       </span>
     
     
     和基本不等式
     
     
       
     
     
     
       <span class="fallback-latex">
         x < y
       </span>
     
     
     ，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。</p>
<p>我们将“存在”这个词作为一种量词引入数学，并且用符号
     
     
       
     
     
     
       <span class="fallback-latex">
         \exists
       </span>
     
     
     来表征“存在”：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}(\exists x (\exists y (x = y))), \\(\exists x (\exists y (x < y)))\end{array}
       </span>
     
     
     
<p>其中
     
     
       
     
     
     
       <span class="fallback-latex">
         \exists x, \exists y
       </span>
     
     
     就都被称为一个<strong>存在量词</strong>。一个存在量词由符号
     
     
       
     
     
     
       <span class="fallback-latex">
         \exists
       </span>
     
     
     与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号
     
     
       
     
     
     
       <span class="fallback-latex">
         ()
       </span>
     
     
     将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p>
<p>又比如，考虑基本等式
     
     
       
     
     
     
       <span class="fallback-latex">
         x + y = y + x
       </span>
     
     
     和基本不等式
     
     
       
     
     
     
       <span class="fallback-latex">
         0 < (x + y)^2
       </span>
     
     
     。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。</p>
<p>我们将“对于所有”这个短语作为一个量词引入，并且用符号
     
     
       
     
     
     
       <span class="fallback-latex">
         \forall
       </span>
     
     
     来表征这个短语：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}

       </span>
     
     
     
<p>其中，
     
     
       
     
     
     
       <span class="fallback-latex">
         \forall x, \forall y
       </span>
     
     
     就都被称为一个<strong>全称量词</strong>。一个全称量词由符号
     
     
       
     
     
     
       <span class="fallback-latex">
         \forall
       </span>
     
     
     和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号
     
     
       
     
     
     
       <span class="fallback-latex">
         ()
       </span>
     
     
     将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。</p>
<p>在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。</p>
<p>第一，每一个基本表达式都是一个表达式：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \begin{array}{l}(t_1 = t_2), \quad (t_1 < t_2) \quad (\text{为了规范起见，我们加上圆括号})\end{array}
       </span>
     
     
     
<p>第二，假设已经得到一个表达式，比如说这个表达式被记作
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     ，那么这个表达式的否定式
     
     
       
     
     
     
       <span class="fallback-latex">
         (\neg \varphi)
       </span>
     
     
     也是一个表达式。</p>
<p>第三，假设已经得到两个表达式，比如说它们被记为
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi
       </span>
     
     
     ，那么</p>
<p>(1) 
     
     
       
     
     
     
       <span class="fallback-latex">
         (\varphi \lor \psi)
       </span>
     
     
      是一个表达式<br>
(2) 
     
     
       
     
     
     
       <span class="fallback-latex">
         (\varphi \land \psi)
       </span>
     
     
      是一个表达式<br>
(3) 
     
     
       
     
     
     
       <span class="fallback-latex">
         (\varphi \to \psi)
       </span>
     
     
      是一个表达式</p>
<p>第四，假设已经得到一个表达式
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     ，
     
     
       
     
     
     
       <span class="fallback-latex">
         x
       </span>
     
     
     是一个变量符号，那么<br>
(1) 
     
     
       
     
     
     
       <span class="fallback-latex">
         (\exists x \varphi)
       </span>
     
     
      是一个表达式<br>
(2) 
     
     
       
     
     
     
       <span class="fallback-latex">
         (\forall x \varphi)
       </span>
     
     
      是一个表达式</p>
<p>最后，除了以上的规定，没有获得新的表达式的可能途径。</p>
<p>关于两个量词的否定，我们规定</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\neg (\forall x \varphi)) \text{ 即为 } (\exists x (\neg \varphi))
\end{array}

       </span>
     
     
     
<p>以及</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\neg (\exists x \varphi)) \text{ 即为 } (\forall x (\neg \varphi))
\end{array}

       </span>
     
     
     
<h3 id="自由变元与约束变元">自由变元与约束变元</h3>
<p>关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     和一个变量符号
     
     
       
     
     
     
       <span class="fallback-latex">
         x
       </span>
     
     
     ，假设这个
     
     
       
     
     
     
       <span class="fallback-latex">
         x
       </span>
     
     
     在表达式中出现若干次。</p>
<p>如果
     
     
       
     
     
     
       <span class="fallback-latex">
         x
       </span>
     
     
     在某一处的出现不在任何存在量词或全称量词的作用范围内，就称
     
     
       
     
     
     
       <span class="fallback-latex">
         x
       </span>
     
     
     为
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     的一个<strong>自由变量</strong>。反之，则被称为<strong>约束变量</strong>。</p>
<p>在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为<strong>语句</strong>。比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\forall x (\forall y (x + y = y + x)))
\end{array}

       </span>
     
     
     
<p>就是一个语句。</p>
<p>在应用中，我们常常会使用形如下述的<strong>受囿量词</strong>：</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
\forall x \in A, \quad \exists x \in A
\end{array}

       </span>
     
     
     
<p>这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     之中，并且通常
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\forall x \in A \varphi(x))
\end{array}

       </span>
     
     
     
<p>这个表达式实际上是</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
\forall x ((x \in A) \to \varphi(x))
\end{array}

       </span>
     
     
     
<p>同样的</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\exists x \in A \varphi(x)) \iff \exists x ((x \in A) \land \varphi(x))
\end{array}

       </span>
     
     
     
<p>更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。</p>
<h3 id="表达式语义解释与真假判定">表达式语义解释与真假判定</h3>
<p>仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。</p>
<p>我们现在设
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     是一个表达式，并且
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     中出现的任何的自由变元都来自
     
     
       
     
     
     
       <span class="fallback-latex">
         (x_1, x_2, \cdots, x_n)
       </span>
     
     
     中，设
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, a_2, \cdots, a_n)
       </span>
     
     
     是实数的一个
     
     
       
     
     
     
       <span class="fallback-latex">
         n
       </span>
     
     
     元组。我们将
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi
       </span>
     
     
     中出现的自由变元
     
     
       
     
     
     
       <span class="fallback-latex">
         x_i
       </span>
     
     
     进行赋值，使得自由变元
     
     
       
     
     
     
       <span class="fallback-latex">
         x_i
       </span>
     
     
     被相应的赋值为
     
     
       
     
     
     
       <span class="fallback-latex">
         a_i
       </span>
     
     
     ，这时
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     就是对
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, a_2, \cdots, a_n)
       </span>
     
     
     的性质描述，其中没有任何的需要特定赋值的自由变元。</p>
<p>我们将根据表达式
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     构造中可能存在的结构来规定如何判定</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     
<p>的真假。</p>
<p>(1) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     是一个基本表达式，那么
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     的真假已经在前文被确定好了。</p>
<p>(2) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     是表达式
     
     
       
     
     
     
       <span class="fallback-latex">
         \phi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     的否定式，即
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi = (\neg \phi)
       </span>
     
     
     并且
     
     
       
     
     
     
       <span class="fallback-latex">
         \phi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     的真假已经被确定，则<br>
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \phi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \phi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真</p>
<p>(3) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi(x_1, x_2, \cdots, x_n)
       </span>
     
     
     是由两个表达式
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1(x_1, x_2, \cdots, x_n)
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2(x_1, x_2, \cdots, x_n)
       </span>
     
     
     通过联结词
     
     
       
     
     
     
       <span class="fallback-latex">
         \lor
       </span>
     
     
     联结而成，即
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi = (\psi_1 \lor \psi_2)
       </span>
     
     
     ，并且
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     的真假已经确定，那么<br>
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，或者
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，并且
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假</p>
<p>(4) 把上述推导的联结词换成
     
     
       
     
     
     
       <span class="fallback-latex">
         \land
       </span>
     
     
     ，那么
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，并且
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，或者
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假</p>
<p>(5) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi = (\psi_1 \to \psi_2)
       </span>
     
     
     ，则<br>
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，或者
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，当且仅当
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_1[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，但是
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi_2[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假</p>
<p>(6) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi = (\forall y \psi)
       </span>
     
     
     ，则<br>
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，当且仅当对每一个实数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     都有
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，当且仅当存在一个实数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     使得
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假</p>
<p>(7) 如果
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi = (\exists y \psi)
       </span>
     
     
     ，则<br>
 (a) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真，当且仅当存在一个实数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     使得
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为真<br>
 (b) 
     
     
       
     
     
     
       <span class="fallback-latex">
         \varphi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假，当且仅当对每一个实数
     
     
       
     
     
     
       <span class="fallback-latex">
         a
       </span>
     
     
     都有
     
     
       
     
     
     
       <span class="fallback-latex">
         \psi[a_1, a_2, \cdots, a_n]
       </span>
     
     
     为假</p>
<p>当一个表达式在一组数据
     
     
       
     
     
     
       <span class="fallback-latex">
         (a_1, \cdots, a_n)
       </span>
     
     
     下为真时，我们说这组数据满足表达式。反之则不满足。</p>
<p>比如，下面这三句话在任何地方都是真语句，<strong>只要涉及到等号，下面三个语句就都为真</strong>。</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{array}{l}
(\forall x (x = x)) \\
(\forall x (\forall y ((x = y) \to (y = x)))) \\
(\forall x (\forall y (\forall z (((x = y) \land (y = z)) \to (x = z)))))
\end{array}

       </span>
     
     
     
<p>这三句话称为<strong>基本等号律</strong>，也称<strong>同一律</strong>。</p>

  </div>
      
      <aside class="sidebar">
        <div class="card">
          <h2>摘要</h2>
          <p>在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领 …</p> 
        </div>
        <div class="card">
          <h2>阅读时长</h2>
          <p>6 min</p> 
        </div>
        <div class="card">
          <h2>总字数</h2>
          <p>≈ 1233</p> 
        </div>
        <div class="card">
          <h2>标签</h2>
          <p>
            
              <a href="#">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-tag" viewBox="0 0 16 16">
                  <path d="M3 2a1 1 0 0 0-1 1v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 8.586 2H3zm1 1h4.586L14 8.414l-4.586 4.586-6-6V3z"/>
                  <path d="M5.5 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                </svg>
                代数学
              </a>
            
          </p>
        </div>
      </aside>
    </div>
</div>
</main>

<div id="related">
  <h2>Related Pages</h2>
  <ul class="posts">
    
      <li class="post">
  
  <a href="http://localhost:1313/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/">
    <h2>
      1.1 皮亚诺公理
    </h2>
    <article>
      在学习实数分析之前，我们首先要回溯数的概念以及数的性质。
我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?
实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。
现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。
自然数集定义 定义 2.1.1 （非正式的）自然数是集合
N := \{ 0, 1, 2, 3, \cdots \}的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。
注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \{1, 2, 3, \cdots \} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。
从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：
N 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？
我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？
我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：
a^3 = a \cdot a \cdot a 。
乘法运算只不过是对加法运算的重复迭代：
3 \cdot a = a + a + a 。 
    </article>
    <div>Read More</div>
  </a>
</li>

    
      <li class="post">
  
  <a href="http://localhost:1313/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.1/">
    <h2>
      1.1 (web)style 简史
    </h2>
    <article>
      层叠样式表（Cascading Style Sheets，CSS）是一种强大的编程语言，可用于改变文档或文档集合的呈现方式，它几乎已经渗透到网络的每个角落以及许多表面上非网络的环境中。例如，嵌入式设备的显示通常使用 CSS 来设计其用户界面，许多 RSS 客户端允许你对订阅源和订阅条目应用 CSS，一些即时消息客户端使用 CSS 来格式化聊天窗口。CSS 的某些方面甚至可以在 JavaScript (JS) 框架的语法中以及 JS 本身中找到。它无处不在！
CSS 最早在 1994 年被提出，当时正值互联网开始真正流行之际。当时，浏览器赋予用户大量的样式控制能力——例如，NCSA Mosaic 的显示偏好允许用户定义每种元素的字体系列、大小和颜色。而文档作者却没有任何这样的能力；他们只能将内容标记为段落、某一级别的标题、预格式化文本或其他十几种元素类型之一。如果用户将其浏览器配置为使所有一级标题变得又小又粉红，而所有六级标题变得又大又红，那完全是用户自己的选择。
CSS 正是在这种环境中被引入的。其目标是为网页作者提供一种简单的声明式样式语言，既灵活又强大，最重要的是，能够同时为作者和用户提供样式控制能力。通过层叠机制，这些样式可以被组合和优先排序，使网站作者和读者都能表达自己的需求——尽管最终的决定权始终在读者手中。
工作迅速推进，到 1996 年底，CSS1 已经完成。尽管新成立的 CSS 工作组继续推进 CSS2 的开发，但浏览器在以互操作性方式实现 CSS1 时遇到了困难。尽管 CSS 的每个部分本身都相对简单，但它们的组合却产生了一些令人意想不到的复杂行为。不幸的是，还出现了一些问题，比如臭名昭著的盒模型实现差异。这些问题一度威胁到 CSS 的发展，但幸运的是，一些巧妙的提议被实施，浏览器开始趋于一致。在接下来的几年里，随着互操作性的增强以及像《Wired》杂志基于 CSS 的重新设计和 CSS Zen Garden 等高调发展项目的推动，CSS 开始流行起来。
在这一切发生之前，CSS 工作组于 1998 年初完成了 CSS2 规范。CSS2 甫一完成，随即开始了 CSS3 的开发以及一个经过澄清的版本 CSS2.1 的工作。与当时的潮流一致，最初称为 CSS3 的规范被设计为一系列（理论上）独立的模块，而不是一个庞大的整体规范。这种方法反映了当时活跃的 XHTML 规范，它也因类似的原因被分解为模块。
对 CSS 进行模块化的理由是，每个模块可以按照自己的节奏进行开发，特别是重要或流行的模块可以沿着万维网联盟（W3C）的进展路径快速推进，而不会被其他模块拖延。事实上，这种方式确实奏效了。截至 2012 年初，已有三个 CSS Level 3 模块（以及 CSS1 和 CSS 2. 
    </article>
    <div>Read More</div>
  </a>
</li>

    
  </ul>
</div>

<div class="comments" data-articleurl="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/">
  <h2>Comments</h2>
  
  
  
    
  

  
  
  
  

    <template id="comment-success">
      <div class="success">
        您的评论已成功提交审核。(´｡• ᵕ •｡`)
      </div>
    </template>
    <template id="comment-error">
      <div class="error">
        啊，好像出了些问题，请您调整后重试。(；′⌒`)
      </div>
    </template>

    <form id="comment-form" data-dynamic-form data-success="#comment-success" data-error="#comment-error" netlify="true" name="Comments" method="POST" style="margin-top: 20px;">
  
      <div id="reply-to" style="display: none; color: #6c757d; margin-bottom: 10px;"></div> 
      
      <input type="hidden" name="url" value="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/">
      <input type="hidden" name="parent" id="parent" value="">
      <input type="hidden" name="custom" id="custom">
      <input type="hidden" name="depth" id="depth" value="0">
      <input type="hidden" name="articleurl" value="/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/">

      
      <label class="comment-label" for="name">Name:</label>
      <input class="comment-input" type="text" id="name" name="name" required autocomplete="name">
      
      <label class="comment-label" for="email">Email:</label>
      <input class="comment-input" type="email" id="email" name="email" required autocomplete="email">
      
      <label class="comment-label" for="comment">Comment:</label>
      <textarea class="comment-textarea" id="comment" name="comment" rows="5" required autocomplete="off"></textarea>
      
      <button class="comment-button" type="submit">Send</button>
    </form>
    
  
</div>
<script>
  
  
  function generateUniqueId() {
    return `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }



document.querySelectorAll(".reply-button").forEach(button => {
  button.addEventListener("click", function() {
    
    const parentComment = this.closest('.comment');

    
    const parentId = this.getAttribute('data-custom');
    const parentName = this.getAttribute('data-name');

    
    const parentDepth = parseInt(parentComment.getAttribute('data-depth')) || 0;

    
    document.getElementById('parent').value = parentId || "";
    console.log("Parent ID set to:", parentId); 

    
    const newDepth = parentDepth + 1;

    
    document.getElementById('depth').value = newDepth;

    
    const replyToElement = document.getElementById('reply-to');
    replyToElement.style.display = 'block';
    replyToElement.innerText = `回复 @${parentName}`;

    
    document.querySelectorAll('.comment').forEach(comment => {
      comment.classList.remove('highlight');
    });
    this.closest('.comment').classList.add('highlight');
  });

    
    document.getElementById('comment-form').scrollIntoView({ behavior: 'smooth' });
  });


  
  document.getElementById("comment-form").addEventListener("submit", function(event) {
    
    const customIdField = document.getElementById("custom");
    if (!customIdField.value) {
        customIdField.value = generateUniqueId();
        console.log("Custom ID set to:", customIdField.value); 
    }
});

window.onload = function() {
    
    const commentsContainer = document.querySelector('.comments'); 
    const articleurl = commentsContainer.dataset.articleurl.replace(/\/$/, '').toLowerCase(); 
    const commentForm = document.querySelector('#comment-form'); 
    const footer = document.querySelector('footer'); 

    
    const allComments = Array.from(document.querySelectorAll('.comment, .child-comment'));

    
    const filteredComments = allComments.filter(comment => {
    const commentArticleUrl = comment.dataset.articleurl.replace(/\/$/, '').toLowerCase();
    return commentArticleUrl === articleurl;
});

    
    commentsContainer.innerHTML = '';

    
    const topLevelComments = filteredComments.filter(comment => comment.dataset.depth === '0');
    topLevelComments.forEach(topLevelComment => {
        commentsContainer.appendChild(topLevelComment);

        
        const childComments = filteredComments.filter(comment => comment.dataset.parent === topLevelComment.dataset.custom);
        childComments.forEach(childComment => {
            childComment.classList.add('child-comment'); 
            commentsContainer.appendChild(childComment);
        });
    });

    
    commentsContainer.appendChild(commentForm);
    commentsContainer.appendChild(footer);

    
    commentsContainer.style.display = 'none';
    commentsContainer.offsetHeight; 
    commentsContainer.style.display = '';

    
    
};

  </script>




    
      <footer class="dark">
         
  <nav>
    
    <ul>
    
      <li>
        <a href="/categories">目录</a>
        
      </li>
    
      <li>
        <a href="/reference">引用资料列表</a>
        
      </li>
    
      <li>
        <a href="/categories">教材索引</a>
        
      </li>
    
    </ul> 
  </nav>


        <ul>
          
            <li>
              <a href="https://facebook.com/example" aria-label="Facebook">
                <i class="  icon-facebook"></i>
              </a>
            </li>
          
          
            <li>
              <a href="https://x.com/i/flow/login" aria-label="Twitter">
                <i class="icon-twitter"></i>
              </a>
            </li>
          
          
            <li>
              <a href="mailto:chiaralee953@foxmail.com" aria-label="email">
                <i class="icon-email"></i>
              </a>
            </li>
          
        </ul>
        <div>Copyright © 2024 Caleton Academy of Magic.</div>
    </footer>
  
  </body>
</html>
