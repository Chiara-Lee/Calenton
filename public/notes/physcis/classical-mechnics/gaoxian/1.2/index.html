<!DOCTYPE html>
<html lang="zh">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    
      <meta name="description" content="函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。
若函数 f(t) 变成了另一个函数 f(t)\longrightarrow \tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \delta f 被定义为
\delta f(t):=\tilde{f(t)}-f(t)\\ 上式中的变分符号&quot; \delta &quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \delta f 是作为另一个函数存在的。
函数的变分 \delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变
f(t)\xrightarrow{t\rightarrow t&#43;dt}f(t&#43;dt) =f(t)&#43;df(t)&#43;\cdots\\ 而函数的变分 \delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关
f(t)\rightarrow\tilde{f(t)}\equiv(f&#43;\delta f)(t)=f(t)&#43;\delta f(t)\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如
\delta (f^n)=nf^{n-1}\delta f\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有
\begin{align}\delta(af_1&#43;bf_2)=a\delta f_1&#43;b\delta f_2\\ \delta(f_1f_2)=(\delta f_1)f_2&#43;f_1(\delta f_2)\end{align}\\另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“
d(\delta f)=\delta(df)\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B&#39; 点的差，即">
    
    <meta name="viewport" 
      content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/png" href="http://localhost:1313/image/favicon_huf6346096f3d7b7acad7cedced168daa3_32661_e417e70d9bed0e84d471438e1d707785.png">
      
      <link rel="stylesheet" href="/css/index.css">
      
      <link rel="stylesheet" href="/css/categories.css">
      
      <link rel="stylesheet" href="/css/comment.css">
      
      <link rel="stylesheet" href="/css/page-main.css">
      
      <link rel="stylesheet" href="/css/pagination.css">
      
      <link rel="stylesheet" href="/css/profile-card.css">
      
      <link rel="stylesheet" href="/css/relative.css">
      
      <link rel="stylesheet" href="/css/search.css">
      
      <link rel="stylesheet" href="/css/about.css">
      
      <link rel="stylesheet" href="/css/post-card.css">
      
      <link rel="stylesheet" href="/css/markdown.css">
      
      <link rel="stylesheet" href="/css/friends.css">
      
      <link rel="stylesheet" href="/css/latex.css">
      
    
    <title>1.2 变分</title>
    
    
    <script type="text/javascript" src="/index.js" defer></script>
  </head>
  <body class=" page ">
    
      <header>
      <a href="/">
      <img src="http://localhost:1313//image/logo.png" alt="Calenton Logo" 
      style="width: 180px;height:160px;" />
      Caleton Academy
      </a>
      <span id="search">
        <input type="search" placeholder="Search">
      <div></div>
      </span>
       
  <nav>
    
      <button class="hamburger">&#9776;</button>
    
    <ul>
    
      <li>
        <a href="/notes">笔记</a>
        
          <ul>
            
              <li><a href="/notes/math/">Math</a></li>
            
              <li><a href="/notes/physcis/">Physics</a></li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/thoughts">思考碎片</a>
        
      </li>
    
      <li>
        <a href="/friends">友人帐</a>
        
      </li>
    
      <li>
        <a href="/about">关于</a>
        
      </li>
    
    </ul> 
  </nav>


      </header>
      
    
<main>
  
  
  
    <h1>
      1.2 变分
    </h1>
  
  
<div class="content-wrapper">
  <div class="content">
    <p>函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是<strong>变分（variation）</strong>。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。</p>
<p>若函数
     
     
       
     
     
     
       <span class="fallback-latex">
          f(t) 
       </span>
     
     
     变成了另一个函数
     
     
       
     
     
     
       <span class="fallback-latex">
          f(t)\longrightarrow \tilde{f(t)} 
       </span>
     
     
     ，且假设两者相差无穷小。则函数
     
     
       
     
     
     
       <span class="fallback-latex">
          f(t) 
       </span>
     
     
     的变分
     
     
       
     
     
     
       <span class="fallback-latex">
          \delta f 
       </span>
     
     
     被定义为</p>

     
     
       
     
     
     
       <span class="fallback-latex">
          \delta f(t):=\tilde{f(t)}-f(t)\\ 
       </span>
     
     
     
<p>上式中的变分符号&quot;
     
     
       
     
     
     
       <span class="fallback-latex">
         \delta
       </span>
     
     
     &quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分
     
     
       
     
     
     
       <span class="fallback-latex">
         \delta f
       </span>
     
     
     是作为另一个函数存在的。</p>
<p>函数的变分
     
     
       
     
     
     
       <span class="fallback-latex">
         \delta f
       </span>
     
     
     和微分
     
     
       
     
     
     
       <span class="fallback-latex">
         df
       </span>
     
     
     同为无穷小变化，但是具有本质上的区别
<img src="/notes/physcis/classical-mechnics/gaoxian/1.2/1.png"></p>
<p>函数的微分
     
     
       
     
     
     
       <span class="fallback-latex">
         df(t)
       </span>
     
     
     是由自变量 t 的变化引起的，函数本身固定不变</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         f(t)\xrightarrow{t\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\cdots\\
       </span>
     
     
     
<p>而函数的变分
     
     
       
     
     
     
       <span class="fallback-latex">
         \delta f(t)
       </span>
     
     
     是因为函数本身发生了无穷小变化，而与自变量 t 无关</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         f(t)\rightarrow\tilde{f(t)}\equiv(f+\delta f)(t)=f(t)+\delta f(t)\\
       </span>
     
     
     
<h2 id="122-变分的运算规则">1.2.2 变分的运算规则</h2>
<p>函数的变分其实和微分运算形式相似，比如</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \delta (f^n)=nf^{n-1}\delta f\\
       </span>
     
     
     
<p>对于函数
     
     
       
     
     
     
       <span class="fallback-latex">
         f_1
       </span>
     
     
     和
     
     
       
     
     
     
       <span class="fallback-latex">
         f_2
       </span>
     
     
     以及常数 a,b， 我们有</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align}
\delta(af_1+bf_2)=a\delta f_1+b\delta f_2\\ 
\delta(f_1f_2)=(\delta f_1)f_2+f_1(\delta f_2)
\end{align}\\

       </span>
     
     
     
<p>另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“</p>
<p>
     
     
       
     
     
     
       <span class="fallback-latex">
         d(\delta f)=\delta(df)\\
       </span>
     
     
     
<img src="/notes/physcis/classical-mechnics/gaoxian/1.2/2.png"></p>
<p>如图，此性质可以被直观证明。考虑
     
     
       
     
     
     
       <span class="fallback-latex">
         f
       </span>
     
     
     的值在
     
     
       
     
     
     
       <span class="fallback-latex">
         A
       </span>
     
     
     点和
     
     
       
     
     
     
       <span class="fallback-latex">
         B'
       </span>
     
     
     点的差，即</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \tilde{f}(t+dt)-f(t)\\
       </span>
     
     
     
<p>若先微分后变分(路径
     
     
       
     
     
     
       <span class="fallback-latex">
         A\rightarrow B\rightarrow B'
       </span>
     
     
     ),精确到一阶小量有</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align} C'B长度&=f(t+dt)-f(t)=df(t)\\ BB'长度&=\tilde{f}(t+dt)-f(t+dt)\\ &=\delta(f(t+dt))\\ &=\delta(f(t)+df(t))\\ &=\delta(f(t))+\delta(d(f(t)) \end{align}\\

       </span>
     
     
     
<p>于是，</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \tilde{f}(t+dt)-f(t)=df(t)+\delta f(t)+\delta (df(t))\\
       </span>
     
     
     
<p>若先变分再微分(路径
     
     
       
     
     
     
       <span class="fallback-latex">
         A\rightarrow A'\rightarrow B
       </span>
     
     
     ),精确到一阶小量有</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         
\begin{align} AA'长度&=\tilde{f}(t)-f(t) \\&=\delta f(t)\\ A'C长度&=\tilde{f}(t+dt)-\tilde{f}(t)\\ &=d\tilde{f}(t)\\ &=d((f+\delta f)(t))\\ &=df(t)+d(\delta f(t)) \end{align}\\

       </span>
     
     
     
<p>于是，</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \tilde{f}(t+dt)-f(t)=\delta f(t)+df(t)+d(\delta f(t))\\
       </span>
     
     
     
<p>进而有，</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         d(\delta f)=\delta(df)\\
       </span>
     
     
     
<p>上式的直接推论即变分和求导运算也可以交换顺序，即是说&quot;导数的变分&quot;=&ldquo;变分的导数&rdquo;.</p>

     
     
       
     
     
     
       <span class="fallback-latex">
         \frac{d}{dt}(\delta f(t))=\delta(\frac{d}{dt}f(t))\\
       </span>
     
     
     
<p>这里的关键在于，变分变化的是函数本身，而与自变量无关。</p>

  </div>
      
      <aside class="sidebar">
        <div class="card">
          <h2>摘要</h2>
          <p>函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。
 …</p> 
        </div>
        <div class="card">
          <h2>阅读时长</h2>
          <p>1 min</p> 
        </div>
        <div class="card">
          <h2>总字数</h2>
          <p>≈ 118</p> 
        </div>
        <div class="card">
          <h2>标签</h2>
          <p>
            
              <a href="#">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-tag" viewBox="0 0 16 16">
                  <path d="M3 2a1 1 0 0 0-1 1v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 8.586 2H3zm1 1h4.586L14 8.414l-4.586 4.586-6-6V3z"/>
                  <path d="M5.5 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                </svg>
                经典力学
              </a>
            
          </p>
        </div>
      </aside>
    </div>
</div>
</main>

<div id="related">
  <h2>Related Pages</h2>
  <ul class="posts">
    
      <li class="post">
  
  <a href="http://localhost:1313/notes/physcis/classical-mechnics/gaoxian/1.1/">
    <h2>
      1.1 泛函
    </h2>
    <article>
      我们首先来回顾一下函数的概念。
一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：
函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\in X 和 y\in Y 之间建立的一个对应关系即为映射。
f:x\rightarrow y=f(x) \\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。
例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。
上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。
这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。
至此，**&ldquo;泛函&rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\cdots,f_n(x) ，所有这些函数自然也构成集合 \mathcal{F}=\{f_1,f_2,\cdots,f_n\} ,把函数 f 的泛函记为 s[f] ，即
S:f\longmapsto S=S[f],\quad\mathcal{F}\longmapsto \mathcal{C}\\ 其中， \mathcal{C} 代表复数集合。
泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。
1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如
平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函
S(曲线长度)=S[f](曲线方程f的泛函)=\int\limits_{曲线}dx\sqrt{1+(f'(x))^2}\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函
W=W[p]=\int\limits_{过程}p(V)dV\\ 三维空间曲线方程记为 z=\phi(x,y) ，则曲面面积 A 为二元函数 z=\phi(x,y) 的泛函
A=A[\phi]=\iint_{\text {区域 }} \mathrm{d} x \mathrm{~d} y \sqrt{1+\left(\frac{\partial \phi}{\partial x}\right)^{2}+\left(\frac{\partial \phi}{\partial y}\right)^{2}} \\ 经典力学中的遇见的泛函，通常为以下形式 
    </article>
    <div>Read More</div>
  </a>
</li>

    
      <li class="post">
  
  <a href="http://localhost:1313/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/fengqi/1.1/">
    <h2>
      1.1  逻辑基础
    </h2>
    <article>
      在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。
1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。
数学中的语句按照分支被分为各自分支中的基本语句和复合语句。
具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\cdot7+2\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 < 来表征小于的线性序关系，那么 1+2<2+3 、 5\cdot2<5\cdot3 就都是基础语句。
复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如
\begin{array}{l}((5 \cdot 2<3 \cdot 2) \rightarrow(0=1)) \\((5 \cdot 2<3 \cdot 2) \leftrightarrow(0=1)) \\((5 \cdot 2<3 \cdot 2) \vee(\neg(0=1))) \\((5 \cdot 2<3 \cdot 2) \wedge(\neg(0=1)))\end{array}就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：
\neg(非),\rightarrow(蕴含),\leftrightarrow(对等),\vee(或),\wedge(且) 其中，
1.符号&quot; \neg &quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”
2.符号&quot; \rightarrow &quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”
3.符号&quot; \leftrightarrow &quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思
4.符号&quot; \vee &quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”
5.符号&quot; \wedge &quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”
基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：
\begin{array}{l}5\cdot7+2\cdot3=41\\5\cdot3=11\end{array}在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \{0,1\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。 
    </article>
    <div>Read More</div>
  </a>
</li>

    
  </ul>
</div>

<div class="comments" data-articleurl="/notes/physcis/classical-mechnics/gaoxian/1.2/">
  <h2>Comments</h2>
  
  
  
    
  

  
  
  
  

    <template id="comment-success">
      <div class="success">
        您的评论已成功提交审核。(´｡• ᵕ •｡`)
      </div>
    </template>
    <template id="comment-error">
      <div class="error">
        啊，好像出了些问题，请您调整后重试。(；′⌒`)
      </div>
    </template>

    <form id="comment-form" data-dynamic-form data-success="#comment-success" data-error="#comment-error" netlify="true" name="Comments" method="POST" style="margin-top: 20px;">
  
      <div id="reply-to" style="display: none; color: #6c757d; margin-bottom: 10px;"></div> 
      
      <input type="hidden" name="url" value="/notes/physcis/classical-mechnics/gaoxian/1.2/">
      <input type="hidden" name="parent" id="parent" value="">
      <input type="hidden" name="custom" id="custom">
      <input type="hidden" name="depth" id="depth" value="0">
      <input type="hidden" name="articleurl" value="/notes/physcis/classical-mechnics/gaoxian/1.2/">

      
      <label class="comment-label" for="name">Name:</label>
      <input class="comment-input" type="text" id="name" name="name" required autocomplete="name">
      
      <label class="comment-label" for="email">Email:</label>
      <input class="comment-input" type="email" id="email" name="email" required autocomplete="email">
      
      <label class="comment-label" for="comment">Comment:</label>
      <textarea class="comment-textarea" id="comment" name="comment" rows="5" required autocomplete="off"></textarea>
      
      <button class="comment-button" type="submit">Send</button>
    </form>
    
  
</div>
<script>
  
  
  function generateUniqueId() {
    return `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }



document.querySelectorAll(".reply-button").forEach(button => {
  button.addEventListener("click", function() {
    
    const parentComment = this.closest('.comment');

    
    const parentId = this.getAttribute('data-custom');
    const parentName = this.getAttribute('data-name');

    
    const parentDepth = parseInt(parentComment.getAttribute('data-depth')) || 0;

    
    document.getElementById('parent').value = parentId || "";
    console.log("Parent ID set to:", parentId); 

    
    const newDepth = parentDepth + 1;

    
    document.getElementById('depth').value = newDepth;

    
    const replyToElement = document.getElementById('reply-to');
    replyToElement.style.display = 'block';
    replyToElement.innerText = `回复 @${parentName}`;

    
    document.querySelectorAll('.comment').forEach(comment => {
      comment.classList.remove('highlight');
    });
    this.closest('.comment').classList.add('highlight');
  });

    
    document.getElementById('comment-form').scrollIntoView({ behavior: 'smooth' });
  });


  
  document.getElementById("comment-form").addEventListener("submit", function(event) {
    
    const customIdField = document.getElementById("custom");
    if (!customIdField.value) {
        customIdField.value = generateUniqueId();
        console.log("Custom ID set to:", customIdField.value); 
    }
});

window.onload = function() {
    
    const commentsContainer = document.querySelector('.comments'); 
    const articleurl = commentsContainer.dataset.articleurl.replace(/\/$/, '').toLowerCase(); 
    const commentForm = document.querySelector('#comment-form'); 
    const footer = document.querySelector('footer'); 

    
    const allComments = Array.from(document.querySelectorAll('.comment, .child-comment'));

    
    const filteredComments = allComments.filter(comment => {
    const commentArticleUrl = comment.dataset.articleurl.replace(/\/$/, '').toLowerCase();
    return commentArticleUrl === articleurl;
});

    
    commentsContainer.innerHTML = '';

    
    const topLevelComments = filteredComments.filter(comment => comment.dataset.depth === '0');
    topLevelComments.forEach(topLevelComment => {
        commentsContainer.appendChild(topLevelComment);

        
        const childComments = filteredComments.filter(comment => comment.dataset.parent === topLevelComment.dataset.custom);
        childComments.forEach(childComment => {
            childComment.classList.add('child-comment'); 
            commentsContainer.appendChild(childComment);
        });
    });

    
    commentsContainer.appendChild(commentForm);
    commentsContainer.appendChild(footer);

    
    commentsContainer.style.display = 'none';
    commentsContainer.offsetHeight; 
    commentsContainer.style.display = '';

    
    
};

  </script>




    
      <footer class="dark">
         
  <nav>
    
    <ul>
    
      <li>
        <a href="/categories">目录</a>
        
      </li>
    
      <li>
        <a href="/reference">引用资料列表</a>
        
      </li>
    
      <li>
        <a href="/categories">教材索引</a>
        
      </li>
    
    </ul> 
  </nav>


        <ul>
          
            <li>
              <a href="https://facebook.com/example" aria-label="Facebook">
                <i class="  icon-facebook"></i>
              </a>
            </li>
          
          
            <li>
              <a href="https://x.com/i/flow/login" aria-label="Twitter">
                <i class="icon-twitter"></i>
              </a>
            </li>
          
          
            <li>
              <a href="mailto:chiaralee953@foxmail.com" aria-label="email">
                <i class="icon-email"></i>
              </a>
            </li>
          
        </ul>
        <div>Copyright © 2024 Caleton Academy of Magic.</div>
    </footer>
  
  </body>
</html>
