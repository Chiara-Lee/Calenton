


















































































[{"content":" 前言 [第 1 章 变分法] 1.1 泛函 [1.1 泛函的概念] [1.1 泛函的具体形式] 1.2 变分 [1.2 变分的概念] [1.2 变分的运算规则] [1.3 泛函导数] 1.3 泛函导数的概念 1.3 泛函导数的操作定义 1.3 计算一阶泛函导数的标准手续 [1.4 泛函极值] 1.4 泛函极值的必要条件 [1.4 欧拉拉格朗日方程] [1.4 多个变量与多元函数] [习题] [第 2 章 位形空间] [2.1 位形与时间演化] [2.1 位形] [2.1 位形空间与流形] [2.1 世界线] [2.2 广义坐标] [2.2 广义坐标的概念] [2.2 广义坐标的变换] ","cover":null,"tags":null,"title":"经典力学-高显  目录","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/catalogue/"},{"content":"1.4.1 泛函极值的必要条件 为什么两点之间直线最短？如何使得平面上固定长度曲线所围区域面积最大？什么循环过程效率最高？轨道形状如何小球下落时间最短？\n有了泛函的概念，这些问题可以归结为当函数（输入）取什么形式时，泛函的值（输出）取极值。在变分法中，这被称为泛函极值问题。在实际问题中，我们关心的并不是泛函的全部信息，而往往是泛函的极值。\n假设泛函 S[f] 在 f(t) = \\bar{f}(t) 时取到极大（小）值，这意味着，任何对 \\bar{f} 的小偏离 \\bar{f} + \\epsilon \\delta f ，都会使得 S[\\bar{f} + \\epsilon \\delta f] 的值比 S[\\bar{f}] 小（大）。只有当不发生偏离，即 \\delta f = 0 时取到极值。从另一个角度，这等价于 S[\\bar{f} + \\epsilon \\delta f] 作为 \\epsilon 参量的普通函数，在 \\epsilon = 0 时取到极值。\n这样就将泛函极值问题转化为普通函数的极值问题。而我们已经知道，普通函数的极值即要求其一阶导数为零。结合泛函导数的定义，我们有\n\\delta S[\\bar{f}] = \\int dt \\left. \\frac{\\delta S[f]}{\\delta f} \\right|_{\\bar{f}} \\delta f(t) = \\left. \\frac{d S[\\bar{f} + \\epsilon \\delta f]}{d \\epsilon} \\right|_{\\epsilon=0} = 0\r由此得到，泛函在 f(t) = \\bar{f}(t) 时取到极值，即要求泛函的一阶变分*为零\n\\delta S[\\bar{f}] = 0\r其意义是在函数（输入）发生小变化时，泛函的值（输出）不变。等价的，这意味着泛函在 \\bar{f}(t) 处的一阶泛函导数为零\n\\left. \\frac{\\delta S[f]}{\\delta f} \\right|_{\\bar{f}} = 0\r需要说明的是，正如一阶导数为零只是函数取到极值的必要而非充分条件，一阶泛函导数为零也只是泛函取到极值的必要而非充分条件。严格来说， \\delta S=0 并非对于泛函一定取到极值，但是一定是 恒稳（stationary） 的。\n作为变分法到目前的小结，可将多元函数与泛函做一个对比：\n1.4.2 欧拉—拉格朗日方程 一类常见的泛函具有如下的形式\nS[f]=\\int dt L(t,f(t),f'(t))\r其特点是，泛函的被积函数 L 最高包含 f 的一阶导数。物理中大多数感兴趣的系统都是类似这样的形式。根据上一节的讨论，泛函取极值的必要条件是\n\\begin{aligned} \\delta S[q(t)] \u0026 =\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q} \\delta q+\\frac{\\partial L}{\\partial \\dot{q}} \\delta \\dot{q}\\right) \\\\ \u0026 =\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q} \\delta q+\\frac{\\partial L}{\\partial \\dot{q}} \\frac{\\mathrm{d}}{\\mathrm{d} t} \\delta q\\right) \\\\ \u0026 =\\left.\\frac{\\partial L}{\\partial \\dot{q}} \\delta q\\right|_{t_{1}} ^{t_{2}}+\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q}-\\frac{\\mathrm{d}}{\\mathrm{d} t} \\frac{\\partial L}{\\partial \\dot{q}}\\right) \\delta q\\\\ \u0026\\simeq \\int_{t_{1}}^{t_{2}} \\mathrm{~d} t\\left(\\frac{\\partial L}{\\partial q}-\\frac{\\mathrm{d}}{\\mathrm{d} t} \\frac{\\partial L}{\\partial \\dot{q}}\\right) \\delta q\\\\ \\end{aligned}\\\\\r\\boxed{- \\frac{\\delta S}{\\delta f} \\equiv \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) - \\frac{\\partial L}{\\partial f} = 0}\r上式是关于 f(t) 的二阶微分方程，被称为变分问题的 欧拉—拉格朗日方程（Euler-Lagrange equation） 。其意义是，泛函式\nS[f] = \\int dt L(t, f(t), f'(t))\r在 f=f(t) 处取到极值的必要条件是 f(t) 满足欧拉拉格朗日方程。\n并不是所有的微分方程都是欧拉拉格朗日方程，即都对应某个泛函的极值。\n对 L 直接求全导数\n\\begin{aligned}\r\\frac{dL}{dt} \u0026= \\frac{\\partial L}{\\partial t} + \\frac{\\partial L}{\\partial f} f' + \\frac{\\partial L}{\\partial f'} f'' \\\\\r\u0026= \\frac{\\partial L}{\\partial t} + \\frac{\\partial L}{\\partial f} f' + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) f' \\\\\r\u0026= \\frac{\\partial L}{\\partial t} + \\underbrace{\\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) \\right] f'}_{=0} + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right)\r\\end{aligned}\r\\frac{dL}{dt} = \\frac{\\partial L}{\\partial t} + \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right).\r\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{dL}{dt} = - \\frac{\\partial L}{\\partial t}.\r注意到 \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) = \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' \\right) - \\frac{dL}{dt} ，因此有\n\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) = - \\frac{\\partial L}{\\partial t}.\r将 - \\frac{\\partial L}{\\partial t} 移到左侧，就得到\n\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) + \\frac{\\partial L}{\\partial t} = 0.\r因此，当欧拉—拉格朗日方程*满足时，下式也成立\n\\boxed{\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} f' - L \\right) + \\frac{\\partial L}{\\partial t} = 0}\r一个立即的推论是，若 L 不显含变量 t \\frac{\\partial L}{\\partial t} = 0 \\quad \\Rightarrow \\quad \\frac{\\partial L}{\\partial f'} f' - L = \\text{常数}\r对于更一般的泛函式，其取极值的必要条件是\n\\frac{\\delta S}{\\delta f} \\equiv \\sum_{n=0} (-1)^n \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) = 0\r如果泛函式中的被积函数 L 包含 f(t) 的最高到 n 阶导数，即 L = L(t, f, f', \\cdots, f^{(n)}) 则上面的求和展开为\n\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\cdots + (-1)^n \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right)\r\\frac{\\delta S}{\\delta f} 中 f(t) 的最高阶导数来自最后一项。如果 \\frac{\\partial L}{\\partial f^{(n)}} 仍然包含 f^{(n)} ，即\n\\frac{\\partial}{\\partial f^{(n)}} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) = \\frac{\\partial^2 L}{\\partial f^{(n)} \\partial f^{(n)}} \\neq 0\r则 \\frac{d^n}{dt^n} \\left( \\frac{\\partial L}{\\partial f^{(n)}} \\right) 包含最高至 f(t) 的 2N 阶导数，满足上式的 L 也被称为是 非退化的（non-degenerate）。总之，如果泛函导数* \\frac{\\delta S}{\\delta f} 包含 f(t) 最高至 2N 阶导数，相应的泛函极值的欧拉—拉格朗日方程为 2N 阶微分方程。\n","cover":null,"tags":["经典力学"],"title":"1.4.1 泛函极值的必要条件","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.4.1/"},{"content":"在上一节中，我们已经证明了所知道的所有关于加法和序的基本事实。为了节省篇幅以及避免赘述那些显然的事情，接下来我们将允许使用所熟悉的关于加法和序的代数法则，而不加进一步的说明。于是我们可以写出 a+b+c=c+b+a 这样的内容，不需要进一步解释说明。现在我们引入乘法。正如加法是重复的增量运算一样，乘法是重复的加法运算。\n定义 2.3.1（自然数的乘法）\n令 m 表示任意一个自然数，\n我们定义 0\\times m:= 0 来表示将 0 乘到 m 上。现在归纳假设我们已经定义了 n\\times m （即把 n 乘到 m 上）。\n那么，我们可以定义\n(n++)\\times m:= (n\\times m)+m 以上，我们就定义好了自然数的乘法规则。\n引理 2.3.2 （乘法是可交换的） 令 n 和 m 表示任意两个自然数，那么有 n\\times m=m\\times n 成立。\n证明： 使用数学归纳法。\n首先我们需要证明 m\\times 0= 0 。当 m=0 时，我们有\n0\\times 0:= 0 归纳假设当 m=m 时 m\\times 0= 0 是成立的，那么现在我们来证明 m=m++ 时等式成立。\n\\begin{align}\r(m++)\\times 0\u0026=(m\\times 0)+0[(n++)\\times m:= (n\\times m)+m]\\\\\r\u0026=0\r\\end{align}\r以上，我们就得到了基础情况 0\\times m=m\\times 0 。\n接下来，我们需要证明\nn\\times (m++)=(n\\times m)+n 当 n=0 时， 0\\times (m++)=0=0\\times m+0 （第一个等号来源于定义，第二个等号是为了交换形式而拼凑出来的）。假设当 n=n 时结论已经成立，即有 n\\times (m++)=(n\\times m)+n ，需证 (n++)\\times (m++)=(n++)\\times m+(n++) \\begin{align}\r(n++)\\times (m++)\u0026=[n\\times(m++)]+(m++)\\\\\r\u0026=n\\times m+n+(m++)\\\\\r\u0026=n\\times m+m+(n++)\\\\\r\u0026=(n++)\\times m+(n++)\r\\end{align}\r其中第三个等号是因为\n\\begin{align}\r\u0026n+(m++)=n+(m+1)\\\\\r\u0026(n++)+m=(n+1)+m\\\\\r\u0026n+(m+1)=(n+1)+m\\\\\r\u0026n+(m++)=(n++)+m\r\\end{align}\r综上,引理得证。\n我们将把 n\\times m 简写为 nm ，而且按照惯例，乘法运算优先于加法运算。\n引理 2.3.3（正自然数没有零因子） 令 n 和 m 表示任意两个自然数，那么 n\\times m=0 当且仅当 n 和 m 中至少有一个为 0 .\n证明： 设 n、m 均为正自然数，并且满足 n=c++、m=d++ ，其中 c、d 均为自然数。\n\\begin{aligned}\r\u0026 (n \\text { is positive }) \\wedge(m \\text { is positive }) \\\\\r\\Rightarrow \u0026 \\exists c, d \\in N, c++=n, d++=m \\\\\r\\Rightarrow \u0026 n m=(c++) \\times(d++)=c \\times(d++)+(d++)=(c \\times(d++)+d)++ \\\\\r\\Rightarrow \u0026 n m \\text { is positive }\r\\end{aligned}\r命题 2.3.4（分配律）\n对于任意自然数 a,b,c \\begin{align}\r\u0026a(b+c)=ab+ac\\\\\r\u0026(b+c)a=ba+ca\r\\end{align}\r均成立\n证明： 由于乘法是可交换的，因此只需要证明第一个等式 a(b+c)=ab+ac 成立即可。\n对 c 进行数学归纳。当 c=0 时，\n\\begin{align}\r\u0026a(b+0)=ab\\\\\r\u0026ab+a0=ab\\\\\r\u0026a(b+0)=ab+a0\r\\end{align}\r现在我们归纳性地假设 a(b+c)=ab+ac 成立，接下来要证明的是 a(b+(c++))=ab+a(c++) 。\n\\begin{align}\r\u0026a(b+(c++))=a[(b+c)++]\\\\\r\u0026a[(b+c)++]=a(b+c)+a\\\\\r\u0026ab+a(c++)=ab+ac+a\r\\end{align}\r根据 a(b+c)=ab+ac ，因此可知 c++ 的情况亦成立。，那么到这里归纳过程就结束了。\n命题 2.3.5（乘法是可结合的）\n对于任意自然数 a,b,c (a\\times b)\\times c=a\\times(b\\times c) 均成立。\n证明：\n对 b 进行数学归纳 : 对于 0: (a \\times 0) \\times c=0 \\times c=0=a 0=a(0 \\times c) 如果 b 是正确的，即 (a\\times b)\\times c=a\\times(b\\times c) , 那么\n\\begin{array}{l}\r(a(b++)) c=(a b+a) c=(a b) c+a c \\\\\r=a(b c)+a c=a(b c+c)=a((b++) c)\r\\end{array}\r命题 2.3.6（乘法保持序不变）\n如果 a,b 是满足 a","cover":null,"tags":["数学分析"],"title":"2.3  乘法","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.3/"},{"content":"1.摘要 本文公理一览：\n公理 3.1（集合是对象） 相等公理、替换公理 公理 3.2 (空集) 公理 3.3（单元素集与双元素集） 公理 3.4（两集合并集） 公理 3.5（分类公理） 公理 3.6 (替代) 公理 3.7 (无穷大) 2.正文 定义 3.1.1（非正式的）（集合）\n我们把 集合 A 定义为任意的一堆没有次序的对象。例如， \\{3,8,5,2\\} 是一个集合。如果 x 是这堆对象中的一个，那么我们称 x 是 A 中的一个元素 ，记作 x\\in A ，否则，记作 x\\notin A 。\n这个定义相当直观，但是它无法回答诸如下面这些问题：什么样的一堆对象可以被看作集合？什么样的集合与另外的集合相等？如何定义集合上的运算，比如并集、交集等？同时，我们还没有给出关于集合或者集合中元素的公理。本节剩余内容的主要目的就是给出这些公理并定义集合上的运算。\n首先阐明一个观点：我们把集合本身看作一类对象。\n公理 3.1（集合是对象） 如果 A 是一个集合，那么 A 也是一个对象。特别地，给定两个集合 A 和 B ，问 A 是不是 B 中的元素是有意义的。\n到目前为止，总的来说，在数学里学到的所有对象当中，有些对象恰好是集合。而且如果 x 是一个对象， A 是一个集合，那么 x \\in A 要么为真，要么为假。（如果 A 不是集合，则我们认为 x \\in A 是无定义的。例如， 3 \\in 4 既非真也非假，该命题是无意义的，因为 4 不是一个集合。）\n接下来我们定义相等的概念：什么情况下可以认为两个集合是相等的？我们认为一个集合中元素的次序并不重要，因此我们把集合 \\{3, 8, 5, 2\\} 与 \\{2, 3, 5, 8\\} 看作同一个集合。另外， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5, 2, 1\\} 是两个不同的集合，这是因为后者中的一个元素不包含在前者里，即元素 1 。基于类似的原因， \\{3, 8, 5, 2\\} 与 \\{3, 8, 5\\} 也是不同的集合。我们把这部分内容作为一个定义。\n定义 3.1.4（集合的相等） 称两个集合 A 和 B 是相等的，即 A = B ，当且仅当 A 中的每个元素都是 B 中的元素并且 B 中的每一个元素也都是 A 中的元素。也就是说， A = B ，当且仅当 A 中的任一元素 x 属于 B ，同时 B 中的任一元素 y 也属于 A ，这记为 (\\forall x \\in A, x \\in B),(\\forall y \\in B, y \\in A) 相等是如何定义的取决于所考察对象的类型，而且从某种程度上来说，这只不过是一个关于下定义的问题而已。然而，从逻辑学的角度来说，我们要求相等遵守下面四条 相等公理 ：\n（自反公理） 给定任意的对象 x ，我们有 x = x 。 （对称公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么 y = x 。 （传递公理） 给定任意三个同类型的对象 x 、 y 和 z ，若 x = y 且 y = z ，则 x = z 。 （替换公理） 给定任意两个同类型的对象 x 和 y ，如果 x = y ，那么对任意一个函数或者运算 f 都有 f(x) = f(y) 。类似地，对任意一个关于 x 的性质 P(x) ，如果 x = y ，那么 P(x) 和 P(y) 就是等价的命题。 容易验证，定义3.1.4满足自反、对称、传递三个性质。\n自反性（Reflexive）: (\\forall x \\in A, x \\in A) \\Rightarrow A = A 对称性（Symmetric）: (A = B) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in A) \\Rightarrow B = A 传递性（Transitive）: (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in A, x \\in B) \\land (\\forall x \\in B, x \\in C) \\Rightarrow (\\forall x \\in A, x \\in C) (A = B) \\land (B = C) \\Rightarrow (\\forall x \\in B, x \\in A) \\land (\\forall x \\in C, x \\in B) \\Rightarrow (\\forall x \\in C, x \\in A) \\text{以上两种情况同时成立，这意味着 } A = C 根据定义 3.1.4 观察可知，如果 x \\in A 并且 A = B ，那么 x \\in B 。于是 “是……的元素” 这种 \\in 关系遵守替换公理。正因如此，只要我们能够把定义在集合上的新运算仅用 \\in 的语言来描述，这个新运算就会遵守替换公理。例如，对于本节中剩下的定义，情况就是这样。（另外，在良好的定义方式中，我们不能使用集合中 “第一个” 或者 “最后一个” 元素这样的概念，因为这将违背替换公理。例如，虽然集合 \\{1, 2, 3, 4, 5\\} 与 \\{3, 4, 2, 1, 5\\} 表示同一个集合，但是它们的第一个元素是不一样的。）\n面我们来讨论到底什么样的对象是集合，什么样的对象不是集合。\n这与上一章中我们如何定义自然数相类似。我们从单个的自然数 0 开始，利用增量运算从 0 中构造出更多的数。\n这里我们将尝试做类似的事情，从单个集合（空集）开始，利用各种运算从空集中构造出更多的集合。我们首先假定空集的存在性。\n公理 3.2 (空集) 存在一个集合 \\varnothing ，被称为空集，它不包含任何元素。也就是说，对于任意的对象 x 均有 x\\notin\\varnothing 。\n空集也记作 {} 。注意只能有一个空集，如果存在两个集合 \\varnothing 和 \\varnothing' 都是空集，那么根据定义3.1.4 （集合的相等）可知，它们必定相等。\n如果一个集合不等于空集，那么称该集合是非空的。下面这个命题非常简单，却值得叙述。\n引理 3.1.6（单个选取） 设 A 是一个非空集合，那么存在一个对象 x 使得 x \\in A 。\n证明： 我们用反证法来证明。假设不存在任何对象 x 使得 x \\in A ，那么对任意一个对象 x 而言，有 x \\notin A 。另外根据公理 3.2 (空集)可知： x \\notin \\varnothing 。于是 x \\in A \\iff x \\in \\varnothing （这两个命题均为假），进而根据定义 3.1.4 (集合的相等)有 A = \\varnothing ，显然这与已知条件“ A 是一个非空集合”相矛盾。\n注 3.1.7 上述引理断言，给定任意一个非空集合 A ，我们可以“选取” A 中的一个元素 x ，以此来证实 A 的非空性。\n后面（在引理 3.5.12 中）我们将证明对于给定的任意有限多个非空集合 A_1, \\cdots, A_n ，能够从每个集合 A_1, \\cdots, A_n 中分别选取一个元素 x_1, \\cdots, x_n ，这称作“有限选取”。**但是如果想要从无穷多个集合中选取元素，我们就需要另一个公理，即选择公理。**关于选择公理的讨论将留到 8.4 节。\n如果公理 3.2 （空集）是集合论中唯一一个公理，那么集合论必然相当乏味，因为在这种情况下，只有唯一一个集合存在，那就是空集。现在我们给出更深层次的公理来丰富可用集合的种类。\n公理 3.3（单元素集与双元素集）\n如果 a 是一个对象，那么存在一个集合 \\{a\\} 并且该集合中唯一的一个元素就是 a 。也就是说，对于任意一个对象 y ，我们有 y \\in \\{a\\} ，当且仅当 y=a ；我们称 \\{a\\} 是元素为 a 的 单元素集。\n更进一步地，如果 a 和 b 都是对象，那么存在一个集合 \\{a, b\\} ，并且该集合的元素只有 a 和 b 。换言之，对于任何一个对象 y ，有 y \\in \\{a,b\\} ，当且仅当， y=a 或者 y=b ，我们称该集合是由 a 和 b 所组成的双元素集。\n注 3.1.9 正如只存在唯一一个空集那样，根据定义 3.1.4 （集合的相等）可知，元素为 a 的单元素集也只有一个。类似地，给定任意两个对象 a 和 b ，那么只存在唯一一个由 a 和 b 构成的双元素集。同样，定义 3.1.4 （集合的相等）也能确保 \\{a, b\\} = \\{b, a\\} 以及 \\{a, a\\} = \\{a\\} 。于是，单元素集公理事实上是多余的，因为它是从双元素集公理中推导出的一个结论。反过来，双元素集公理可以由单元素集公理以及后面的两集合并集公理推出（参见引理 3.1.13）。人们可能会问为什么我们不继续构造三元素集公理、四元素集公理等；然而，一旦我们引入下面的两集合并集公理，就没有必要再去构造这些公理了。\n目前为止，我们构造的每一个集合所包含的元素个数都不超过两个。接下来这个公理将让我们能够构造出比之前稍大一些的集合。\n公理 3.4（两集合并集） 给定任意两个集合 A 和 B ，存在一个集合 A \\cup B 被称为 A 和 B 的 并集，该集合的元素由属于 A 的或者属于 B 的或者同时属于 A 和 B 的所有元素共同构成。换言之，对任意的对象 x ，\nx \\in A \\cup B \\iff (x \\in A \\text{ 或 } x \\in B)\r回忆一下，“或”在数学中默认表示 包含，也可以说，“ X 或 Y 为真” 是指 “要么 X 为真，要么 Y 为真，要么 X 和 Y 都为真”。 参见 A.1 节。\n例 3.1.11 集合 \\{1,2\\} \\cup \\{2,3\\} 中的元素是由属于 \\{1,2\\} 的或者属于 \\{2,3\\} 的或者同时属于这两个集合的一切元素共同构成的；换言之，这个集合的元素就是 1、2 和 3。因此，我们把该集合记作 \\{1,2\\} \\cup \\{2,3\\} = \\{1,2,3\\} 。\n注 3.1.12 如果 A 、 B 和 A' 都是集合并且 A 等于 A' ，那么 A \\cup B 等于 A' \\cup B 。\n证明：\n步骤 1: 证明 A \\cup B \\subseteq A' \\cup B 假设 x \\in A \\cup B 。根据并集的定义， x \\in A \\cup B 意味着 x \\in A 或者 x \\in B 。\n如果 x \\in A ，由于 A = A' ，因此 x \\in A' ，所以 x \\in A' \\cup B 。 如果 x \\in B ，显然 x \\in A' \\cup B （因为 x \\in B ）。 因此， x \\in A' \\cup B 。从而，我们得出 A \\cup B \\subseteq A' \\cup B 。\n步骤 2: 证明 A' \\cup B \\subseteq A \\cup B 假设 x \\in A' \\cup B 。根据并集的定义， x \\in A' \\cup B 意味着 x \\in A' 或者 x \\in B 。\n如果 x \\in A' ，由于 A = A' ，因此 x \\in A ，所以 x \\in A \\cup B 。 如果 x \\in B ，显然 x \\in A \\cup B （因为 x \\in B ）。 因此， x \\in A \\cup B 。从而，我们得出 A' \\cup B \\subseteq A \\cup B 。\n结论:\n由步骤 1 和步骤 2，我们得出 A \\cup B = A' \\cup B 。 \\square 虽然以上证明显式的写出了尚未定义的集合之间的属于关系，但实际上，我们完全可以删掉这些属于号，而只使用 (\\forall x \\in A, x \\in B),(\\forall y \\in B, y \\in A) 这种写法，上述证明过程仍然成立，因此，该证明过程使用到的只有集合相等定义和并集公理。\n类似地，如果 B' 是与 B 相等的集合，那么 A \\cup B 等于 A \\cup B' 。因此，求并运算遵守替换公理，从而该运算在集合上是定义明确的。\n现在我们给出并集的一些基本性质。\n引理 3.1.13 如果 a 和 b 都是对象，那么 \\{a, b\\} = \\{a\\} \\cup \\{b\\} 。如果 A 、 B 和 C 都是集合，那么求并运算是可交换的（即 A \\cup B = B \\cup A ），而且也是可结合的（即 (A \\cup B) \\cup C = A \\cup (B \\cup C) ）。另外，我们有 A \\cup A = A \\cup \\emptyset = \\emptyset \\cup A = A 。\n证明： 首先证明 结合律 (A \\cup B) \\cup C = A \\cup (B \\cup C) 。\n根据定义 3.1.4 （集合的相等）可知，我们需要证明 (A \\cup B) \\cup C 中的任意一个元素 x 都是集合 A \\cup (B \\cup C) 中的元素，反之亦然。\n于是，首先假设 x 是 (A \\cup B) \\cup C 中的一个元素，那么根据公理 3.4 （两集合并集）可知，这意味着 x \\in A \\cup B 和 x \\in C 中至少有一个为真。现在我们分两种情况来讨论。\n如果 x \\in C ，则根据公理 3.4 可知 x \\in B \\cup C ，进而再次利用公理 3.4 可得， x \\in A \\cup (B \\cup C) 。\n现在假设 x \\in A \\cup B ，那么由公理 3.4 可知 x \\in A 或 x \\in B 。一方面，如果 x \\in A ，从公理 3.4 中可得 x \\in A \\cup (B \\cup C) ；另一方面，如果 x \\in B ，通过连续应用公理 3.4 可得 x \\in B \\cup C ，进而有 x \\in A \\cup (B \\cup C) 。\n因此我们得到，在所有可能的情况中， (A \\cup B) \\cup C 中的每一个元素均包含在 A \\cup (B \\cup C) 中。同理可以推出 A \\cup (B \\cup C) 中的每一个元素也都包含在 (A \\cup B) \\cup C 中，于是我们证明了 (A \\cup B) \\cup C = A \\cup (B \\cup C) 。□\n第二，对于求并运算的可交换性， A \\cup B=B \\cup A .\n证明 A \\cup B \\subseteq B \\cup A : 假设 x \\in A \\cup B 。根据并集的定义，此时存在两种可能：\nx \\in A x \\in B 无论是上述哪种情况，都意味着 x \\in B \\cup A （因为 B \\cup A 定义与 A \\cup B 相同，只是 A 和 B 的位置对调，不影响“或”的逻辑关系）。\n因此，当 x \\in A \\cup B 时，必有 x \\in B \\cup A 。由此得到 A \\cup B \\subseteq B \\cup A 。\n证明 B \\cup A \\subseteq A \\cup B : 该部分的证明与上面完全对称。\n假设 x \\in B \\cup A 。根据并集的定义，这意味着：\nx \\in B 或者 x \\in A 无论是哪种情况，都必然有 x \\in A \\cup B 。\n因此，当 x \\in B \\cup A 时，必有 x \\in A \\cup B 。由此得到 B \\cup A \\subseteq A \\cup B 。\n合并结果： 综合上述两个包含关系，我们有：\nA \\cup B \\subseteq B \\cup A \\quad \\text{且} \\quad B \\cup A \\subseteq A \\cup B\r根据集合相等的判定标准（互相包含），得到：\nA \\cup B = B \\cup A\r第三，对于 A \\cup A = A \\cup \\emptyset = \\emptyset \\cup A = A. ，使用与上两式同样的证明思路易得。\n因为有了上面这个引理，我们就不需要利用括号来表示多个并集运算了。例如，我们可以用 A \\cup B \\cup C 来代替 (A \\cup B) \\cup C 和 A \\cup (B \\cup C) 。类似地，对于四个集合求并，我们可以写成 A \\cup B \\cup C \\cup D ，等等。\n这个公理使得我们可以定义三元素集、四元素集，以此类推。如果 a, b, c 是三个对象，那么定义 \\{a, b, c\\} := \\{a\\} \\cup \\{b\\} \\cup \\{c\\} ；如果 a, b, c, d 是四个对象，那么定义 \\{a, b, c, d\\} := \\{a\\} \\cup \\{b\\} \\cup \\{c\\} \\cup \\{d\\} ，以此类推。另外，对任意给定的自然数 n ，我们目前尚无法定义由 n 个对象构成的集合；这需要把上述结构迭代 “ n 次”，然而 n 次迭代的概念还没有被严格定义。基于类似的原因，我们还无法定义由无穷多个对象所构成的集合概念，因为这需要对两集合并集公理迭代无穷多次，而且目前能否确保整个过程的严谨性尚不清楚。后面我们会介绍集合论的一些其他公理，这些公理将使我们能够构造出任意大甚至是无穷大的集合。\n显然，某些集合看起来比其他集合要大。正式建立这种概念的一种方法是引入子集的概念。\n定义 3.1.15（子集） 设 A 和 B 都是集合，我们称 A 是 B 的子集，并记作 A \\subseteq B ，当且仅当 A 的每一个元素都是 B 中的元素，即\n\\text{对任意的对象} x，x \\in A \\implies x \\in B\r如果 A \\subseteq B 并且 A \\neq B ，那么我们称 A 是 B 的真子集，记作 A \\subsetneq B 。\n注 3.1.16 因为上面的定义中只包含了相等的概念以及“是……的元素”的关系，而这两者都遵守替换公理，所以子集的概念也自动地遵守替换公理。于是，譬如若 A \\subseteq B 并且 A = A' ，那么 A' \\subseteq B 。\n例 3.1.17 我们有 \\{1, 2, 4\\} \\subseteq \\{1, 2, 3, 4, 5\\} ，这是因为 \\{1, 2, 4\\} 中的每一个元素都是 \\{1, 2, 3, 4, 5\\} 中的元素。事实上，我们也可以得到 \\{1, 2, 4\\} \\subsetneq \\{1, 2, 3, 4, 5\\} ，因为集合 \\{1, 2, 4\\} 与 \\{1, 2, 3, 4, 5\\} 不相等。给定任意一个集合 A ，我们总有 A \\subseteq A 和 \\varnothing \\subseteq A 。\n正如下面这个命题所描述的那样，集合论中的子集概念类似于数系中“小于或等于”的概念（更精确的表述参见定义 8.5.1）。\n命题 3.1.18（集合的包含关系使集合是偏序的） 设 A 、 B 、 C 是集合。如果 A \\subseteq B 并且 B \\subseteq C ，那么 A \\subseteq C 。如果 A \\subseteq B 并且 B \\subseteq A ，那么 A = B 。最后，如果 A \\subsetneq B 并且 B \\subsetneq C ，那么 A \\subsetneq C 。\n证明：\n第一个结论。假设 A \\subseteq B 并且 B \\subseteq C 。为了证明 A \\subseteq C ，我们必须证明 A 中的每一个元素都是 C 中的元素。那么取 A 中任意一个元素 x ，因为 A \\subseteq B ，所以 x 一定是 B 中的元素。又因为 B \\subseteq C ，所以 x 是 C 中的元素。因此 A 中的每一个元素实际上都是 C 中的元素，结论得证。\n第二结论 证明显然。\n第三结论 其证明过程和第一结论的证明是完全相同的。\n习题： 设 A , B , C 都是集合，\n证明 A \\cap B \\subseteq A 和 A \\cap B \\subseteq B 。 更进一步地，证明 C \\subseteq A 且 C \\subseteq B ，当且仅当 C \\subseteq A \\cap B 。 类似地，证明 A \\subseteq A \\cup B 和 B \\subseteq A \\cup B ， 且进一步证明 A \\subseteq C 且 B \\subseteq C ，当且仅当 A \\cup B \\subseteq C 。 证明：\n证明 A \\cap B \\subseteq A 和 A \\cap B \\subseteq B (1) A \\cap B \\subseteq A 证明：设任意 x \\in A \\cap B 。则根据交集的定义， x \\in A 且 x \\in B 。由此可见， x \\in A ，故 A \\cap B \\subseteq A 。\n(2) A \\cap B \\subseteq B 证明与上面类似：设 x \\in A \\cap B ，则 x \\in A 且 x \\in B ，因此 x \\in B ，故 A \\cap B \\subseteq B 。\n当且仅当条件： C \\subseteq A \\cap B \\iff C \\subseteq A \\text{ 且 } C \\subseteq B (1) 若 C \\subseteq A \\cap B ，则对任意 x \\in C ，有 x \\in A \\cap B 。由交集定义， x \\in A 且 x \\in B 。由于 x 是 C 的任意元素，这意味着 C \\subseteq A 且 C \\subseteq B 。\n(2) 反之，若 C \\subseteq A 且 C \\subseteq B ，则对于任意 x \\in C ，有 x \\in A 且 x \\in B 。由此可得 x \\in A \\cap B 。因为 x 是 C 的任意元素，所以 C \\subseteq A \\cap B 。\n结合(1)和(2)，可得\nC \\subseteq A \\cap B \\iff C \\subseteq A \\text{ 且 } C \\subseteq B .\n证明 A \\subseteq A \\cup B 和 B \\subseteq A \\cup B (1) A \\subseteq A \\cup B 证明：若任意 x \\in A ，则根据并集定义 x \\in A \\cup B （因为 x \\in A 即满足“或”条件）。由此 A \\subseteq A \\cup B 。\n(2) B \\subseteq A \\cup B 证明与上类似：若 x \\in B ，则 x \\in A \\cup B ，故 B \\subseteq A \\cup B 。\n当且仅当条件： A \\cup B \\subseteq C \\iff A \\subseteq C \\text{ 且 } B \\subseteq C (1) 若 A \\cup B \\subseteq C ，则对任意 x \\in A ，因为 A \\subseteq A \\cup B ，所以 x \\in A \\cup B \\subseteq C ，故 A \\subseteq C 。同理，对任意 x \\in B ，有 x \\in A \\cup B \\subseteq C ，故 B \\subseteq C 。综合得到 A \\subseteq C \\text{ 且 } B \\subseteq C 。\n(2) 反之，若 A \\subseteq C \\text{ 且 } B \\subseteq C ，则对任意 x \\in A \\cup B ，必然 x \\in A \\text{ 或 } x \\in B ，进而 x \\in C ，因此 A \\cup B \\subseteq C 。\n综上，\nA \\cup B \\subseteq C \\iff A \\subseteq C \\text{ 且 } B \\subseteq C .\n注 3.1.20 子集关系 \\subsetneq 和小于关系 \u003c 之间存在一个重要的区别。给定任意两个不同的自然数 n 和 m ，我们知道其中一个会比另外一个小（命题2.2.13 自然数的序的三歧性）；但是给定两个不同的集合，说其中一个是另外一个集合的子集这种命题通常不为真。例如，令 A := \\{2n : n \\in \\mathbb{N}\\} 是由所有偶自然数构成的集合，令 B := \\{2n + 1 : n \\in \\mathbb{N}\\} 是由所有奇自然数构成的集合，那么 A 和 B 彼此互不为对方的子集。这就是我们为什么说集合仅仅是 偏序 的，而自然数却是 全序 的（参见定义8.5.1和定义8.5.3）。\n注 3.1.21 我们也应该注意到子集关系 \\subseteq 与元素的属于关系 \\in 是不一样的。数字 2 是集合 \\{1, 2, 3\\} 中的一个元素，而不是它的一个子集，因此 2 \\in \\{1, 2, 3\\} ，但是 2 \\nsubseteq \\{1, 2, 3\\} 。事实上， 2 本身就不是一个集合。反过来， \\{2\\} 是集合 \\{1, 2, 3\\} 的一个子集，而不是元素，所以 \\{2\\} \\subseteq \\{1, 2, 3\\} ，但是 \\{2\\} \\notin \\{1, 2, 3\\} 。这里的关键在于数字 2 和集合 \\{2\\} 是不同的对象。\n把集合与集合中的元素区分开来非常重要，因为 集合和元素具有不同的性质。譬如，能够找到一个含有无穷多个元素的集合，其中每一个元素都是有穷数字（自然数集 \\mathbb{N} 就是这样的例子），也能够找到这样一个集合，它的元素个数是有限的，但是每个元素都是由无穷多个元素构成的集合（例如，考虑集合 \\{\\mathbb{N}, \\mathbb{Z}, \\mathbb{Q}, \\mathbb{R}\\} ，该集合共有四个元素且每一个元素都是由无穷多个元素构成的集合）。\n现在我们给出一个公理，它能够让我们轻松地构造出一个较大集合的子集。\n公理 3.5（分类公理） 设 A 是一个集合，对任意的 x \\in A ，令 P(x) 表示关于 x 的一个性质（即 P(x) 要么是真命题，要么是假命题）。那么存在一个集合，记作 \\{x \\in A : P(x) \\text{ 为真}\\} （或者简记为 \\{x \\in A : P(x)\\} ），该集合恰好是由 A 中那些使得 P(x) 为真的元素 x 构成的。换言之，对任意的对象 y ，\ny \\in \\{x \\in A : P(x) \\text{ 为真}\\} \\iff (y \\in A \\text{ 并且 } P(y) \\text{ 为真}) 这个公理也被称为 分离公理。注意， \\{x \\in A : P(x) \\text{ 为真}\\} 一定是集合 A 的一个子集，尽管它可能与 A 一样大，也可能与空集一样小。我们能够证明替换公理适用于分类，所以如果 A = A' ，则有 \\{x \\in A : P(x)\\} = \\{x \\in A' : P(x)\\} 。（因为，替换公理保证若 A = A' ，则我们可以在任意公式中将 A 替换为 A' 而不改变命题的真值，因此分离公理满足替换公理）\n另外，我们在此处所述的替换公理，实际上是一阶逻辑中的替换性。\n逻辑中的替换原则（等式替代性）：\n在一阶逻辑中，如果我们知道 x = y ，那么无论在什么性质 P(x) 或函数 f(x) 中，都可以把 x 换成 y 而不会改变陈述的真值或函数的值。这是逻辑本身的一个基本定律，也常被翻译为“替换规则”或“替代律”。有时，有些教材或笔记中也会将其称为“替换公理”或“替换规律”，这是在逻辑层面上的用法。这种替换不涉及集合的构造，只是逻辑上允许你将相等的对象互相替代。\n而在 ZF1 公理系统中也存在一个替换公理，其表述为\n替换公理模式（Replacement Schema） 是 ZF 集合论的一组 公理模式，用以保证由函数式定义的类从集合中“替换”元素形成的新类依然是集合。其一般形式如下：\n给定一个公式 \\phi(x, y, \\vec{p}) ，其中 \\vec{p} 是若干参数， \\phi 在集合论语言中构成一个谓词。如果满足下列条件：\n对任意集合 x 和 x' ，如果对某个 \\vec{p} 有 \\phi(x, y, \\vec{p}) 且 \\phi(x', y', \\vec{p}) 成立，那么若 x = x' 则必定 y = y' 。也就是说，对于固定的参数 \\vec{p} 和每个集合 x ， \\phi 充当一个定义良好的“类函数”——从 x 唯一确定一个 y 。\n对任意集合 A ，定义 B = \\{y : \\exists x \\in A, \\phi(x, y, \\vec{p})\\} 。那么替换公理断言： B 也是一个集合。\n简而言之，替换公理模式可以表述为：\n如果 \\phi 定义了从任意集合 A 到集合的一个类函数（即对 A 中每个元素 x 唯一定义一个 y 使 \\phi(x, y) 成立），那么 \\{y : \\exists x \\in A, \\phi(x, y)\\} 也是一个集合。\n两者的根本区别在于：替换性保证在逻辑推理中，可自由地在公式中用相等的对象互代，以维持公式的真值不变。这是一种语义上的逻辑规则，用来 确保逻辑推理的正确性和一致性。替换公理保证给定某种定义良好的类函数，可以“替换”集合中的每个元素为其对应像值，从而产生新集合的存在性。这是关于 从集合理论中已有的集合构造出新集合的存在性命题。因此，在平常的使用中，我们必须区别两者。\n有时我们用 \\{x \\in A | P(x)\\} 来代替 \\{x \\in A : P(x)\\} ，当用冒号 “:” 表示其他含义时，这种新写法就有用了。例如，用冒号来表示一个函数 f : X \\to Y 的值域和定义域。\n我们可以利用分类公理去进一步定义集合上的一些运算，即求交集和差集。\n定义 3.1.23（交集） 两个集合的交集 S_1 \\cap S_2 被定义为下面这样一个集合：\nS_1 \\cap S_2 := \\{x \\in S_1 : x \\in S_2\\} 即 S_1 \\cap S_2 是由所有同时属于 S_1 和 S_2 的元素构成的。于是对任意的对象 x ，\nx \\in S_1 \\cap S_2 \\iff x \\in S_1 \\text{ 且 } x \\in S_2 注 3.1.24 注意，这个定义是明确的（也就是说，该定义遵守替换公理）因为定义中仅仅使用到了属于关系以及更为原始的“满足..的性质”这一概念，因此它是遵循替换公理（替换性）的。\n注 3.1.26 顺便提一下，对于词语中的“和”我们要小心使用。根据上下文，它有时候表示并集，而有时候表示交集，非常容易混淆。例如，如果有人谈到“男孩和女孩”的集合，那么他的意思是男孩组成的集合与女孩组成的集合的并集，但是如果有人提到同时满足单身和男性这两个条件的人组成的集合，那么他的意思就是单身人士组成的集合与男性组成的集合的交集。另一个问题是“和”也表示相加，例如，我们可以说“2 与 3 的和是 5”，也可以说“集合 {2} 的元素和集合 {3} 的元素构成了集合 {2, 3}”，还有“在 {2} 和 {3} 中的元素构成了集合 ∅”。这确实容易混淆！原因之一在于我们用数学符号来代替像“和”这样的词语。数学符号总是能够准确清晰地表述意思，而想要真正了解某个词语所表达的涵义，我们必须非常仔细地阅读上下文才行。\n定义 3.1.27（差集） 给定两个集合 A 和 B ，我们定义集合 A - B 或 A \\setminus B 是由 A 中所有不属于 B 的元素组成的集合。\nA \\setminus B := \\{ x \\in A : x \\notin B \\} 例如， \\{1, 2, 3, 4\\} \\setminus \\{2, 4, 6\\} = \\{1, 3\\} 。在很多情况下， B 是 A 的一个子集，但并非必须如此。\n现在我们给出并集、交集和差集的一些基本性质。\n命题 3.1.28（集合构成布尔代数） 设 A 、 B 、 C 都是集合，令 X 表示包含 A 、 B 、 C 作为其子集的集合。\n(a)（最小元）我们有 A \\cup \\emptyset = A 和 A \\cap \\emptyset = \\emptyset 。\n(b)（最大元）我们有 A \\cup X = X 和 A \\cap X = A 。\n(c)（恒等式）我们有 A \\cap A = A 和 A \\cup A = A 。\n(d)（交换律）我们有 A \\cup B = B \\cup A 和 A \\cap B = B \\cap A 。\n(e)（结合律）我们有 (A \\cup B) \\cup C = A \\cup (B \\cup C) 和 (A \\cap B) \\cap C = A \\cap (B \\cap C) 。\n(f)（分配律）我们有 A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C) 和 A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C) 。\n(g)（分拆法）我们有 A \\cup (X \\setminus A) = X 和 A \\cap (X \\setminus A) = \\emptyset 。\n(h)（德摩根定律）我们有 X \\setminus (A \\cup B) = (X \\setminus A) \\cap (X \\setminus B) 和 X \\setminus (A \\cap B) = (X \\setminus A) \\cup (X \\setminus B) 。\n注 3.1.29 德摩根定律是以逻辑学家奥古斯塔斯·德摩根（1806—1871）的名字来命名的，他把这些定律确定为集合论的基本定律之一。\n什么是布尔代数 (Boolean Algebra)? 布尔代数是一种抽象代数结构，用来刻画经典逻辑以及集合运算的代数性质。它由一个带有两个二元运算（通常记为 \\land 和 \\lor 或者 \\cap 和 \\cup ）、一个一元运算（补操作），以及特定恒等元所组成的代数系统。满足布尔代数的结构必须符合以下公理特性：\n交换律 (Commutativity)：\na \\land b = b \\land a a \\lor b = b \\lor a 结合律 (Associativity)：\n(a \\land b) \\land c = a \\land (b \\land c) (a \\lor b) \\lor c = a \\lor (b \\lor c) 分配律 (Distributivity)：\na \\land (b \\lor c) = (a \\land b) \\lor (a \\land c) a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c) 恒等元存在 (Identity Elements)： 存在两个特殊元素：\n单位元 1 以及零元 0，满足： a \\land 1 = a a \\lor 0 = a 补元存在 (Complements)： 对每个 a 存在补元 a\u0026rsquo; 使：\na \\land a' = 0 a \\lor a' = 1 典型的布尔代数例子包括：\n真值代数：{true, false} 构成的代数结构 任一集合的幂集（其子集组成的集合），在并集、交集和补集下形成的结构 为什么“集合构成布尔代数”这个命题重要到成为集合论的基本定律？ 集合论在很大程度上被视为现代数学的基础框架。当我们发现任意集合的幂集在并、交和补这三种操作下构成了一个布尔代数时，这意味着经典命题逻辑的代数结构（逻辑运算：与、或、非）有了一个精确而自然的集合论刻画。换言之，逻辑命题间的真值结构与集合之间的包含关系及运算结构完全同构。这种对应为数学基础的统一提供了坚实的理论支撑，让我们能够在集合论基础上讨论逻辑系统的性质，从而使得集合论不仅仅是“描述数学对象的语言”，还是“描述逻辑结构和推理过程的语言”。\n虽然现在我们已经积累了有关集合的大量公理和结果，但是还有许多事情没办法做到。关于集合，我们想要做的一件最基本的事就是取出集合中的每一个元素，并按照某种方式把每一个元素都转换成另外的新对象。例如，我们希望从一个数集 \\{3, 5, 9\\} 开始，把该集合中的每个元素进行增长，从而构造出一个新集合 \\{4, 6, 10\\} 。直接利用之前学过的公理是无法做到这件事的，因此我们需要一个新公理。\n公理 3.6 (替代) 设 A 是一个集合，对任意的 x\\in A 和任意的一个对象 y ，假设存在一个关于 x 和 y 的命题 P(x,y) 使得对任意的 x\\in A ，最多能够找到一个 y 使得 P(x,y) 为真。那么存在一个集合 \\{y:P(x,y)对某x\\in A为真\\} 使得对任意的对象 z ，\nz\\in\\{y:P(x,y)对某x\\in A为真\\}\\iff 对某x\\in A,P(x,z)为真 例 3.1.31 令 A:=\\{3,5,9\\} ，并且设 P(x,y) 表示命题 y=x++ ，即 y 是紧跟在 x 之后的那个数。观察可知，对任意一个 x\\in A ，只有一个 y 使得 P(x,y) 为真。具体地，就是紧跟在 x 之后的那个数。于是，上面的公理断定集合 \\{y:y=x++对某x\\in\\{3,5,9\\}为真\\} 是存在的。此时，上述集合显然就是 \\{4,6,10\\} 。\n例 3.1.32 令 A:=\\{3,5,9\\} ，设 P(x,y) 表示命题 y=1 。那么同样，对任意的 x\\in A ，只有一个 y 使得 P(x,y) 为真。具体地，就是数字1。此时， \\{y:y=1对某x\\in\\{3,5,9\\}为真\\} 就是单元素集 \\{1\\} ，我们已经把原始集合 A 中的每一个元素3、5、9都用同一个元素1来代替。因此，这个相当无聊的例子告诉我们，通过上述公理得到的集合可以比原始集合更\u0026quot;小\u0026quot;。\n我们经常把形式如\n\\{ y : \\text{ 对某些 } x \\in A \\text{ 有 } y = f(x) \\}\r的集合简写为 \\{ f(x) : x \\in A \\} 或者 \\{ f(x) | x \\in A \\} 。例如，若 A = \\{3, 5, 9\\} ，那么\n\\{ x++ : x \\in A \\} 就是集合 \\{4, 6, 10\\} 。我们当然可以把代数和分类公理合并在一起使用。例如，按照下面的过程构造类似\n\\{ f(x) : x \\in A \\text{ 且 } P(x) \\text{ 为真} \\} 的集合。\n从集合 A 开始，利用分类公理构造集合 \\{ x \\in A : P(x) \\text{ 为真} \\} ，然后使用替代公理构造集合\n\\{ f(x) : x \\in A \\text{ 且 } P(x) \\text{ 为真} \\} 。于是可以有\n\\{ n++ : n \\in \\{3, 5, 9\\} \\text{ 且 } n \u003c 6\\}=\\{4,6\\} 。\n在我们的许多例子中，都隐含地假设了自然数实际上就是对象。对此我们给出下面的正式叙述。\n公理 3.7 (无穷大) 存在一个集合 \\mathbb{N} ，它的元素被称为自然数。对象 0 在 \\mathbb{N} 中，且每一个自然数 n \\in \\mathbb{N} 所指定的满足皮亚诺公理（公理 2.1～2.5）的对象 n++ 也在 \\mathbb{N} 中。\n这是假设 2.6 更加正式的表达。它被称为无穷大公理，因为它引入了无穷大集合一个最基本的例子，也就是自然数集 \\mathbb{N} （我们将在 3.6 节正式阐述有穷大和无穷大的意思）。我们从无穷大公理中能够看到，像 3, 5, 7 等这样的数确实是集合论中的对象，从而（根据双元素集合公理和两集合并集公理）我们的确可以合法构造如 \\{ 3, 5, 9 \\} 这样的集合，就像在之前的例子中我们做过的那样。\n我们必须区分清楚“集合”的概念以及“集合中元素”的概念。例如，集合 \\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} 与表达式或函数 n + 3 并不相同。我们通过下面的例子来强调这一点。\n例 3.1.33 （非正式的）这个例子需要用到减法的概念，但是目前我们还没有正式介绍减法。下面两个命题\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} \\tag{3.1}\r成立（见下文），尽管对任意的自然数 n ，表达式 n + 3 和 8 - n 都绝对不可能相等。\n所以当你谈论集合时，记得要使用大括号 \\{ \\} ，这样可以避免你偶然地把集合与其元素混淆。\n这种看似简单的原因之一是字符 n 在式 (3.1) 的两端是以两种不同的方式使用的。为了阐明这种情况，我们把字符 n 替换成字母 m 来重新书写集合\n\\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} ，于是我们得到\n\\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\} 。它与之前的集合完全相等。因此我们能够把式 (3.1) 重新写成：\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\}\r现在很容易看出（利用定义 3.1.4）为什么该等式为真：每一个形式如 n + 3 的数（其中 n 表示 0 与 5 之间的自然数）也可以写成 8 - m 的形式，其中 m := 5 - n （注意 m 也是 0 到 5 之间的自然数）。反过来，每一个形式 8 - m 的数（其中 m 表示 0 到 5 之间的自然数）也可以写成 n + 3 的形式，其中 n := 5 - m （注意 n 也是 0 到 5 之间的自然数）。观察一下，如果我们没有事先把 n 替换成 m ，那么上面对式 (3.1) 的解释将会让人困惑！\n原因与分析：\n在最初的写法中，集合通通过类似的表达式构造，例如\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - n : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} 。\n这里两边都使用了相同的记号 n ，但在左侧和右侧实际上是两次独立引入的【哑变量】（dummy variable）。从逻辑上讲，这些变量在各自的集合构造中是局部的，不应该相互混淆。然而，当两侧同时使用同一个字母 n 时，该符号可能会被误认为是一个全局的变量，从而产生误解，以为这两个定义式右边一层正用同一个值描述元素。因此会让人困惑：为什么 n+3 的元素集会等于 8-n 的元素集，难道左边两个表达式中 n 是同一回事吗？\n如何解决混淆：\n通过将右侧的 n 改成 m ，得到\n\\{ n + 3 : n \\in \\mathbb{N}, 0 \\leq n \\leq 5 \\} = \\{ 8 - m : m \\in \\mathbb{N}, 0 \\leq m \\leq 5 \\} 。\n现在，这看一眼就能看出：左边用 n 来构造集合，右边用 m 来构造集合，它们是两个独立的参数，各自有独立定义的集合。这样就可以清晰地观察到，左边集合里的每个元素都能通过一个适当的 m （或在集合里的元素都能通过一个合适的 n ）来匹配上。换句话说，改变了字母作为变量之后，变量不会误地将两侧的集合混为一谈，而能顺利理解两个集合事实上是不同的参数化得到的元集合。\n3.习题 设 A 和 B 是集合，证明 吸收率 A \\cap (A \\cup B) = A \\quad \\text{和} \\quad A \\cup (A \\cap B) = A. 证明 A \\cap (A \\cup B) = A 证明 A \\cap (A \\cup B) \\subseteq A : 设 x \\in A \\cap (A \\cup B) 。\n根据集合定义： x \\in A 且 x \\in A \\cup B 。\n由于 x \\in A ，故有 x \\in A \\cap (A \\cup B) \\subseteq A 。\n证明 A \\subseteq (A \\cap (A \\cup B)) : 设 x \\in A 。\n因为 x \\in A 所以显然 x \\in A \\cup B （因为 x \\in A 即满足“或”条件）。\n因此 x \\in A \\cap (A \\cup B) 。\n综上，两方面的包涵都得证，故有 A \\cap (A \\cup B) = A 。\n证明 A \\cup (A \\cap B) = A 证明 A \\cup (A \\cap B) \\subseteq A :\n设 x \\in A \\cup (A \\cap B) 。\n根据并集定义， x \\in A 或 x \\in A \\cap B 。\n若 x \\in A ，则显然 x \\in A 成立。\n若 x \\in A \\cap B ，根据交集定义， x \\in A 且 x \\in B 。此时依然有 x \\in A 。\n故 A \\cup (A \\cap B) \\subseteq A 。\n证明 A \\subseteq (A \\cup (A \\cap B)) :\n设 x \\in A 。\n由于 x \\in A ，显然有 x \\in A \\cup (A \\cap B) 。\n故 A \\subseteq (A \\cup (A \\cap B)) 。\n综上，两方面的包涵都得证，故有 A \\cup (A \\cap B) = A 。\n令 A, B, X 表示集合，并且它们满足 A \\cup B = X 和 A \\cap B = \\emptyset 。证明 A = X \\setminus B 和 B = X \\setminus A 证明 A = X \\setminus B 证明 A \\subseteq X \\setminus B : 任取 x \\in A ，因为 A \\subseteq A \\cup B = X ，可知 x \\in X 。\n又因为 A \\cap B = \\emptyset ，所以 x \\notin B 。\n因此 x \\in X \\setminus B ，故 A \\subseteq X \\setminus B 。\n证明 X \\setminus B \\subseteq A : 任取 x \\in X \\setminus B ，则 x \\in X 且 x \\notin B 。\n已知 X = A \\cup B ，且 x \\in A \\cup B ，则 x \\in A 或 x \\in B 。\n由于 x \\notin B ，则只能有 x \\in A ，故 X \\setminus B \\subseteq A 。\n综上，两方面的包涵都得证，故有 A = X \\setminus B 。\n证明 B = X \\setminus A 的过程与上完全相同，只需将 A 和 B 的角色对调：\nx \\in B \\Rightarrow x \\in X \\text{ 且 } x \\notin A, \\text{ 故 } B \\subseteq X \\setminus A. x \\in X \\setminus A \\Rightarrow x \\in X \\text{ 且 } x \\notin A, \\text{ 由 } X = A \\cup B \\text{ 且 } x \\notin A, \\text{ 得 } x \\in B, \\text{ 故 } X \\setminus A \\subseteq B. 综上可得 B = X \\setminus A 。\n其余习题已于正文中给出。\n策梅洛-弗兰克尔集合论（英语：Zermelo-Fraenkel Set Theory），是数学基础中最常用的一阶公理化集合论。含选择公理时常简写为ZFC，不含选择公理的则简写为ZF。它是二十世纪早期为了建构一个不会导致类似罗素悖论的矛盾的集合理论所提出的一个公理系统。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":["数学分析"],"title":"3.1  基础知识","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/2.1/"},{"content":"1.3.1 泛函导数的概念 对于普通函数的导数，函数的微分是由自变量的微分引起的：\n\\begin{align}\rf(t) \\xrightarrow{t \\to t+\\epsilon} f(\\tilde{t}) \u0026= f(t+ \\epsilon) \\\\\r\u0026= f(t) + \\epsilon df(t) + \\frac{\\epsilon^2}{2!} d^2 f(t) + \\frac{\\epsilon^3}{3!} d^3 f(t) + \\cdots\r\\end{align}\r其中 \\epsilon 是无穷小参数， \\epsilon^n 项即为函数的 n 阶微分，函数的 n 阶导数则由函数的 n 阶微分与 dt 的关系给出。对于一阶导数：\ndf(t) = \\frac{df(t)}{dt} dt\r高阶导数则为：\nd^{(n)} f(t) = \\frac{d^{(n)}f(t)}{dt^n} dt\r只要计算出函数的各阶微分，就可以给出相应的各阶导数。\n泛函导数从形式上完全是对普通函数导数的类比。对于泛函 S[f] ，其变分是由函数的变分引起的：\n\\begin{align}\rS[f] \\xrightarrow{f \\to \\tilde{f}} S[\\tilde{f}] \u0026= S[f + \\epsilon f] \\\\ \u0026= S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots \\end{align}\r这里 \\epsilon^n 项即被称为是泛函的 n 阶变分 \\delta^n S[f] 。仿照函数的 n 阶导数即可定义 n 阶泛函导数。\n定义 1 阶泛函导数\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 其中：\n\\delta f(t) = \\tilde{f}(t) - f(t) 这里 \\delta S 是泛函的一阶变分， \\frac{\\delta S}{\\delta f(t)} 即为一阶泛函导数（the first order functional derivative）。可以看出，一阶泛函导数的作用，是将函数的变分 \\delta f(t) （无穷小函数）映射到泛函的一阶变分 \\delta S （无穷小的数）。这也解释了为什么定义式中出了 dt 的积分。\n为了更好的理解泛函导数，可以将泛函与多元函数进行类比，例如：\n\\delta S[f] := \\int dt \\frac{\\delta S}{\\delta f(t)} \\delta f(t) 可以和多元函数 F = F(x_1, x_2, \\cdots, x_n) 的一阶微分\ndF = \\sum_n \\frac{\\partial F}{\\partial x_n} dx_n 相类比。\n类比函数的高阶导数，高阶泛函导数定义为：\n\\delta^2 S[f] := \\int dt_1 \\int dt_2 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} \\delta f(t_1) \\delta f(t_2) \\delta^3 S[f] := \\int dt_1 \\int dt_2 \\int dt_3 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} \\delta f(t_1) \\delta f(t_2) \\delta f(t_3) 这里的 \\frac{\\delta^2 S}{\\delta f(t_1) \\delta f(t_2)} 和 \\frac{\\delta^3 S}{\\delta f(t_1) \\delta f(t_2) \\delta f(t_3)} 即分别代表 S[f] 对 f 的二阶泛函导数和三阶泛函导数。\n例如，二阶泛函导数的作用，是将函数的变分 \\delta f(t) 映射为泛函的二阶变分 \\delta^2 S （二阶无穷小数）。在经典力学中，我们大多只关注一阶泛函导数。\n","cover":null,"tags":["经典力学"],"title":"1.3 泛函导数","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3/"},{"content":"1.3.2 泛函导数的操作定义 根据上面的讨论，泛函导数归结于计算泛函 S[f] 的变分。\n换个角度，在泛函 S[f + \\epsilon \\delta f] 中， \\epsilon 是一个参数，而泛函 S 是一个数，其值依赖于 \\epsilon 。所以，泛函 S[f + \\epsilon \\delta f] 可以被看作是 \\epsilon 的普通函数，于是公式：\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots\r可以视为 S[f + \\epsilon \\delta f] 相对于 \\epsilon 的普通泰勒展开。\n一般函数在 x_0 处以及 x_0 = 0 的泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^2 + R_n\rR_n=o[(x-x_0)^n]\rf(x) = f(0) + \\frac{f'(0)}{1!}(x) + \\frac{f''(0)}{2!}(x)^2 + \\cdots + \\frac{f^{(n)}(0)}{n!}(x)^2 + R_n\rR_n=o[(x)^n]\r通过比较\nS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\left. \\frac{d}{d\\epsilon} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\frac{\\epsilon^2}{2!} \\left. \\frac{d^2}{d\\epsilon^2} S[f + \\epsilon \\delta f] \\right|_{\\epsilon=0} + \\cdots\rS[f + \\epsilon \\delta f] = S[f] + \\epsilon \\delta S[f] + \\frac{\\epsilon^2}{2!} \\delta^2 S[f] + \\frac{\\epsilon^3}{3!} \\delta^3 S[f] + \\cdots\r即可得到一阶泛函导数的形式：\n\\delta S=\\left.\\frac{d}{d\\epsilon}S[f+\\epsilon \\delta f]\\right|_{\\epsilon=0}=\\int\\limits dt\\frac{\\delta S}{\\delta f(t)}\\delta f(t)\r\\delta S^2=\\left.\\frac{d^2}{d\\epsilon^2}S[f+\\epsilon\\delta f]\\right|_{\\epsilon=0}=\\int dt_1\\int dt_2\\frac{\\delta ^2S}{\\delta f(t_1)\\delta f(t_2)}\\delta f(t_1)\\delta f(t_2)\r高阶泛函导数的形式可以类似的写出。\n对于下述形式的泛函\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\r可以联系一阶泛函导数的形式可以得到\n\\begin{align}\r\\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026\\text{其中} f+\\epsilon\\delta f \\text{是关于} \\epsilon \\text{的函数} f(\\epsilon)，f' \\text{同理}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align}\r上式的被积函数就是 L 的一阶变分 \\delta L ，与其微分形式 dL 全同。只是微分换成了变分。\n这意味着\n\\delta S\\equiv\\delta(\\int\\limits_{t_1}^{t_2}dtL)=\\int\\limits_{t_1}^{t_2}dt\\delta L\r即是说，变分符号可以移到积分内。\n观察一阶泛函导数的形式\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f\r右边只出现了函数的变分 \\delta f 。但是在\n\\begin{align} \\delta S\u0026=\\left.\\int\\limits_{t_1}^{t_2}dt\\frac{d}{d\\epsilon}L(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\\right|_{\\epsilon=0}\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt\\underbrace{(\\frac{\\partial L}{\\partial f}\\delta f+\\frac{\\partial L}{\\partial f'}\\delta f'+\\frac{\\partial L}{\\partial f''}\\delta f''+\\cdots)}_{\\equiv\\delta L} \\end{align}\\\\\r中却出现了函数的导数的变分 \\delta f',\\delta f'',\\cdots ，在处理这个情况时，我们就需要使用变分法中非常重要的技巧——分部积分（integration by parts）。\n分部积分的基本思路是：利用变分和求导可以交换顺序的性质，将作用于 \\delta f 的导数移除，代价是产生额外的“全导数”项，然后设定全导数为边界项，并且忽略边界项，使得泛函的变分式中各项的共有项为 \\delta f ，提出 \\delta f 后即得一阶泛函导数。\n例如，对于正比于 \\delta f' 的项。\n\\frac{\\partial L}{\\partial f'}\\delta f'\\xlongequal{\\text{变分与求导交换顺序}}\\frac{\\partial L}{\\partial f'}\\frac{d}{dt}\\delta f=\\underbrace{\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'}\\delta f)}_{\\text{全导数}}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f\r第二个等号是因为\n\\begin{align} \u0026(uv)'=u'v+uv'\\\\ \u0026uv'=(uv)'-u'v \\end{align}\r类似的，\n\\begin{align} \\frac{\\partial L}{\\partial f''}\\delta f''\u0026=\\frac{\\partial L}{\\partial f''}\\frac{d^2}{dt^2}\\delta f={\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''}\\frac{d}{dt}\\delta f)}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\frac{d}{dt}\\delta f\\\\ \u0026=\\underbrace{\\frac{d}{dt}\\bigg(\\frac{\\partial L}{\\partial f''}\\delta f'-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f''})\\delta f\\bigg)}_{\\text{全导数}}+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f \\end{align}\r由此类推，有\n\\begin{align} \\delta S\u0026=\\int\\limits_{t_1}^{t_2}dt\\bigg[\\frac{\\partial L}{\\partial f}\\delta f-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})\\delta f+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})\\delta f+\\cdots+\\frac{d\\mathcal{B}}{dt}\\bigg]\\\\ \u0026=\\int\\limits_{t_1}^{t_2}dt[\\frac{\\partial L}{\\partial f}-\\frac{d}{dt}(\\frac{\\partial L}{\\partial f'})+\\frac{d^2}{dt^2}(\\frac{\\partial L}{\\partial f''})+\\cdots]\\delta f+\\left.\\mathcal{B}\\right|_{t_1}^{t_2}\r\\end{align}\r这里 \\frac{d\\mathcal{B}}{dt} 代表全导数项。积分后得到的 \\left.\\mathcal{B}\\right|_{t_1}^{t_2} 被称为边界项（boundary term）,在积分的端点（边界）处取值。对比\n\\delta S[f]:=\\int\\limits dt\\frac{\\delta S}{\\delta f}\\delta f\r\\delta S 在上式中的积分已经具有泛函导数的形式，主要的阻碍来自于边界项。由上面的推导可知，如果泛函的被积函数 L 包含 f(t) 的最高 n 阶导数，则边界项 \\mathcal{B} 就包含 \\delta f(t) 的最高 n-1 阶导数。\n因此，变分法的一个基本假设就是： 如果泛函的被积函数包含函数的最高 n 阶导数，那么在积分的边界处，函数及其直到 n-1 阶导数的变分为零。 即\n\\left.\\delta f\\right|_{t_1}=\\left.\\delta f\\right|_{t_2}=0\r\\left.\\delta f'\\right|_{t_1}=\\left.\\delta f'\\right|_{t_2}=0\r\\vdots\r\\left.\\delta f^{(n-1)}\\right|_{t_1}=\\left.\\delta f^{(n-1)}\\right|_{t_2}=0\r在这样的假设下，边界项 \\left.\\mathcal{B}\\right|_{t_1}=\\left.\\mathcal{B}\\right|_{t_2}=0 恒为零。这也意味着，被积函数可以加上函数 f(t) 及其直到 n-1 阶导数的任意函数 F=F(t,f,f',\\cdots,f^{(n-1)}) 的全导数，而不影响泛函导数。\n两个被积函数相差全导数，或者两个积分相差边界项，这件事在变分法中非常重要。因此通常使用专门的符号\u0026quot; \\simeq \u0026quot;来表示：\nL_1\\simeq L_2\\Leftrightarrow L_1=L_2+\\frac{dF(t,f,f',\\cdots)}{dt}\r之所以全导数项是 \\frac{dF(t,f,f',\\cdots)}{dt} 是因为上文中的所有函数 f(t) 都是关于 t 的函数，而所有的泛函 s[f+\\epsilon \\delta f] ，则可被视为是 \\epsilon 的函数。\n以及\nS_1\\simeq S_2\\Leftrightarrow S_1=S_2+\\left.L\\right|_{t_1}^{t_2}\r基于以上假设，对于泛函导数的计算来说，边界项不重要。在实际计算中，都是直接丢掉边界项，而无需写出其具体形式的。例如\n\\frac{\\partial L}{\\partial f^{\\prime}} \\delta f^{\\prime} \\simeq-\\frac{\\mathrm{d}}{\\mathrm{d} t}\\left(\\frac{\\partial L}{\\partial f^{\\prime}}\\right) \\delta f, \\quad \\frac{\\partial L}{\\partial f^{\\prime \\prime}} \\delta f^{\\prime \\prime} \\simeq \\frac{\\mathrm{d}^{2}}{\\mathrm{d} t^{2}}\\left(\\frac{\\partial L}{\\partial f^{\\prime \\prime}}\\right) \\delta f\r基于同样的理由，泛函积分的上下限也经常被省略，即\nS=\\int\\limits dtL\r1.3.3 计算一阶泛函的标准手续 变分原理是整个分析力学的第一原理，而变分法的核心就是计算一阶泛函导数。\n对于\nS[f] = \\int_{t_1}^{t_2} dt L(t, f(t), f'(t), \\cdots)\r这种形式的泛函，可以总结一下关于一阶泛函导数的计算手续。\n(1) 将变分符号 “ \\delta ” 移到积分号内\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\delta L(t, f(t), f'(t), \\cdots)\r(2) 按照类似复合函数求导的规则来计算 \\delta L \\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right)\r这里变分和微分的形式全同，只是微分被换成了变分。\n(3) 做分部积分，将 \\delta f 的导数移除，这是计算一阶泛函导数的最关键的一步。 在实际操作中，只需要不断地将 \\delta f 的导数移除，并不需要关注全导数项的具体形式。\n(4) 提取 \\delta f 前的系数，即为一阶泛函导数。\n根据以上的手续，经过分部积分，式子\n\\delta S[f] = \\int_{t_1}^{t_2} dt \\left( \\frac{\\partial L}{\\partial f} \\delta f + \\frac{\\partial L}{\\partial f'} \\delta f' + \\frac{\\partial L}{\\partial f''} \\delta f'' + \\cdots \\right)\r成为\n\\delta S \\simeq \\int_{t_1}^{t_2} dt \\left[ \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots \\right] \\delta f\r从中得到一阶泛函导数\n\\boxed{\\frac{\\delta S}{\\delta f} = \\frac{\\partial L}{\\partial f} - \\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial f'} \\right) + \\frac{d^2}{dt^2} \\left( \\frac{\\partial L}{\\partial f''} \\right) + \\cdots}\r需要强调的是，虽然上式在形式上绝对正确， 但是最好不要将偏导数 \\frac{\\partial L}{\\partial f} 、 \\frac{\\partial L}{\\partial f'} 、 \\frac{\\partial L}{\\partial f''} ……先计算出来再代入式子中，而应该按照上面的“变分—分部积分”操作步骤。\n例 1.1 一阶泛函导数\n考虑泛函 S[f] = \\int dt \\left[ (f'(t))^2 - (f(t))^2 \\right] ，有\n\\begin{align}\r\\delta S[f] \u0026= \\int dt \\, \\delta \\left( f'^2 - f^2 \\right) \\\\\r\u0026= \\int dt \\left( 2 f' \\delta f' - 2 f \\delta f \\right) \\\\\r\u0026= \\int dt \\left( 2 f' \\delta f' \\right) - \\int dt \\left( 2 f \\delta f \\right) \\\\\r\\int dt \\, f' \\delta f' \u0026= \\left[ f' \\delta f \\right] - \\int dt \\, f'' \\delta f \\\\\r\\Rightarrow\\int dt \\, f' \\delta f' \u0026= - \\int dt \\, f'' \\delta f \\\\\r\\delta S[f] \u0026= - \\int dt \\, 2 f'' \\delta f - \\int dt \\, 2 f \\delta f \\\\\r\\delta S[f] \u0026\\approx \\int dt \\left( - 2 f'' - 2 f \\right) \\delta f(t)\r\\end{align}\r因此一阶泛函导数为\n\\frac{\\delta S}{\\delta f(t)} = -2 f''(t) - 2 f(t).\r例 1.2 一阶泛函导数与全导数\n考虑泛函 S[f] = \\int dt \\left[ f(t) f'(t) + f'(t) f''(t) \\right] ，有\n\\begin{align}\r\\delta S[f] \u0026= \\int dt \\, \\delta \\left( f f' + f' f'' \\right) \\\\\r\u0026= \\int dt \\left( \\delta f f' + f \\delta f' + \\delta f' f'' + f' \\delta f'' \\right) \\\\\r\u0026= \\int dt \\left( \\delta f f' \\right) + \\int dt \\left( f \\delta f' \\right) + \\int dt \\left( \\delta f' f'' \\right) + \\int dt \\left( f' \\delta f'' \\right) \\\\\r\\end{align}\r\\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f \\int dt \\, \\delta f' f'' = \\left[ \\delta f' f' \\right] - \\int dt \\, f' \\delta f'' = - \\int dt \\, f' \\delta f'' \\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f\r\\int dt \\, f' \\delta f'' = \\left[ f' \\delta f' \\right] - \\int dt \\, f'' \\delta f' = - \\int dt \\, f'' \\delta f' \\int dt \\, f'' \\delta f' = \\left[ f'' \\delta f \\right] - \\int dt \\, f''' \\delta f = - \\int dt \\, f''' \\delta f\r最终 \\begin{align}\r\\delta S[f] \u0026= \\int dt \\left( f' \\delta f - f' \\delta f - f''' \\delta f + f''' \\delta f \\right) \\\\\r\u0026= 0\r\\end{align}\r其中，在此例的推导过程中，第一项\n\\int dt \\delta f f'\r这一项可以选择直接处理，不需要分部积分，主要是因为 \\delta f 只是一个变分项，而 f' 是一个普通的导数函数，这里没有更高阶的导数存在，所以我们没有对其进行分部积分。\n第二项\n\\int dt f\\delta f'\r这一项需要分部积分，目的是将 \\delta f' 变分项中的导数和变分分离开来，通过分部积分后得到\n\\int dt \\, f \\delta f' = \\left[ f \\delta f \\right] - \\int dt \\, f' \\delta f 这里我们将 \\delta 和 f' 分离，避免处理变分的导数项。同时丢弃了边界项。 \\left[ f \\delta f \\right] 。\n基于同样的理由，第三项和第四项都进行了分部积分丢弃全导数项的过程。因此一阶泛函导数为零。\n在这个例子中，出现了泛函导数为零的情况。实际上，观察泛函中的被积函数， f f' + f' f'' = \\frac{d}{dt} \\left( \\frac{1}{2} f^2 + \\frac{1}{2} f'^2 \\right) \\equiv \\frac{dF}{dt} ，其自身就是个全导数。而根据上面的讨论，被积函数中的全导数可以自然舍去，所以 f f' + f' f'' \\approx 0 ，难怪其对应的泛函导数为零了。\n另外，通过以上两个例子的分析我们可以发现：\n我们分部积分的根本目的就是为了分离变分号 \\delta 和导数 f' ，因此，对于任何被变分和求导同时操作的函数项 f ，我们都需要对它进行分部积分。 由于分部积分的性质 (uv)'=u'v+uv'\r\\int u'v=[uv]-\\int uv'\r因此，我们可以注意要有这样一种便捷的记忆方式，例如对于\nf\\delta f'\r变分和求导同时作用于 f ，因此我们需要对此项进行分部积分。而我们可以将该项视为 u'v 或者 uv' 中的任意一项（它们的区别仅仅只是两个乘数互换一下位置而已），一旦确定好了，那么最终的 \\simeq 结果就是另外一项。\n而事实上，不管我们选择哪个形式，根据两者的形式差异，我们就可以断定， \\simeq 结果一定是\nf'\\delta f\r利用这种视角我们来看，\nf''\\delta f'\r另一项的形式一定是两个乘数的导数次数一赠一减，并且由于我们是分离变分和求导，因此变分号里的导数次数一定是减少的，所以最终的结果就是\nf'''\\delta f\r事实上，这相对于是我们将 f''\\delta f' 看成是 uv' ，实际上，我们我们将之看成 u‘v 的话，我们就需要经历以下的过程：\nf''\\delta f'\\Rightarrow f'\\delta f''\r很显然它是需要继续分部积分的，因此\nf''\\delta f'\\Rightarrow f'\\delta f''\\Rightarrow f''\\delta f'\r最后再进行一次分部积分得到，\nf''\\delta f'\\Rightarrow f'\\delta f''\\Rightarrow f''\\delta f'\\Rightarrow f'''\\delta f'\r这也就是我们在上面的做法，很显然结果是一样的，而且这样是多此一举。\n以及最后，很显然的我们可以发现，每次分部积分的结果都是负的，因此进行奇数次分部积分的结果是负的，偶数次是正的。 ","cover":null,"tags":["经典力学"],"title":"1.3.2 泛函导数的操作定义","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.3.2/"},{"content":"目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。\n具体做法如下：\n5 加上 3 与对 5 进行 3 次增量运算的结果是一样的。且这比 5 加上 2 多了一次增量运算，而 5 加 2 又比 5 加 1 多了一次增量运算。5 加 1 比 5 加 0 多了一次增量运算，最后，5 加 0 就等于 5。如此，我们就可以递归的定义加法运算。\n定义 2.2.1 (自然数的加法) 令 m 为一个自然数，我们定义 m 加 0 为：\n0+m:=m\r现在归纳的假设我们已经定义了如何将 m 加上 n。那么，我们将 m 加上 n++ 定义为\n(n++)+m:=(n+m)++\r于是， 0+m 就是 m， 1+m 就是 (0++)+m=(0+m)++=m++ ， 2+m 就是 (1++)+m=(1+m)++=(m++)++ ，以此类推。例如：\n2+m=(1++)+m=(1+m)++=(m++)++\\\\\r2+3=(1++)+3=(1+3)++=(3++)++=4++=5\\\\\r根据数学归纳原理，以上，对于任意自然数 n，我们已经定义了 n+m。\n现在，我们将之前一般化的讨论特殊化为， a_n=n+m 和 f_n(a_n)=a_n++ 的情景。\n注意：我们以上定义的自然数加法是不对称的： 3+5 表明将 3 增长了 5 次，而 5+3 表明将 5 增加了 3 次。不过，它们生成的值是一样的。更一般，对于任意自然数 m、n。有\nm+n=n+m\r均成立。（我们将稍后给出其证明）\n引理 2.2.2 对任意自然数 n， n+0=n 恒成立。\n注意，我们的定义是 0+m:=m ，由于我们尚未证明 m+n=n+m 对于任意自然数 n、m 均成立，因此我们不可以直接通过交换律得到 n+0=n 。\n证明:\n采用归纳法来证明。因为 0 + m = m 对任意自然数 m 均成立并且 0 是一个自然数，所以我们能得到最基本的情况 0 + 0 = 0 。\n现在归纳性地假设 n + 0 = n 成立。我们希望证明 (n++) + 0 = n++ 。\n根据加法的定义， (n++) + 0 = (n + 0)++ ；\n又根据 n + 0 = n 可以推导出 (n + 0)++ = n++ 。\n至此整个归纳过程就结束了。 \\Box 引理 2.2.3 对任意的自然数 n 和 m ，有\nn + (m++) = (n + m)++ 成立。\n同样，因为目前我们还不知道有 a + b = b + a ，所以不能从 (n++) + m = (n + m)++ 中推导出本结论。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先考虑最基本的情况， n = 0 。此时我们必须证明\n0 + (m++) = (0 + m)++ 根据加法定义，左侧等于 m++ ，再次根据加法定义，显然右侧也为 m++ ，因此等式成立。\n现在归纳性地假定 n + (m++) = (n + m)++ 成立，那么我们必须证明\n(n++) + (m++) = ((n++) + m)++ 根据加法的定义，上式左端等于 (n + (m++))++ 又由归纳假设可得 (n+(m++))++ = ((n + m)++)++\r。 类似地，根据加法的定义可得， (n++) + m = (n + m)++ ，从而等式的右端也等于 ((n + m)++)++ 。\n因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。 \\Box 作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到\nn++ = n + 1。 因为 n+1=n+(0++)=(n+0)++=n++ 。\n如之前承诺的，现在，我们来证明 a + b = b + a 。\n命题 2.2.4 （加法是可交换的）\n对任意的自然数 n 和 m ，有\nn + m = m + n 成立。\n证明:\n将 m 设为定值，对 n 采用归纳法。首先证明当 n = 0 时结论成立，也就是说证明 0 + m = m + 0 。\n一方面，根据加法的定义可以推出 0 + m = m ；\n另一方面，根据引理 2.2.2 可得 m + 0 = m 。\n于是 n = 0 时结论成立。\n现在归纳性地假设 n + m = m + n 成立，那么我们要证明\n(n++) + m = m + (n++) 来完成归纳。\n根据加法的定义， (n++) + m = (n + m)++ ；\n根据引理 2.2.3， m + (n++) = (m + n)++ ；\n但由归纳假设 n + m = m + n 可知 (m + n)++ = (n + m)++ 。\n因此 (n++) + m = m + (n++) ，进而归纳过程结束。 \\Box 命题 2.2.5 （加法是可结合的）\n对任意三个自然数 a 、 b 、 c ，有\n(a + b) + c = a + (b + c) 成立。\n证明:\n固定 a, c \\in N , 对 b 进行归纳讨论.\n设定当 b = 0 :\n(a + 0) + c = a + c = a + (c + 0) = a + (0 + c) 现在归纳假设 b=n 时命题成立, 需要证明 b=n++ 时命题成立:\n\\begin{align} (a + (n++)) + c \u0026= ((a + n)++) + c \\\\ \u0026= c + ((a + n)++) \\\\ \u0026= (c + a + n)++ \\\\ \u0026= ((a + n) + c)++ \\\\ \u0026= (a + (n + c))++ \\\\ \u0026= a + (n + c)++ \\\\ \u0026= a + ((n++) + c) \\end{align} 根据数学归纳法，命题对所有自然数均成立。\n正是因为有了这条结合律，我们可以把 a, b, c 的和写成 a + b + c 的形式，而无需顾虑它们是按照什么样的次序加起来的。\n下面，我们给出消去律。\n命题 2.2.6 （消去律）\n令 a, b, c 为任意三个自然数并且满足\na + b = a + c, 那么 b = c 成立。\n注意:\n由于目前我们还没有给出减法和负数的概念，所以这里不能利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及了一种“虚拟减法”。\n证明:\n我们通过对 a 进行归纳来证明该命题。\n首先考虑最基本的情况 a = 0 ，我们有\n0 + b = 0 + c, 那么根据加法的定义，由 0 + b = 0 + c 可以得到 b = c ，故命题成立。\n现在归纳性假设关于 a 的消去律成立（进而从 a + b = a + c 中可以得到 b = c ），接下来我们要证明关于 a++ 的消去律也成立。换言之，就是在假设\n(a++) + b = (a++) + c 成立时，去证明 b = c 成立。根据加法的定义，我们有\n(a++) + b = (a + b)++ 和\n(a++) + c = (a + c)++, 从而可以得到\n(a + b)++ = (a + c)++. 根据公理 2.4（任意两个不同的自然数的后继也是不同的），我们进一步得到\na + b = a + c. 显然上式为待证情况的充要条件。因为我们已知关于 a 的消去律成立，所以有 b = c 成立，结论得证。至此归纳法结束。\n\\Box 现在我们讨论加法与正性是如何相互作用的。\n定义 2.2.7 （正自然数） 称一个自然数 n 是正的，当且仅当它不等于 0 。\n命题 2.2.8 如果 a 是正的并且 b 是自然数，那么 a + b 是正的（从而根据命题2.2.4可知， b + a 也是正的）。\n证明： 我们通过对 b 进行归纳来证明该命题。如果 b = 0 ，那么\na + b = a + 0 = a 显然是正的，从而 b = 0 时的结论得证。\n现在归纳性地假设 a + b 是正的。那么根据公理 2.3 (0 不是任何自然数的后继)可知，\na + (b++) = (a + b)++ 不等于零，从而 a + (b++) 是正的。至此归纳法结束。\n\\Box 推论 2.2.9\n如果 a 和 b 是自然数并且满足 a + b = 0 ，那么 a = 0 且 b = 0 。\n证明：\n假设结论的反面 a \\neq 0 或 b \\neq 0 成立。如果 a \\neq 0 ，那么 a 是正的，从而根据 命题 2.2.8 可知， a + b 是正的，这显然与已知条件 a + b = 0 相矛盾。类似地，如果 b \\neq 0 ，那么 b 是正的，同样根据 命题 2.2.8 可知， a + b 是正的，这与 a + b = 0 相矛盾。于是 a 和 b 必须同时为 0 。□\n引理 2.2.10 令 a 表示一个正自然数，那么恰存在一个自然数 b 使得 b++ = a 。\n证明： 根据皮亚诺公理 3 （0 不是任何自然数的后继）和 4（不同自然数的后继互不相同）有 \\forall m, n \\in \\mathbb{N}, S(m) = S(n) \\implies m = n.\r则， \\begin{align}\r\u0026S(b)=a\\\\\r\u0026\\forall n \\in \\mathbb{N},\\text{if} S(n)=S(b)=a \\implies n = b.\r\\end{align}\r至此命题成立。\n定义 2.2.11 （自然数的序）\n令 n 和 m 表示任意两个自然数。我们称 n 大于等于 m ，并且记作 n \\geq m 或者 m \\leq n ，当且仅当存在自然数 a 使得 n = m + a 。我们称 n 大于 m ，并且记作 n \u003e m 或者 m \u003c n ，当且仅当 n \\geq m 且 n \\neq m 。\n于是，例如由于 8 = 5 + 3 并且 8 \\neq 5 ，所以 8 \u003e 5 。另外注意，对任意的 n 均有 n++ \u003e n ；因此不存在最大的自然数 n ，这是因为下一个数 n++ 总是更大。\n命题 2.2.12 （自然数的序的基本性质）\n令 a, b, c 为任意自然数，那么：\n(a) （序是自反的） a \\geq a 。\n(b) （序是可传递的）如果 a \\geq b 并且 b \\geq c ，那么 a \\geq c 。\n(c) （序是反对称的）如果 a \\geq b 并且 b \\geq a ，那么 a = b 。 (d) （加法保持序不变） a \\geq b ，当且仅当 a + c \\geq b + c 。\n(e) a \u003c b ，当且仅当 a++ \\leq b 。\n(f) a \u003c b ，当且仅当存在正自然数 d 使得 b = a + d 。\n证明:\n(a) a \\geq a a + 0 = a \\rightarrow a \\geq a (b) a \\geq b,b \\geq c ，那么 a \\geq c \\begin{align}\ra \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\\rb \\geq c \\rightarrow b = c + m, m \\in \\mathbb{N}\\\\\r\\end{align}\r因此， a = b + n = c + m + n\r显然就可得结论， a \\geq c (c) a \\geq b，b \\geq a ，则 a = b \\begin{align}\ra \\geq b \\rightarrow a = b + n, n \\in \\mathbb{N}\\\\\rb \\geq a \\rightarrow b = a + m, m \\in \\mathbb{N}\\\\\r\\end{align}\r即 a = a + m + n\r显然， m = 0，n = 0 ，则 a = b 。\n(d) a \\geq b if and only if a + c \\geq b + c . \\begin{align}\r(a \\geq b) \u0026\\iff a = b + m, \\, m \\in \\mathbb{N} \\\\\r\u0026\\iff a + c = b + m + c = b + c + m, \\, m \\in \\mathbb{N} \\\\\r\u0026\\iff a + c \\geq b + c.\r\\end{align}\r(e) a \u003c b if and only if a++ \\leq b .\nWe have\n\\begin{align}\r(a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\\r\u0026\\iff ((a + m = b, \\, m \\in \\mathbb{N}) \\land (a \\neq b)) \\\\\r\u0026\\iff m \\neq 0 \\\\\r\u0026\\iff \\exists n \\in \\mathbb{N}, \\, n++ = m \\\\\r\u0026\\iff a + (n++) = b, \\, n \\in \\mathbb{N} \\\\\r\u0026\\iff (a++) + n = b, \\, n \\in \\mathbb{N} (引理 2.2.3)\\\\\r\u0026\\iff a++ \\leq b.\r\\end{align}\r(f) a \u003c b if and only if b = a + d for some positive number d .\nWe have\n\\begin{align}\r(a \u003c b) \u0026\\iff ((a \\leq b) \\land (a \\neq b)) \\\\\r\u0026\\iff (a + d = b, \\, d \\in \\mathbb{N}) \\land (d \\neq 0) \\\\\r\u0026\\iff a + d = b, \\, d \\text{ is positive.}\r\\end{align}\r命题 2.2.13 （自然数的序的三歧性）\n令 a 和 b 表示任意两个自然数，那么在下面三种表述中恰有一种表述为真： a \u003c b ， a = b ， a \u003e b 。\n证明：\n首先我们证明 a \u003c b ， a = b 以及 a \u003e b 这三种表述中同时为真的表述个数不超过一个。如果 a \u003c b ，那么根据定义可知 a \\neq b ；同样，如果 a \u003e b ，根据定义可知 a \\neq b 。如果 a \u003e b 并且 a \u003c b ，那么根据命题 2.2.12 可知 a = b ，这显然与 a \\neq b 相矛盾。因此同时为真的表述个数不超过一个。\n现在我们证明至少有一个表述为真。\n保持 b 固定不变，对 a 进行归纳。当 a = 0 时，对所有的 b 均有 0 \\leq b （为什么？）因此我们得到 0 = b 或者 0 \u003c b ，从而 a = 0 时的结论得证。\n现在归纳性地假设关于 a 的命题已经被证明是成立的，下面我们要证明 a++ 也同样成立。\n从关于 a 的三歧性中可知，存在三种可能的情况： a \u003c b ， a = b 以及 a \u003e b 。如果 a \u003e b ，那么有 a++ \u003e b 。（为什么？）如果 a = b ，那么 a++ \u003e b 。（为什么？）现在假设 a \u003c b ，那么根据命题 2.2.12 可知 a++ \\leq b 。于是我们得到要么 a++ = b ，要么 a++ \u003c b ，其中任何一种情况都符合我们的要求。至此归纳法结束。\nWhy 1: When a = 0 , we have 0 \\leq b for all b .\n(0 + b = b, b \\in \\mathbb{N}) \\Rightarrow (0 \\leq b, b \\in \\mathbb{N})\rWhy 2: If a \u003e b , then a++ \u003e b .\n(a \u003e b) \\Rightarrow (a = b + m, m \\in \\mathbb{N}) \\land (a \\neq b) \\\\ \\Rightarrow a++ = b + (m++) \\Rightarrow a++ \u003e b Why 3: If a = b , then a++ \u003e b .\n(a = b) \\Rightarrow a++ = b++ = (b + 0)++ = b + (0++) = b + 1 \\\\ \\Rightarrow a++ \u003e b 命题 2.2.14 （强归纳法原理）\n令 m_0 表示一个自然数， P(m) 表示与任意自然数 m 有关的性质。假设对任意满足 m \\geq m_0 的自然数 m ，均有如下内容成立：若 P(m') 对任意满足 m_0 \\leq m' \u003c m 的自然数 m' 均为真，那么 P(m) 也为真。（特别地，这意味着 P(m_0) 为真，因为当 m = m_0 时，前提中的 m' 取值范围为空。）于是我们能够断定，对于任意满足 m \\geq m_0 的自然数 m ， P(m) 为真。\n注 2.2.15 在应用强归纳法原理的时候，我们通常令 m_0 = 0 或者 m_0 = 1 。\n证明： 设 P(m) 是一个与自然数 m 相关的命题。如果满足以下条件：\n基础情况：当 m = m_0 时， P(m_0) 为真。 归纳假设：对于任意 m \u003e m_0 ，如果 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 也为真。 则结论是： P(m) 对所有 m \\geq m_0 成立。\n证明过程\n1. 用普通归纳法重新定义问题\n设 Q(n) 表示如下命题：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ，命题 P(m) 都为真。\n我们的目标是证明：对于所有正整数 n ， Q(n) 成立。这等价于强归纳原理，因为 Q(n) 的结论覆盖了 P(m) 在 m \\geq m_0 的所有情况。\n2. 验证基础情况\n当 n = 1 时， Q(1) 的含义是：对于所有 m 满足 m_0 \\leq m \u003c m_0 + 1 ， P(m) 为真。\n因为能满足 m_0 \\leq m \u003c m_0 + 1 的自然数 m 只有 m_0 ，因此此情况下性质仅涉及 P(m_0) ，而强归纳原理假设， P(m_0) 为真，因此 Q(1) 为真。\n3. 验证归纳步骤\n假设 Q(n) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n ， P(m) 为真。\n需要证明 Q(n+1) 为真，即：\n对于所有 m 满足 m_0 \\leq m \u003c m_0 + n + 1 ， P(m) 为真。\n根据 Q(n) ，我们已经知道：\nP(m') 对于所有 m_0 \\leq m' \u003c m_0 + n 都成立。 我们现在需要证明 P(m_0 + n) 为真。这与基础情况的逻辑是相同的。\n因为 Q(n+1) 的定义是 Q(n+1) := \\forall m(m_0 \u003c m \u003c m_0 + n + 1 \\rightarrow P(m) \\text{为真})\r根据归纳假设， Q(n) 为真，即 P(m) \\text{对于所有的} m_0 \\le m \u003c m_0 + n \\text{都为真}\r所以我们有待验证的范围还剩下 m_0 + n \\le m \u003c m_0 + n + 1\r而满足上述范围的自然数 m 只有 m_0 + n 。\n综上，我们只需要证明 P(m_0 + n) 为真，即可得到 Q(n+1) 为真。\n根据强归纳原理假设，若 P(m') 对所有 m_0 \\leq m' \u003c m 都成立，则 P(m) 为真。\n将 m = m_0 + n 代入，这里 P(m') 对所有 m_0 \\leq m' \u003c m_0 + n 已经成立（由归纳假设 Q(n) ），因此 P(m_0 + n) 为真。\n结合归纳假设，我们得出 Q(n+1) 为真。\n4. 归纳完成\n通过普通数学归纳法，我们证明了 Q(n) 对所有正整数 n 都成立。这意味着：\n对于所有 m \\geq m_0 ， P(m) 为真。 逆向归纳法原理\n令 n 表示一个自然数， P(m) 是关于自然数的一个性质并且满足：只要 P(m++) 为真， P(m) 就为真。假设 P(n) 也为真，证明： P(m) 对任意满足 m \\leq n 的自然数 m 均为真；这被称为逆向归纳法原理。（提示：对变量 n 使用归纳法。）\n证明： Induction on n , let Q(n) represent:\nQ(n) := \\{ P(m) \\text{ is true, } \\forall m \\leq n \\} Case 0: Q(0) is true.\nIf Q(k) is true, then consider Q(k++) :\nQ(k++) = \\{ P(m) \\text{ is true, } \\forall m \\leq k++ \\} ,\nas P(k++) is true. Hence, Q(k++) is true.\nThe induction is valid.\n","cover":null,"tags":["数学分析"],"title":"2.2 加法和归纳原理的两个变体","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.2/"},{"content":"在学习实数分析之前，我们首先要回溯数的概念以及数的性质。\n我们已经和数打了很多年的交道了，我们会熟练的利用代数法则和数进行计算，那么现在请让我们转向一个更基本的问题：为什么代数法则是有效的？例如，对于 a(b+c)=ab+ac 为什么总是成立的?\n实际上，这些运算法则不是随意给出的，而是通过数系更为原始也更为基本的性质中推演得到的。这推演会使我们获得新的技能，即使用较为简单的性质来推导更加复杂的性质。在这个过程中，请时刻记得怀疑的精神，也就是不要轻易的接受一个结论，要思考一个显然成立的命题为什么是显然的。\n现在，我们要根据皮亚诺公理给出定义自然数的一种标准方法。\n自然数集定义 定义 2.1.1 （非正式的）自然数是集合\nN := \\{ 0, 1, 2, 3, \\cdots \\}\r的元素。其中，集合是从 0 开始的，无休止的往前进行计数所得列的所有元素构成的集合。我们称 N 为自然数集。\n注 2.1.2 在有些教材中，自然数被定义为从 1 而不是 0 开始的，但这仅仅是一种符号约定罢了。在以后的讨论中，我们定义集合 \\{1, 2, 3, \\cdots \\} 为正整数集，并记为 Z^+ ，而不是自然数集。自然数有时候也被称为完整数（whole number）。\n从某种意义上讲，上述定义给出了什么是自然数这个问题的答案：自然数是集合 N 中的元素。然而这个定义并非真正的那么令人满意。因为它带来了一个新的问题：\nN 到底是什么？“从 0 开始，无休止的计数”看起来好像是对 N 的足够直观的定义描述，但是这样的叙述尚未解决的可能性问题，例如：如何确定我们不会出现无休止的计数结果循环回到 0 的情景？我们应当怎样在上述定义之下构造出一个系列的计算？\n我们首先来回答第二个问题：我们应该怎样在上面定义诸如加法、乘法等一系列的计算？\n我们使用的方法就是利用较为简单的运算来定义较为复杂的运算。指数运算只不过是对乘法运算的重复迭代：\na^3 = a \\cdot a \\cdot a 。\n乘法运算只不过是对加法运算的重复迭代：\n3 \\cdot a = a + a + a 。\n（由于减法和除法运算并不完全适用于自然数的运算，因此我们暂不讨论。我们在整数数和有理数对应的章节时，会对这些运算进行讨论。）\n加法和增量运算 那么加法又是怎么定义的呢？加法就是重复往前计数或者不断增加的运算。\n如果你把 5 加上 3 ，也就是使得 5 增长了三次。另外，增长看起来是一个基本的运算，它不能再被拆解为更加简单的运算。\n于是，为了定义自然数，我们将使用如下两个基本概念：数 0 和增量运算。我们使用 n++ 来表示 n 的增量或者紧跟在 n 后面的数字。例如： 3++ = 4, (3++)++ = 5 。\n注意，这与计算机的语言不同，在数学中，我们对一个变量只赋值一次。\n因此，这看起来就似乎说明 N 是由 0 以及所有能通过增量运算由 0 得到的数构成的。这就是 N 应该如下对象构成的：\n0, 0++, (0++)++, \\cdots\r如果我们把自然数用上述对象来表示，那么得到了如下关于 0 和增量运算的公理。\n公理2.1 ~ 定义2.1.3 定义自然数集的具体元素 公理 2.1 0 是自然数。\n公理 2.2 如果 n 是自然数，那么 n++ 也是自然数。\n于是，举例来说，我们能通过公理2.1和公理2.2，可以推的 (0++)++ 是一个自然数。为了计数书写的方便，我们又有如下的定义。\n定义 2.1.3\n我们定义1为数 0++ ，2为数 (0++)++ 等等。\n于是，举例来说，我们有：\n命题 2.1.4 3 是一个自然数\nproof:\n根据公理2.1可知， 0 是一个自然数。根据公理2.2， 0++ = 1 是一个自然数。又根据公理2.2， 1++ = 2 也是自然数，那么再通过依序公理2.2， 2++ = 3 自然也是自然数。\n目前看来，我们对自然数已经有了充分的描述，但对于 N 的性质尚未彻底厘清。\n公理2.3 ~ 公理2.5 定义自然数系的具体性质 虽然我们定义了 0 和增量运算，并打算以此来构建自然数系，但是我们并没有对自然数系的性质做出规定。例如我们目前没有方法确定定义的自然数系会不会出现循环的情况，即\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 0\r为了防止以上这种循环情况的产生，我们将引入另外的公理。\n公理 2.3\n0 不紧跟在任何自然数之后。换言之，对于任意一个自然数 n ， n++ \\neq 0 均成立。\n如此一来，我们就有防止循环情况出现的工具了。\n命题 2.1.6 4 \\neq 0 proof:\n根据定义 4 = 3++ ，根据公理2.1和公理2.2，可知 3 是一个自然数，故根据公理2.2， 4 也是一个自然数，再根据公理2.3，我们就有 3++ = 4 \\neq 0 。\n除此之外，我们还需要对其他的性质进行研究和规定，否则我们的数系仍然会存在很多病态的性质。\n例 2.1.7\n考虑由 0, 1, 2, 3, 4 构成的数系。在这个数系里，增量运算在遇到 4 时达到了运算的极限。换言之，在这个数系里\n0++ = 1, \\, 1++ = 2, \\, 2++ = 3, \\, 3++ = 4, \\, 4++ = 4\r（换言之，也就是 5 = 4++ = 4, 7 = 4++ = 4 ）。这种情况并不违背我们上面规定的任何公理或者定义，甚至，我们虽然防止了我们的自然数系出现绕回到 0 的情况，但它仍然可以绕回到 1, 2 等其他自然数。\n有许多的方法可以阻止这些情况发生，最简单的方法是设定下面的公理成立。\n公理 2.4\n对于不同的自然数而言，紧跟在它们之后的数字也必然不同。也就是说，如果 n 和 m 都是自然数，并且 n \\neq m ，那么 n++ \\neq m++ 。\n等价地说，如果 n++ = m++ ，则 n = m 。\n命题 2.1.8 6 不等于 2\nproof:\n使用反证法，假设 6 = 2 ，那么有 5++ = 1++ 。根据公理2.4，有 5 = 1 ，进而有 4++ = 0++ 。再次利用公理2.4，也就有 4 = 0 。在我们的数系中，只有 0 \\sim 4 这几个数是被定义好的，所有根据我们的规定， 4 = 0 与命题2.1.6矛盾，所有我们有结论 6 \\neq 2 。\n规定了上述的公理后，我们还需要考虑这样的自然数系的元素问题，目前来看，好像所有的自然数都是两两不同的，我们已经确定 0, 1, 2, 3, 4, \\cdots 是自然数系的不同对象，但是它们之间是否有其他形式的数字存在呢？\n例 2.1.9 （非正式的）\n假设我们的数系 N 是由如下的整数和半整数共同构成的：\nN := \\{0, 0.5, 1, 1.5, 2, 2.5, \\cdots\\}\r（该例之所以是非正式的是因为，我们提前使用了实数，但我们现在还没有定义实数。）容易验证，这个例子仍然满足公理2.1~公理2.4。\n为此我们希望有这样一个公理，它告诉我们自然数系的所有元素都可以通过对 0 进行增量运算来得到，从而能够从 N 中排除像 0.5 这种形式的元素。幸运的是，我们有一种巧妙的解决办法达到前述要求：\n公理 2.5 （数学归纳法）\n令 P(n) 表示自然数 n 满足的一种任意的性质，如果 P(0) 为真并且 P(n) 为真时 P(n++) 也为真，则对于任意的自然数 n ， P(n) 一定为真。\n隐藏在这个公理中的通俗的直观的说明如下：假设 P(n) 满足以下条件： P(0) 为真，且 P(n) 为真时 P(n++) 也为真，那么由于 P(0) 为真，所以 P(0++) = P(1) 也为真，进而 P(1++) = P(2) 也为真，以此类推我们可以得到 P(0), P(1), P(2), P(3), \\cdots 均为真。\n然而根据这样的规定，我们根本没有定义 0.5 这样的元素，因此公理2.5对 P(0.5) 是失效的，从而我们就避免了自然数系中出现附带的奇怪对象。\n在公理2.5之上，我们将在习题中给出关于它的其他形式，它们分别是：逆向归纳法、强化归纳法和超限归纳法*（这名字好酷对吧）。\n公理2.1 ~ 公理2.5被称为皮亚诺公理，这套公理系统就是定义自然数系的方法之一。为了定义自然数系，我们假设存在一个数系 N ，我们称 N 中的元素为自然数，而且公理2.1 ~ 公理2.5对 N 均成立。\n根据前面的所有规定，我们可以得到以下的这个结论：现在我们可以递归的定义序列。\n递归定义 假设我们通过以下方式来构造数列 a_0, a_1, a_2, \\cdots ：首先定义 a_0 的基值。例如，令 a_0 = c ，其中 c 是一个固定的数字。然后令 a_1 为关于 a_0 的某个函数： a_1 := f_0(a_0) ，令 a_2 为关于 a_1 的某个函数： a_2 := f_1(a_1) 。以此类推，一般地，我们记 a_{n++} := f_n(a_n) ，其中 f_n 是 N \\to N 的某个函数。利用前面的公理可以推出，对于任意给定的自然数 n ，上述过程将对应数列中的元素 a_n 给出唯一的值。\n更准确的说：\n命题 2.1.10 （递归定义）\n假设对于任何自然数 n ，都存在从自然数系到自然数系的函数 f_n: N \\to N ，令 c 为某个固定的自然数，那么对于任意的自然数 n ，都可以唯一确定自然数 a_n ，使得 a_0 = c 以及 a_{n++} = f_n(a_n) 恒成立。\nproof:\n利用归纳法。首先，根据题设，我们有 a_0 = c 。假设，题设的过程对 a_m 赋予了单一的值，由于公理2.3（ n++ \\neq 0 ）和公理2.4（ n++ \\neq m++ \\iff n \\neq m ），可知上述过程 a_{n++} := f_n(a_n) 对 a_n 来说是不会改变 a_n 的赋值的，因此可知上述过程也同样使得 a_{n++} 被唯一赋值了。那么根据数学归纳法，对于任意的自然数 n ， a_n 都被定义了，并且每个 a_n 都赋予了唯一的值。\n注意所有的公理在这个过程中是如何被应用的。在一个数系中，如果存在某种类型的绕回状况，那么递归定义就不适用于该数系。这是因为序列中的某些元素将会连续不断地被重新定义。例如，在例2.1.5中，因为 3++ = 0 ，所以 a_0 （至少）存在两种相矛盾的定义， c 或者 f_3(a_3) 。在一个含有多余元素（比如 0.5 ）的数系中，元素 a_{0.5} 将永远不会被定义。\n对于递归定义，我（笔记书写者）的理解是，我们首先固定了 a_0 = c ，然后递归的过程是\n\\begin{aligned}\ra_1 \u0026 := f_0(a_0), \\\\\ra_2 \u0026 := f_1(a_1), \\\\\ra_3 \u0026 := f_2(a_2), \\\\\r\\text{也就是 } a_3 \u0026 := f_2(f_1(f_0(a_0))).\r\\end{aligned}\r所以它就是固定一个对象，然后通过一系列函数的嵌套运算过程给出另一个对象的唯一赋值，通过对递归定义的重复应用，我们就可以定义出一系列对象，从而组成一个序列。\n一个简单的示例就是泰勒展开：\n我们知道导数的定义是\n\\frac{dy}{dx} = \\lim_{\\Delta x \\to 0} \\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\to 0} \\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x}\r从图像上讲，也就是说在曲线上的两点 (x_0, f(x_0)), (x_0 + \\Delta x, f(x_0 + \\Delta x)) 当横坐标无限靠近时，导数曲线上两点的点成也无限靠近，此时连接两点的直线成为曲线上的切线，两点成为一个切点。在这个切点上，切线与曲线的斜率就是导数的值。\n二阶导数是\n\\frac{d^2y}{dx^2} = \\lim_{\\Delta x \\to 0} \\frac{df(x_0 + \\Delta x) - df(x_0)}{\\Delta x}.\r也就是说对于原函数曲线，一阶导组成的曲线在 (x_0, df(x_0)) , (x_0 + \\Delta x, df(x_0 + \\Delta x)) 切点处的导数， df(x_0) 就是原函数曲线在 x_0 和 x_0 + \\Delta x (\\Delta x \\to 0) 处的导数， df(x_0 + \\Delta x) 就是原函数曲线在 x_0 + \\Delta x 和 x_0 + 2\\Delta x (\\Delta x \\to 0) 处的导数，这在原函数曲线上表现为 f(x_0) \\sim f(x_0 + \\Delta x)(\\Delta x \\to 0) ， f(x_0 + \\Delta x) \\sim f(x_0 + 2\\Delta x)(\\Delta x \\to 0) 。这两段相连的曲线，我们知道因为 \\Delta x \\to 0 所以这两段曲线都缩略了两个点，而二阶导就是对这两点之间曲线段的拟合度的衡量。\n以此类推， x_0 处的三阶导、四阶导实际上就是通过对求导这个操作把原函数曲线在 x_0 的邻域内的曲线段一遍遍的放大，然后用切线来拟合曲线。\n所以泰勒展开\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x - x_0) + \\frac{f''(x_0)}{2!}(x - x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n, \\, R_n(x) = o\\left((x - x_0)^n\\right)\r就是函数 f(x) 在 x_0 处，通过 n 次求导迭代得到的最终拟合的结果。而根据迭代的定义，我们知道这个迭代的拟合的过程中给出的赋值是唯一的，并且我们可以根据迭代次数来构造一个不同次迭代赋值得到的函数值的序列。\n总结 总而言之，以下是皮亚诺公理的全部内容：\n公理假设 皮亚诺公理假设存在一个集合 \\mathbb{N} ，其元素被称为自然数，以及一个称为“后继函数”的映射 S: \\mathbb{N} \\to \\mathbb{N} ，满足以下五条公理：\n五条皮亚诺公理 零是自然数：\n0 \\in \\mathbb{N}. （注：有些表述中将 0 换为 1 ，视具体情况而定。）\n每个自然数都有一个后继：\n\\forall n \\in \\mathbb{N}, S(n) \\in \\mathbb{N}. 后继函数 S 为每个自然数定义一个唯一的“下一个”自然数。\n零不是任何自然数的后继：\n\\forall n \\in \\mathbb{N}, S(n) \\neq 0. 这保证了自然数序列是以 0 为起点、向后无限延伸的，且没有“前驱”。\n不同的自然数有不同的后继（后继函数是单射）：\n\\forall m, n \\in \\mathbb{N}, \\, S(m) = S(n) \\implies m = n. 这保证了后继函数不会将两个不同的自然数映射到同一个自然数。\n数学归纳原理：\n若一个性质 P 满足以下两点：\nP(0) 成立； 对任何 n \\in \\mathbb{N} ，如果 P(n) 成立，则 P(S(n)) 也成立， 则 P(n) 对所有 n \\in \\mathbb{N} 成立。\n数学归纳原理确保可以对自然数集合进行递归定义和归纳证明。\n解释与扩展 皮亚诺公理定义了自然数的基本结构，其中 S 通常被解释为“加 1”操作。例如：\nS(0) 通常表示 1 ， S(S(0)) 表示 2 ，以此类推。 递归定义 通过皮亚诺公理可以递归定义自然数的加法和乘法等运算：\n加法定义：\nn + 0 = n, \\quad n + S(m) = S(n + m). 乘法定义：\nn \\cdot 0 = 0, \\quad n \\cdot S(m) = (n \\cdot m) + n. 数学基础中的地位 皮亚诺公理在数学基础中占有重要地位，为数理逻辑、集合论以及模型论等领域提供了形式化的支柱。\n","cover":null,"tags":["数学分析"],"title":"2.1 皮亚诺公理","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/1.1/"},{"content":"层叠样式表（Cascading Style Sheets，CSS）是一种强大的编程语言，可用于改变文档或文档集合的呈现方式，它几乎已经渗透到网络的每个角落以及许多表面上非网络的环境中。例如，嵌入式设备的显示通常使用 CSS 来设计其用户界面，许多 RSS 客户端允许你对订阅源和订阅条目应用 CSS，一些即时消息客户端使用 CSS 来格式化聊天窗口。CSS 的某些方面甚至可以在 JavaScript (JS) 框架的语法中以及 JS 本身中找到。它无处不在！\nCSS 最早在 1994 年被提出，当时正值互联网开始真正流行之际。当时，浏览器赋予用户大量的样式控制能力——例如，NCSA Mosaic 的显示偏好允许用户定义每种元素的字体系列、大小和颜色。而文档作者却没有任何这样的能力；他们只能将内容标记为段落、某一级别的标题、预格式化文本或其他十几种元素类型之一。如果用户将其浏览器配置为使所有一级标题变得又小又粉红，而所有六级标题变得又大又红，那完全是用户自己的选择。\nCSS 正是在这种环境中被引入的。其目标是为网页作者提供一种简单的声明式样式语言，既灵活又强大，最重要的是，能够同时为作者和用户提供样式控制能力。通过层叠机制，这些样式可以被组合和优先排序，使网站作者和读者都能表达自己的需求——尽管最终的决定权始终在读者手中。\n工作迅速推进，到 1996 年底，CSS1 已经完成。尽管新成立的 CSS 工作组继续推进 CSS2 的开发，但浏览器在以互操作性方式实现 CSS1 时遇到了困难。尽管 CSS 的每个部分本身都相对简单，但它们的组合却产生了一些令人意想不到的复杂行为。不幸的是，还出现了一些问题，比如臭名昭著的盒模型实现差异。这些问题一度威胁到 CSS 的发展，但幸运的是，一些巧妙的提议被实施，浏览器开始趋于一致。在接下来的几年里，随着互操作性的增强以及像《Wired》杂志基于 CSS 的重新设计和 CSS Zen Garden 等高调发展项目的推动，CSS 开始流行起来。\n在这一切发生之前，CSS 工作组于 1998 年初完成了 CSS2 规范。CSS2 甫一完成，随即开始了 CSS3 的开发以及一个经过澄清的版本 CSS2.1 的工作。与当时的潮流一致，最初称为 CSS3 的规范被设计为一系列（理论上）独立的模块，而不是一个庞大的整体规范。这种方法反映了当时活跃的 XHTML 规范，它也因类似的原因被分解为模块。\n对 CSS 进行模块化的理由是，每个模块可以按照自己的节奏进行开发，特别是重要或流行的模块可以沿着万维网联盟（W3C）的进展路径快速推进，而不会被其他模块拖延。事实上，这种方式确实奏效了。截至 2012 年初，已有三个 CSS Level 3 模块（以及 CSS1 和 CSS 2.1）达到了完整的推荐标准——CSS Color Level 3、CSS Namespaces 和 Selectors Level 3。同时，有七个模块达到了候选推荐（Candidate Recommendation）状态，还有数十个模块处于各种工作草案阶段。如果按照旧的方法，颜色、选择器和命名空间模块必须等到规范的所有其他部分完成或被舍弃之后，才能成为完成的规范的一部分。多亏了模块化设计，它们无需等待。\n因此，虽然我们无法指着一本完整的文档说“这就是 CSS”，但我们可以根据模块名称来讨论特性，因为这些特性是通过模块引入的。模块带来的灵活性远远弥补了它们有时造成的语义上的尴尬。（如果你想要接近单一整体规范的内容，CSS 工作组每年都会发布“Snapshot”文档。）\n有了这些背景知识，我们就可以开始理解 CSS 了。让我们从样式表的基本内容开始讲起。\n","cover":null,"tags":["前端开发"],"title":"1.1 (web)style 简史","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.1/"},{"content":"在样式表（stylesheet）中，你会发现它们的规则看起来是这样的：\n1 2 3 4 5 6 7 8 /* 示例代码，仅用于展示 */ .example h1 { color: maroon; /* 改变一级标题颜色 */ } .example body { background: yellow; /* 设置背景颜色 */ } 诸如此类的样式共同构成了样式表的主体。\n规则的结构 为了更详细的说明规则的概念，让我们分解下代码的结构。\n每条规则由两个基本部分组成：选择器（selector）和声明块（declaration block）。声明块包含一个或多个声明（declaration），而每个声明由一个属性（property）和一个值（value）组成。每个样式表都是由这样的一系列规则构成的。图 1-1 展示了规则的各个部分。 选择器位于规则的左侧，用于定义文档中哪些部分将被选中进行样式应用。在图 1-1 中，选择器为 \u0026lt;h1\u0026gt;，表示选择所有一级标题（heading level 1）元素。如果选择器是 p，那么所有段落（\u0026lt;p\u0026gt;）元素将被选中。\n规则的右侧是声明块，由一个或多个声明组成。每个声明由一个 CSS 属性和该属性的值组成。在图 1-1 中，声明块包含两个声明。第一个声明指定规则会将文档的某些部分设置为红色文本，第二个声明指定文档的某些部分将有一个黄色背景。因此，文档中的所有 \u0026lt;h1\u0026gt; 元素（由选择器定义）将被设置为红色文本，并带有黄色背景。\n供应商前缀（Vendor Prefixing） 有时，您会看到 CSS 的某些部分带有连字符和标签，例如：-o-border-image。这些供应商前缀是浏览器供应商用来标记某些属性、值或其他 CSS 部分为实验性或专有功能（或者两者兼有）的一种方式。截至 2023 年初，仍有一些供应商前缀在使用，其中最常见的如表 1-1 所示。 如表1-1所示，供应商前缀的通用格式通常是连字符、标签和连字符，尽管有几个前缀错误地省略了第一个连字符。\n供应商前缀的使用与滥用历史悠久、复杂且超出了本书的范围。简单来说，它们最初的目的是为浏览器供应商提供测试新功能的方式，从而加速互操作性的发展，同时避免被与其他浏览器不兼容的遗留行为所束缚。这避免了一类几乎在 CSS 初期扼杀其发展的问题。然而，不幸的是，这些带前缀的属性随后被网页作者广泛使用，最终导致了全新的一类问题。\n截至 2023 年初，带有供应商前缀的 CSS 功能几乎已经不存在，旧的前缀属性和值正被浏览器实现逐步且稳定地移除。您可能永远不需要编写带前缀的 CSS，但可能会在实际项目中遇到，或者从遗留代码库中继承以下类似的代码：\n/* 示例代码，演示供应商前缀 */\r.example {\r-webkit-transform: rotate(45deg); /* WebKit 内核浏览器 */\r-moz-transform: rotate(45deg); /* Gecko 内核浏览器 */\r-ms-transform: rotate(45deg); /* Trident 内核浏览器 */\r-o-transform: rotate(45deg); /* 旧版 Opera 浏览器 */\rtransform: rotate(45deg); /* 标准 CSS 写法 */\r} 这段代码实际上表达了同样的内容四次：分别为 WebKit（如 Safari、Chrome）、Gecko（如 Firefox）和 Opera 浏览器的前缀版本，最后是符合 CSS 标准的写法。再次强调，这种写法已经不再必要。我们在此仅包含它是为了让您对其可能的外观有一个概念，以备将来遇到类似情况时能够识别。\n空白符处理 CSS 基本上对规则之间的空白符不敏感，对规则内部的空白符也不太敏感，尽管存在一些例外情况。\n通常，CSS 处理空白字符的方式与 HTML 相同：任何连续的空白字符序列都会在解析时折叠为一个空格。因此，你可以以下列方式格式化这个假设的彩虹规则：\nrainbow: infrared red orange yellow green blue indigo violet ultraviolet;\nrainbow:\rinfrared\rred\rorange\ryellow\rgreen\rblue\rindigo\rviolet\rultraviolet\r; 以及你能想到的任何其他分隔模式。唯一的限制是分隔字符必须是空白字符：空格、制表符或换行符，单独使用或组合使用，数量不限。\n类似地，你可以以任何喜欢的方式用空格格式化一系列规则。以下这些都是这只是无数可能性中的五个例子：\n/* 示例代码，演示空白符处理 */\r/* 示例样式仅应用于 .example 类范围 */\r.example html {color: black;} /* 黑色文字 */\r.example body {background: white;} /* 白色背景 */\r.example p {color: gray;} /* 灰色段落文字 */\r.example h2 {color: silver;} /* 银色标题 */\r.example ol {\rcolor: silver; /* 银色有序列表 */\r} 正如你从第一条规则中看到的，空白字符在很大程度上可以省略。实际上，这通常是压缩 CSS 的情况，压缩 CSS 是指移除了所有多余空白字符的 CSS，通常由某种自动化的服务器端脚本完成。第一条规则之后的规则逐步使用了更多的空白字符，直到最后一条规则，几乎每个可以分开到单独一行的部分都被分开了。\n所有这些方法都是有效的，所以您应该选择最有意义的格式——也就是最容易读懂的格式，并坚持使用它。\nCSS 中的注释 CSS允许注释。这些注释与 C/C++ 注释非常相似，它们被/* 和 */包围：\n/* This is a CSS comment */\n注释可以跨越多行，就像 C++ 一样。\n/* This is a CSS comment, and it can be several lines long without any problem whatsoever. */\n重要的是要记住，CSS 注释不能嵌套。例如，这是不正确的：\n/* This is a comment, in which we find\ranother comment, which is WRONG\r/* Another comment */\rand back to the first comment, which is not a comment.*/ 一种意外创建“嵌套”注释的情况是暂时注释掉包含注释的大块样式表。由于 CSS 不允许嵌套注释，“外层”注释会在“内层”注释结束的地方结束。\n不幸的是，CSS 中没有像 // 或 # 这样的“单行注释”模式（其中 # 已经被保留用于 ID 选择器）。CSS 中唯一的注释模式是 /* */。因此，如果您希望在与标记相同行中添加注释，需要注意放置的方式。例如，这是正确的做法：\n/* 示例代码，演示 CSS 单行注释的正确用法 */\r.example h1 {color: gray;} /* 一级标题为灰色 */\r.example h2 {color: silver;} /* 二级标题为银色 */\r.example p {color: white;} /* 段落文字为白色 */\r.example pre {color: gray;} /* 预格式化文字为灰色 */ 以下示例中，因为有四行注释都没有正确标注，大部分样式表将成为注释的一部分，因此将无法生效：\n.example h1 {color: gray;} /* This CSS comment is several lines\r.example h2 {color: silver;} long, but since it is not wrapped\r.example p {color: white;} in comment markers, the last three\r.example pre {color: gray;} styles are part of the comment. */ 在此示例中，只有第一条规则（h1 {color: gray;}）会应用到文档中。其余规则作为注释的一部分，被浏览器的渲染引擎忽略。\nCSS 注释被 CSS 解析器视为完全不存在，因此在解析时不算作空白字符。这意味着我们可以将它们放在规则的中间，甚至直接插入到声明中！\n标记（Markup） 样式表中没有标记（markup）。唯一的例外是 HTML 注释标记，由于历史原因，它被允许出现在 \u0026lt;style\u0026gt; 元素中：\n\u0026lt;!-- 示例代码，用于展示历史标记 --\u0026gt;\r\u0026lt;style\u0026gt;\r/* 这种写法仅为历史兼容性展示 */\r.example h1 {color: maroon;} /* 一级标题为栗色 */\r.example body {background: yellow;} /* 背景为黄色 */\r\u0026lt;/style\u0026gt; 就像这样，不过即使是以上这样的代码也不再被推荐；需要它的浏览器已经几乎被遗忘了。\n说到标记，现在是时候稍微绕一下弯路来讨论 CSS 将用于设置样式的元素，以及 CSS 如何以最基本的方式影响这些元素。\n特别提示：在 Markdown 文档中嵌入示例代码块时，请注意添加诸如 .example 这类的名称来规避代码块对页面的影响。例如，如果我们在本文的第一个示例中忽略 .example 而直接书写 p 等选择器时，由于恰好示例代码是 css 代码，且示例代码恰好是全局选择器，因此我们新添加的属性值就会更改原来的页面样式。\n","cover":null,"tags":["前端开发"],"title":"1.2 样式表内容","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.2/"},{"content":"使用简单的文本编辑器，输入前面的任一示例并以文件名保存，如 helloworld.html 或 helloworld.htm；你可以选择使用 .htm 或 .html 文件扩展名，但无论你选择哪个进行开发，都要保持一致。这本书的所有文件都使用 .html。\n将示例文件保存到本地文件系统后，在 Web 浏览器中打开它，方法是打开文件菜单，然后根据你的浏览器选择打开、打开页面或打开文件： 一旦您的浏览器读取了该文件，它就应该呈现如下所示的页面： 如果由于某种原因没有使用适当的扩展名保存文件，则浏览器不会尝试解释 HTML 标记。例如，请注意当你尝试以 .txt 扩展名打开内容时: 如果要对文档进行更改，可以更新标记，保存文件，返回浏览器，然后单击重新加载或刷新按钮。有时，浏览器仍会从其缓存中重新加载页面；如果页面在重新加载时没有正确更新，请在按住 Shift 键的同时单击重新加载按钮，浏览器应该会刷新该页面。\n在编写标记时，保持浏览器和编辑器同时打开是一个非常好的主意，以避免不断地重新打开其中之一。许多 Web 编辑器将帮助您将 Web 页面加载到各种浏览器中，甚至直接预览标记的可视化。图1-1显示了 Adobe 广受欢迎的 Dreamweaver 程序[]。 ","cover":null,"tags":["前端开发"],"title":"1.3 Viewing Markup Locally","url":"/notes/computer-science-and-technology/front-end-development/css-the-definitive-guide/1.3/"},{"content":"在学习线性代数之前，我们有必要将数学中有关真假判定等逻辑问题解答的基础性知识规范一下。值得一提的是，冯琦老师的专业方向就是数理逻辑和公理化集合论，冯琦老师所著《数理逻辑导引》和《集合论导引》都是相关领域的不可多得的高质量推荐教材，有兴趣的读者可能自行找书学习。\n1.1.1 语句真假判定 在数学中，我们总会关注语句的真假，由于数学中的语句都是按照一种确定的规范由简至繁逐渐成形，因而对所关注的语句的真假判定就完全按照其构成方式被规范的归结到对一系列基本事实的真假判定。下面我们就来介绍一下语句的构成规范和真假判定归结规范。\n数学中的语句按照分支被分为各自分支中的基本语句和复合语句。\n具体到线性代数这一分支，比较典型的基本语句就是由加法运算和乘法运算所确定的等式。比如 5\\cdot7+2\\cdot3=41 就是一个基本语句。如果还涉及到线性序，例如用 \u003c 来表征小于的线性序关系，那么 1+2\u003c2+3 、 5\\cdot2\u003c5\\cdot3 就都是基础语句。\n复合语句则是将一系列的基本语句经过一系列的逻辑联结词关联起来之后所得，例如\n\\begin{array}{l}\r((5 \\cdot 2\u003c3 \\cdot 2) \\rightarrow(0=1)) \\\\\r((5 \\cdot 2\u003c3 \\cdot 2) \\leftrightarrow(0=1)) \\\\\r((5 \\cdot 2\u003c3 \\cdot 2) \\vee(\\neg(0=1))) \\\\\r((5 \\cdot 2\u003c3 \\cdot 2) \\wedge(\\neg(0=1)))\r\\end{array}\r就都是复合语句。从上面的复合语句中我们可以看到所涉及到的逻辑关联词一共有五个：\n\\neg(非),\\rightarrow(蕴含),\\leftrightarrow(对等),\\vee(或),\\wedge(且) 其中，\n1.符号\u0026quot; \\neg \u0026quot;用以表示“否定”：在一个命题之前加上这样的否定词，就得到原命题的否定，这也就是自然语言所用的“并非如何如何”\n2.符号\u0026quot; \\rightarrow \u0026quot;用以表征“蕴含”：蕴含关联词将作为前提的命题和作为结论的命题关联起来。也就是自然语言的“如果，那么”\n3.符号\u0026quot; \\leftrightarrow \u0026quot;用以表征“对等”：对等关联词将两个命题以逻辑等价的方式联结起来。也就是两个命题互为充要条件，也可以说是当且仅当的意思\n4.符号\u0026quot; \\vee \u0026quot;用以表征“析取”“或者”：析取词将两个命题以“至少其中之一”这样的选择析取方式关联起来。也就是自然语言中的“要么，要么”\n5.符号\u0026quot; \\wedge \u0026quot;用以表征“合取”“并且”：合取词将两个命题以“两者都成立”的方式联结起来。也就是自然语言中的“不仅，而且”\n基本语句的真假判定 在判断基本语句的真假之前，我们首先要明确被判定真假的基本语句是关于哪个线性代数学对象的断言。同一个基本语句，在不同的线性代数学对象之中计算出来的结果可以不同。以下述两个基本语句为例：\n\\begin{array}{l}\r5\\cdot7+2\\cdot3=41\\\\\r5\\cdot3=11\r\\end{array}\r在自然数范围内，或者在整数范围内，第一个基本语句为真，第二个为假。但如果是在只有两个元素的域 \\{0,1\\} 上，第二个语句就是真的。因而在线性代数学里，关于语句的真假判定都是在相对于给定的具体的线性代数模型之中实现的。真，是相当于具体对象为真；假，是相对于具体对象为假。 在一个固定的线性代数对象中，一个给定的基本等式的两边事实上就给出了在这个对象（模型）之中分别计算出两个值的计算过程。若在给定的具体线性代数对象中按照等式两边所描述的计算结果来看，两边结果一致，则认为所给等式为真；否则，所给等式就为假。\n复合语句真假判定归结过程 复合语句的真假判定依赖于复合语句的布尔值计算规则。\n同基本语句的真假判定一样，复合语句的真假判定也需要在相应的具体的线性代数对象中讨论，其真假是相对于具体的线性代数对象而言的。下面的真值计算表可以看作是系统递归地归结的计算方法。\n我们约定用 1 来表示真，用 0 来表示假。并且 1\\ne 0 。复合语句的真假赋值必须遵从以下五条计算等式规则：\n1.否定词计算规则：‘并非’\n如果 A 是一个已经被赋值了的较低层次的逻辑命题，那么对于 A 的否定式 (\\neg A) 的赋值必须满足下述背反等式的要求：\n对 (\\neg A) 赋值为 1 的充要条件是对 A 的赋值为 0 ,对 (\\neg A) 赋值为 0 的充要条件是对 A 的赋值为 1 2.蕴含词计算规则：‘如果，那么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的蕴含式 (A\\rightarrow B) 的真值赋值必须满足下述蕴含等式要求：对 (A\\rightarrow B) 的赋值为 0 的充分必要条件是 “(对 A 赋值为 1 ，对 B 赋值为 0 )”。 在蕴含赋值计算表中，我们将蕴含式 (A \\to B) 放于最右侧是因为， (A \\to B) 命题的层级比 A 和 B 都高，对于 (A \\to B) 的真值的赋值依赖于对 A 和 B 的真值的赋值。根据赋值表我们可以知道“假可以蕴含假，假可以蕴含真，真不能蕴含假，真可以蕴含真”。\n3.析取词计算规则：‘要么，要么’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的析取式 (A \\lor B) 的赋值必须满足下述析取等式要求：对 (A \\lor B) 的赋值为 1 的充分必要条件是 “（或对 A 的赋值为 1 ，或对 B 的赋值为 1 ）”，对 (A \\lor B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，并且对 B 的赋值也为 0 ）”。\n4.合取词计算规则：‘不仅，而且’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么他们的合取式 (A \\land B) 的赋值必须满足以下合取等式要求：对 (A \\land B) 的赋值为 1 的充分必要条件是 “（对 A 的赋值为 1 ，并且对 B 的赋值也为 1 ）”，对 (A \\land B) 的赋值为 0 的充分必要条件是 “（或对 A 的赋值为 0 ，或对 B 的赋值为 0 ）”。\n5.对等词计算规则：‘当且仅当’\n如果 A 和 B 是已经被赋值了的较低层级的逻辑命题，那么它们的对等式 (A \\leftrightarrow B) 的赋值必须满足以下对等等式要求：对 (A \\leftrightarrow B) 赋值为 1 的充分必要条件是 “（对 A 和对 B 的赋值是相等的）”，对 (A \\leftrightarrow B) 赋值为 0 的充分必要条件是 “（对 A 和对 B 的赋值是不相等的）”。\n从上面的逻辑真值计算规则，我们可以注意到下面的基本逻辑规律：（所述等价，即是说它们有相同的真值表）\n\\begin{array}{l}\r1. \\, A \\, \\text{与} \\, (\\neg(\\neg A)) \\, \\text{等价} \\\\\r2. \\, (A \\to B) \\, \\text{与} \\, ((\\neg B) \\to (\\neg A)) \\, \\text{等价} \\\\\r3. \\, (A \\lor B) \\, \\text{与} \\, (B \\lor A) \\, \\text{等价} \\\\\r4. \\, (A \\land B) \\, \\text{与} \\, (B \\land A) \\, \\text{等价} \\\\\r5. \\, (A \\leftrightarrow B) \\, \\text{与} \\, (B \\leftrightarrow A) \\, \\text{等价}\r\\end{array}\r另外两条规律也值得注意：\n\\begin{array}{l}\r6. \\, \\text{如果} \\, (A \\to B) \\, \\text{并且} \\, (B \\to C), \\, \\text{则} \\, (A \\to C) \\\\\r7. \\, \\text{如果} \\, (A \\leftrightarrow B) \\, \\text{并且} \\, (B \\leftrightarrow C), \\, \\text{则} \\, (A \\leftrightarrow C)\r\\end{array}\r在数学逻辑中，我们实际上可以只要一条基本的推导规则：由 A 和 (A \\to B) 导出 B 来。这是数学推演中默认的推理法则，这在许多的推理中都有广泛应用，比如在数学归纳法证明定理时就有明显的运用。\n另外还需要注意，人们时常使用 \\Leftarrow 代替 \\leftarrow ， \\Rightarrow 代替 \\rightarrow ， \\Leftrightarrow 代替 \\leftrightarrow 。\n1.1.2 表达式及其语义解释 基本表达式及其语义解释 一般而言，在现代数学中，使用变量来抽象的表达一般性已经是一种最为基础的行为。人们不再关心具体的量之间的等价关系，取而代之的是对于等式所揭示的一般的普遍性的密切关注。\n比如，你想要表达自然数加法运算具有可交换性和可结合性，最自然的方法就是使用类似下面的有两个变量或三个变量的等式：\nx+(y+z)=(x+y)+z\\\\ 当变量引入，人们可以方便的表达关于所研究的对象的种种的一般性质。\n前面我们论证过，任何具体的量之间的等式都是基本语句。因而也就可以通过等式两边经过的具体的运算所得到的结果的比对来判断等式成立与否。可是诸如， x+y=y+x 这样的等式是否也具有真假判定问题呢？或者说，这个等式在什么时候表达了一种真相，什么时候表达了一种假象?\n在展开讨论之前，有一点需要明确，即，当我们使用一个表达式来表达一种性质的时候，如果表达式存在变量，我们必须明确当前关注对象的具体范围，也就是变量变化的范围，我们将这个范围称为论域。后面，我们将看到许多论域的例子，因为具体的论域、论域之上的加法、乘法运算所组成的结构就是线性代数的基本对象。\n因为我们关注的是线性代数学，因而我们不妨以给定论域上的加法、乘法运算为例来解释这样的表达式的真假判定问题。\n第一，我们首先规定：任何一个被用来标识特殊个体对象的常量（符号），比如\n1，2，3\\cdots2024\\cdots\\\\ 为一个项。\n任何一个被用来表示任意个体的变量（符号），比如\nx,y,z,A,B,C\\cdots \\\\ 也是一个项。\n然后，由任意两个已有的项 t_1 和 t_2 经过加法、乘法运算就可以得到新的项\nt_1+t_2,t_1\\cdot t_2 \\\\ 最后，只有从常量或者变量出发，经过有限次加法、乘法迭代方可得到一个项。比如\n\\begin{array}{l}\ra_1x_1+a_2x_2+\\cdots+a_nx_n\\\\\rx^m+b_1x^m+\\cdots+b_{m-1}x_1\r\\end{array}\r就是两个项。\n第二，我们规定，任何一个基本表达式无非就是由两个项所组成的一个等式，比如\n\\begin{array}{l}\ra_1x_1+a_2x_2+\\cdots a_nx_n=1,\\\\\rx_m+\\cdots+b_m=0\\\\\r\\end{array}\r如果我们还关心诸如实数的线性序（例如 \u003c 就是被用来表达线性序的符号），那么任何一个涉及线性序的基本表达式就是由两个项所组成的不等式。比如\n\\begin{array}{l}\ra_1x_1+\\cdots+a_nx_n\u003c0,\\\\\rb_1m_1+\\cdots+b_2m_2\u003ex_1+\\cdots+x_n\\\\\r\\end{array}\r不妨假设我们需要涉及大小的比较，因而我们有必要使用线性序的关系。这样一来，我们就有两种基本表达式：项之间的等式、项之间的不等式。以上两种基本表达式我们就分别称之为基本等式和基本不等式。\n第三，我们固定一个线性代数学的具体对象。比如：实数与实数的加法、乘法运算，以及它们的线性序关系。这样一来，每个项就是关于实数的一个对象，或者关于实数的一种计算过程。任何一个基本等式也是关于实数的等式，同理不等式就是关于实数的不等式。\n第四，在前述的基础上，我们来解决基本表达式的真假判定问题。\n给定一个基本表达式，令 t_1(x_1, \\cdots, x_n) 、 t_2(x_1, \\cdots, x_n) 为所涉及的两个项，并且约定，无论是 t_1 还是 t_2 ，在项中出现的所有自变量都出自变量 x_1, \\cdots, x_n 中。那么这 n 个变量就可以彼此独立地在实数范围内取任何值。\n我们规定任何一个实数的 n -元组 (a_1, \\cdots, a_n) 就是上述 n 个变量的一组取值。我们称 (a_1, \\cdots, a_n) 为 x_1, \\cdots, x_n 的一组赋值或者解释。\n并且，我们规定，记号 t_1(a_1, \\cdots, a_2) 和 t_2(a_1, \\cdots, a_2) 分别用来标识由计算过程 t_i (i=1, 2) 以数据 (a_1, \\cdots, a_n) 为输入所计算出来的结果，并且称 t_i 在数据 (a_1, \\cdots, a_n) 处的赋值或者解释。\n在此基础上，我们称数值等式\n\\begin{array}{l}\rt_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2)\r\\end{array}\r为基本等式 t_1 = t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n类似的我们称数值不等式\n\\begin{array}{l}\rt_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2)\r\\end{array}\r为基本不等式 t_1 \u003c t_2 在数据 (a_1, \\cdots, a_n) 处的语义解释。\n现在，我们就规定：\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值等式 \\begin{array}{l}\rt_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2)\r\\end{array}\r的确成立。\n基本等式 t_1 = t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值等式 \\begin{array}{l}\rt_1(a_1, \\cdots, a_2) = t_2(a_1, \\cdots, a_2)\r\\end{array}\r的确不成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为真，当且仅当数值不等式 \\begin{array}{l}\rt_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2)\r\\end{array}\r的确成立。\n基本不等式 t_1 \u003c t_2 相对于数据 (a_1, \\cdots, a_n) 为假，当且仅当数值不等式 \\begin{array}{l}\rt_1(a_1, \\cdots, a_2) \u003c t_2(a_1, \\cdots, a_2)\r\\end{array}\r的确不成立。\n量词与表达式 前面我们看到对于基本表达式而言，它们在不同的输入数据处可能表现出不同的真假状态；也有的对输入数据表现得毫无差别，那么，这样的现象又怎样在表达式中被合适的表达出来？这就涉及到当代数学在逻辑学领域的一大里程碑式的突破——在数学中引入量词。\n既然有变量，就有量词。这是将含有自由变量的表达式转换成没有二义性的语句的需要。\n比如说考虑基本等式 x = y 和基本不等式 x \u003c y ，我们知道，它们有的时候为真，有的时候为假，取决于所给定的输入数据。也就是说，存在一组使其为真的数据，也存在使其为假的数据。\n我们将“存在”这个词作为一种量词引入数学，并且用符号 \\exists 来表征“存在”：\n\\begin{array}{l}\r(\\exists x (\\exists y (x = y))), \\\\\r(\\exists x (\\exists y (x \u003c y)))\r\\end{array}\r其中 \\exists x, \\exists y 就都被称为一个存在量词。一个存在量词由符号 \\exists 与一个紧随其右的变元符号组成。并且规定紧跟在存在量词右边一定有一对括号 () 将这个存在量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n又比如，考虑基本等式 x + y = y + x 和基本不等式 0 \u003c (x + y)^2 。我们知道它们的真假状态与它们的输入数据无关。也就是说，对于所有数据，这些表达式都为真。\n我们将“对于所有”这个短语作为一个量词引入，并且用符号 \\forall 来表征这个短语：\n\\begin{array}{l}\r(\\forall x (\\forall y (x + y = y + x)))\r\\end{array}\r其中， \\forall x, \\forall y 就都被称为一个全称量词。一个全称量词由符号 \\forall 和紧跟其右的变量组成，并且规定紧跟在全称量词右边一定有一对括号 () 将这个全称量词的作用范围确定下来，在这个作用范围内，存在量词所涉及的变量被认为是“受约束变量”。\n在引进量词的基础上，我们基本上就可以确定线性代数学所关注的表达式一般都是什么模样了仍然假设我们关注的有加法、乘法和大小比较。\n第一，每一个基本表达式都是一个表达式：\n\\begin{array}{l}\r(t_1 = t_2), \\quad (t_1 \u003c t_2) \\quad (\\text{为了规范起见，我们加上圆括号})\r\\end{array}\r第二，假设已经得到一个表达式，比如说这个表达式被记作 \\varphi ，那么这个表达式的否定式 (\\neg \\varphi) 也是一个表达式。\n第三，假设已经得到两个表达式，比如说它们被记为 \\varphi 和 \\psi ，那么\n(1) (\\varphi \\lor \\psi) 是一个表达式\n(2) (\\varphi \\land \\psi) 是一个表达式\n(3) (\\varphi \\to \\psi) 是一个表达式\n第四，假设已经得到一个表达式 \\varphi ， x 是一个变量符号，那么\n(1) (\\exists x \\varphi) 是一个表达式\n(2) (\\forall x \\varphi) 是一个表达式\n最后，除了以上的规定，没有获得新的表达式的可能途径。\n关于两个量词的否定，我们规定\n\\begin{array}{l}\r(\\neg (\\forall x \\varphi)) \\text{ 即为 } (\\exists x (\\neg \\varphi))\r\\end{array}\r以及\n\\begin{array}{l}\r(\\neg (\\exists x \\varphi)) \\text{ 即为 } (\\forall x (\\neg \\varphi))\r\\end{array}\r自由变元与约束变元 关于表达式，有一点非常重要，就是区分表达式种出现的变量是受约束出现还是自由出现。因为这是对表达式赋予语义内涵的关键。给定一个表达式 \\varphi 和一个变量符号 x ，假设这个 x 在表达式中出现若干次。\n如果 x 在某一处的出现不在任何存在量词或全称量词的作用范围内，就称 x 为 \\varphi 的一个自由变量。反之，则被称为约束变量。\n在涉及变量和量词的表达式中，那些没有自由变量的表达式被称为语句。比如\n\\begin{array}{l}\r(\\forall x (\\forall y (x + y = y + x)))\r\\end{array}\r就是一个语句。\n在应用中，我们常常会使用形如下述的受囿量词：\n\\begin{array}{l}\r\\forall x \\in A, \\quad \\exists x \\in A\r\\end{array}\r这样书写的根本理由就是我们将变量的变化范围限定在一个局限范围 A 之中，并且通常 A 就是当前所关注的论域，或者论域的一个子集。需要注意的是，这些并非新的量词，更多的是为了强调变量变化的范围。比如\n\\begin{array}{l}\r(\\forall x \\in A \\varphi(x))\r\\end{array}\r这个表达式实际上是\n\\begin{array}{l}\r\\forall x ((x \\in A) \\to \\varphi(x))\r\\end{array}\r同样的\n\\begin{array}{l}\r(\\exists x \\in A \\varphi(x)) \\iff \\exists x ((x \\in A) \\land \\varphi(x))\r\\end{array}\r更多的时候，当我们固定在一个论域上讨论问题时，使用不受局限的量词与使用受限于论域之内的受限量词实际上是同一回事。\n表达式语义解释与真假判定 仍然以实数加法、乘法和实数的大小比较为我们当前关注的线性代数学的一个对象，我们来解释表达式的语义和真假判定内涵。\n我们现在设 \\varphi(x_1, x_2, \\cdots, x_n) 是一个表达式，并且 \\varphi 中出现的任何的自由变元都来自 (x_1, x_2, \\cdots, x_n) 中，设 (a_1, a_2, \\cdots, a_n) 是实数的一个 n 元组。我们将 \\varphi 中出现的自由变元 x_i 进行赋值，使得自由变元 x_i 被相应的赋值为 a_i ，这时 \\varphi[a_1, a_2, \\cdots, a_n] 就是对 (a_1, a_2, \\cdots, a_n) 的性质描述，其中没有任何的需要特定赋值的自由变元。\n我们将根据表达式 \\varphi(x_1, x_2, \\cdots, x_n) 构造中可能存在的结构来规定如何判定\n\\varphi[a_1, a_2, \\cdots, a_n] 的真假。\n(1) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是一个基本表达式，那么 \\varphi[a_1, a_2, \\cdots, a_n] 的真假已经在前文被确定好了。\n(2) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是表达式 \\phi(x_1, x_2, \\cdots, x_n) 的否定式，即 \\varphi = (\\neg \\phi) 并且 \\phi[a_1, a_2, \\cdots, a_n] 的真假已经被确定，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为假\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假当且仅当 \\phi[a_1, a_2, \\cdots, a_n] 为真\n(3) 如果 \\varphi(x_1, x_2, \\cdots, x_n) 是由两个表达式 \\psi_1(x_1, x_2, \\cdots, x_n) 和 \\psi_2(x_1, x_2, \\cdots, x_n) 通过联结词 \\lor 联结而成，即 \\varphi = (\\psi_1 \\lor \\psi_2) ，并且 \\psi_1[a_1, a_2, \\cdots, a_n] 和 \\psi_2[a_1, a_2, \\cdots, a_n] 的真假已经确定，那么\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(4) 把上述推导的联结词换成 \\land ，那么 (a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，并且 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(5) 如果 \\varphi = (\\psi_1 \\to \\psi_2) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为假，或者 \\psi_2[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当 \\psi_1[a_1, a_2, \\cdots, a_n] 为真，但是 \\psi_2[a_1, a_2, \\cdots, a_n] 为假\n(6) 如果 \\varphi = (\\forall y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为假\n(7) 如果 \\varphi = (\\exists y \\psi) ，则\n(a) \\varphi[a_1, a_2, \\cdots, a_n] 为真，当且仅当存在一个实数 a 使得 \\psi[a_1, a_2, \\cdots, a_n] 为真\n(b) \\varphi[a_1, a_2, \\cdots, a_n] 为假，当且仅当对每一个实数 a 都有 \\psi[a_1, a_2, \\cdots, a_n] 为假\n当一个表达式在一组数据 (a_1, \\cdots, a_n) 下为真时，我们说这组数据满足表达式。反之则不满足。\n比如，下面这三句话在任何地方都是真语句，只要涉及到等号，下面三个语句就都为真。\n\\begin{array}{l}\r(\\forall x (x = x)) \\\\\r(\\forall x (\\forall y ((x = y) \\to (y = x)))) \\\\\r(\\forall x (\\forall y (\\forall z (((x = y) \\land (y = z)) \\to (x = z)))))\r\\end{array}\r这三句话称为基本等号律，也称同一律。\n","cover":null,"tags":["代数学"],"title":"1.1  逻辑基础","url":"/notes/math/%E4%BB%A3%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AF%BC%E5%BC%95/1.1/"},{"content":"函数和泛函同为映射。”输入/输出“的无穷小变化，对函数而言就是微分，对泛函而言即是变分（variation）。简而言之，泛函是函数到数的映射，函数本身的无穷小变化，以及由此引出的泛函的变化即为变分。\n若函数 f(t) 变成了另一个函数 f(t)\\longrightarrow \\tilde{f(t)} ，且假设两者相差无穷小。则函数 f(t) 的变分 \\delta f 被定义为\n\\delta f(t):=\\tilde{f(t)}-f(t)\\\\ 上式中的变分符号\u0026quot; \\delta \u0026quot;代表变分运算这种操作。即对函数本身进行无穷小的变化。变分运算的结果，亦即上式的右侧仍然是一个函数（只不过是无穷小的），变分 \\delta f 是作为另一个函数存在的。\n函数的变分 \\delta f 和微分 df 同为无穷小变化，但是具有本质上的区别 函数的微分 df(t) 是由自变量 t 的变化引起的，函数本身固定不变\nf(t)\\xrightarrow{t\\rightarrow t+dt}f(t+dt) =f(t)+df(t)+\\cdots\\\\ 而函数的变分 \\delta f(t) 是因为函数本身发生了无穷小变化，而与自变量 t 无关\nf(t)\\rightarrow\\tilde{f(t)}\\equiv(f+\\delta f)(t)=f(t)+\\delta f(t)\\\\ 1.2.2 变分的运算规则 函数的变分其实和微分运算形式相似，比如\n\\delta (f^n)=nf^{n-1}\\delta f\\\\ 对于函数 f_1 和 f_2 以及常数 a,b， 我们有\n\\begin{align}\r\\delta(af_1+bf_2)=a\\delta f_1+b\\delta f_2\\\\ \\delta(f_1f_2)=(\\delta f_1)f_2+f_1(\\delta f_2)\r\\end{align}\\\\\r另一个重要且非常有用的性质是，变分和微分可以交换顺序，即”微分的变分”=“变分的微分“\nd(\\delta f)=\\delta(df)\\\\ 如图，此性质可以被直观证明。考虑 f 的值在 A 点和 B' 点的差，即\n\\tilde{f}(t+dt)-f(t)\\\\ 若先微分后变分(路径 A\\rightarrow B\\rightarrow B' ),精确到一阶小量有\n\\begin{align} C'B长度\u0026=f(t+dt)-f(t)=df(t)\\\\ BB'长度\u0026=\\tilde{f}(t+dt)-f(t+dt)\\\\ \u0026=\\delta(f(t+dt))\\\\ \u0026=\\delta(f(t)+df(t))\\\\ \u0026=\\delta(f(t))+\\delta(d(f(t)) \\end{align}\\\\\r于是，\n\\tilde{f}(t+dt)-f(t)=df(t)+\\delta f(t)+\\delta (df(t))\\\\ 若先变分再微分(路径 A\\rightarrow A'\\rightarrow B ),精确到一阶小量有\n\\begin{align} AA'长度\u0026=\\tilde{f}(t)-f(t) \\\\\u0026=\\delta f(t)\\\\ A'C长度\u0026=\\tilde{f}(t+dt)-\\tilde{f}(t)\\\\ \u0026=d\\tilde{f}(t)\\\\ \u0026=d((f+\\delta f)(t))\\\\ \u0026=df(t)+d(\\delta f(t)) \\end{align}\\\\\r于是，\n\\tilde{f}(t+dt)-f(t)=\\delta f(t)+df(t)+d(\\delta f(t))\\\\ 进而有，\nd(\\delta f)=\\delta(df)\\\\ 上式的直接推论即变分和求导运算也可以交换顺序，即是说\u0026quot;导数的变分\u0026quot;=\u0026ldquo;变分的导数\u0026rdquo;.\n\\frac{d}{dt}(\\delta f(t))=\\delta(\\frac{d}{dt}f(t))\\\\ 这里的关键在于，变分变化的是函数本身，而与自变量无关。\n","cover":null,"tags":["经典力学"],"title":"1.2 变分","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.2/"},{"content":"我们首先来回顾一下函数的概念。\n一个形象的解释是，函数是一个机器，我们把一个数输入到函数中，函数就会按照其描述来给出一个数。换成一个稍微数学的点的说法就是：\n函数是一个具体的映射关系，给定两个集合 X 和 Y ，在两个集合的元素 x\\in X 和 y\\in Y 之间建立的一个对应关系即为映射。\nf:x\\rightarrow y=f(x) \\\\ 1.1.1 泛函的概念 从映射的角度，很多时候普通函数的概念显的不太够用。\n例如，空间（平面、球面等）中两点用任一曲线连接，给定曲线的形状，就可以计算出曲线的长度，又比如，平面上的封闭曲线和空间中的封闭曲面，给定曲线和曲面的形状，就可以计算出所包围的面积和体积。\n上面的例子有个共同的特点，“输入”——曲线的形状、曲面的形状等等，不是一般意义上的数。而”输出“却都是数。由此可见，为了描述并解决这些问题，普通函数的概念需要被推广，需要引入新的数学概念来描述这种”不是数的输入“。\n这些例子还有一个共同的特点，这些输入都可以用”函数“来刻画。\n至此，**\u0026ldquo;泛函\u0026rdquo;**的概念已经呼之欲出了。用数学语言来说，泛函就是函数到数的映射。两个集合之间的映射有很多种，也就是，存在很多的函数 f_1(x),f_2(x),\\cdots,f_n(x) ，所有这些函数自然也构成集合 \\mathcal{F}=\\{f_1,f_2,\\cdots,f_n\\} ,把函数 f 的泛函记为 s[f] ，即\nS:f\\longmapsto S=S[f],\\quad\\mathcal{F}\\longmapsto \\mathcal{C}\\\\ 其中， \\mathcal{C} 代表复数集合。\n泛函既然也是一种映射，那么如果把泛函输入的函数当成是某种”广义的数“，则泛函也可以视为是一种函数。只不过函数是数的函数，泛函是函数的函数。\n1.1.2 泛函的具体形式 根据泛函的定义——输入函数，输出数。我们可以举出很多泛函的例子，比如\n平面上曲线方程记为 y=f(x) ，则两点之间的曲线长度 S 为曲线方程 f(x) 的泛函\nS(曲线长度)=S[f](曲线方程f的泛函)=\\int\\limits_{曲线}dx\\sqrt{1+(f'(x))^2}\\\\ 理想气体准静态过程对外做功 W 即是过程方程 p=p(V) 的泛函\nW=W[p]=\\int\\limits_{过程}p(V)dV\\\\ 三维空间曲线方程记为 z=\\phi(x,y) ，则曲面面积 A 为二元函数 z=\\phi(x,y) 的泛函\nA=A[\\phi]=\\iint_{\\text {区域 }} \\mathrm{d} x \\mathrm{~d} y \\sqrt{1+\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial \\phi}{\\partial y}\\right)^{2}} \\\\ 经典力学中的遇见的泛函，通常为以下形式\nS[f]=\\int_{t_{1}}^{t_{2}} \\mathrm{~d} t L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right)\\\\ 此处的被积函数 L=L\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 是函数 f(t) 及其导数的一般函数。\n可以再次看到，泛函的结果或者说输出 s[f] 是一个数，但是 s[f] 描述的对象是函数的函数，也就是函数所遵循的具体的对应关系，在上式中，它是 f(t) 遵循 \\int\\limits_{t_1}^{t_2} dtL\\left(t, f(t), f^{\\prime}(t), f^{\\prime \\prime}(t), \\cdots\\right) 。\n我们称数 s[f] 是 f 的泛函，其实是\u0026quot; s[f] 所描述的函数的函数是函数 f 的泛函\u0026quot;的简洁说法，因为 s[f] 的结果是数，所以简称数 s[f] 是 f 的泛函。\n","cover":null,"tags":["经典力学"],"title":"1.1 泛函","url":"/notes/physcis/classical-mechanics/%E7%BB%8F%E5%85%B8%E5%8A%9B%E5%AD%A6%E9%AB%98%E6%98%BE/1.1/"},{"content":"1.Markdown 语法 元素 Markdown 语法 标题 (Heading) # H1 ## H2 ### H3 粗体 (Bold) bold text 斜体 (Italic) italicized text 引用块 (Blockquote) \u0026gt; blockquote 有序列表 (Ordered List) 1. First item 2. Second item 3. Third item 无序列表 (Unordered List) - First item - Second item - Third item 代码 (Code) code 分隔线 (Horizontal Rule) \u0026mdash; 链接 (Link) title 一级列表项 1 二级列表项 1.1 三级列表项 1.1.1 二级列表项 1.2 一级列表项 2 元素 Markdown 语法 表格 (Table) | Syntax | Description | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | Header | Title | | Paragraph | Text | 代码块 (Fenced Code Block) \u0026lt;br\u0026gt; { \u0026lt;br\u0026gt; \u0026quot;firstName\u0026quot;: \u0026quot;John\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;lastName\u0026quot;: \u0026quot;Smith\u0026quot;, \u0026lt;br\u0026gt; \u0026quot;age\u0026quot;: 25 \u0026lt;br\u0026gt; } \u0026lt;br\u0026gt; 标题编号 (Heading ID) ### My Great Heading {#custom-id} 定义列表 (Definition List) term : definition 删除线 (Strikethrough) The world is flat. 任务列表 (Task List) - [x] Write the press release - [ ] Update the website - [ ] Contact the media ~ 公理1.1 ~\n公理1.1\n以上内容来自 Markdown 语法官方中文教程\n2.Markdown 语法报错修正 代码块 `` Markdown 代码块中的代码是保存功能而不仅仅只是展示用的，因此，当处于代码块中的代码是关于页面设定的代码，那么，它就会影响网页的生成。\n为了避免这种情况，我们需要采用如下语法来规避影响：\nHTML 标签 在需要显示代码时，可以使用 \u0026lt;code\u0026gt; 或 \u0026lt;pre\u0026gt; 标签来确保代码的正确显示，这些标签不会引起 Markdown 渲染问题。\n例如：\n1 \u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt; 更保险一些可以改写为\n1 \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;`代码`\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 其中 pre 标签是 HTML 中的一个标签，用于定义 预格式化文本。它的作用是按照原样保留文本的格式，尤其是 空格、换行和制表符 等白空格字符，不会被浏览器自动压缩或忽略。常用于显示格式化的文本内容，比如代码、日志文件等。\n以及，三个反引号之后的语法声明，例如 三反引号+html 只是使得代码块中的 HTML 语法高亮显示，而不是对其格式化。\n3.LaTex渲染测试 测试项目（1）：行内渲染和展示渲染\nS[x^A(t)]=\\int dtL(x^A(t),\\dot{x}^A(t))\\tag{1.0} d \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over B} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\times \\mathord{ \\buildrel{ \\lower3pt \\hbox{$ \\scriptscriptstyle \\rightharpoonup$}} \\over r} }}{{{r^3}}} = \\frac{{{ \\mu _0}}}{{4 \\pi }} \\frac{{Idl \\sin \\theta }}{{{r^2}}} 结果表明，展示渲染块内无需添加 // 以声明展示居中，这正是我们特地定义展示渲染模式的目的。（事实上，展示渲染加 // 会导致报错）\n根据 layouts/shortcode/latex.html 设定，{{latex}} 默认 display=\u0026ldquo;true\u0026rdquo; 因此展示渲染可以直接使用 {{latex}}{{/latex}}，行内展示则需要定义 display=\u0026ldquo;false\u0026rdquo;。(但是保险起见还是全都加上 dispaly 属性的好，因为有时 api 会因为一些神必原因而为此报错)\n测试结果项目（2）：公式内空格\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots)\nS[f+\\epsilon \\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon \\delta f,f'+\\epsilon \\delta f',f''+\\epsilon \\delta f''+\\cdots)\rS[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\nS[f+\\epsilon\\delta f]=\\int\\limits_{t_1}^{t_2}dtL(t_,f+\\epsilon\\delta f,f'+\\epsilon\\delta f',f''+\\epsilon\\delta f''+\\cdots)\r测试结果项目（3）：公式写法\n\\bigg、\\equiv 等特殊符号都是可用的。 align 环境中不可插入中文，需要使用 \\text{}。 特殊符号也不可携带中文，例如：\\xlongequal{\\text{变分与求导交换顺序}}、_{\\text{全导数}}。因此，我们或者使用全英文，或者对中文使用 \\text{} 转写。 {{latex}} 内可以无需在意符号转义。但是为了避免报错，还是建议当输入 f\u0026rsquo;(x) 这样的符号时，\u0026rsquo; 尽量使用英文冒号键而不是反引号键。 测试项目(2)证明了特殊符号之间的空格不影响渲染结果，但是，需要注意的是，特殊符号和字母之间必须有空格，例如 \\delta L。因为 \\deltaL 这个特殊符号是不存在的。 Markdown 加粗语法可以包裹 LaTeX 代码。 有序列表、无序列表都需要在文本和序号之间加一个空格符。\n4.脚注样式测试 The Einstein field equations (EFE) may be written in the form:1\nwhere G_{\\mu\\nu} is the Einstein tensor, g_{\\mu\\nu} is the metric tensor, T_{\\mu\\nu} is the stress–energy tensor, \\Lambda is the cosmological constant and \\kappa is the Einstein gravitational constant.\nFootnote 1.\n爱因斯坦场方程（EFE）可以写成： G_{\\mu \\nu}+\\Lambda g_{\\mu \\nu}=\\kappa T_{\\mu \\nu} where G_{\\mu\\nu} is the Einstein tensor, g_{\\mu\\nu} is the metric tensor, T_{\\mu\\nu} is the stress–energy tensor, \\Lambda is the cosmological constant and \\kappa is the Einstein gravitational constant.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","cover":null,"tags":null,"title":"测试专用页","url":"/notes/test-page/"},{"content":"","cover":null,"tags":["数学分析"],"title":"1.2","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.2/"},{"content":"1.请给出以下集合的笛卡尔积的几何解释：\n二线段（矩形） 二直线（平面） 直线和圆周（圆柱面） 直线和圆面（圆柱体） 二圆周（圆环面） 圆周和圆面（圆环体） 解答：\n二线段（矩形） 集合： A = [a_1, a_2] ， B = [b_1, b_2] 。 笛卡尔积：\nA \\times B = {(x, y) \\mid x \\in [a_1, a_2], y \\in [b_1, b_2] } 。\n几何解释：\n该笛卡尔积代表了二维平面中的一个矩形区域，其中横坐标范围为 [a_1, a_2] ，纵坐标范围为 [b_1, b_2] 。因此，笛卡尔积构成了一个矩形。\n二直线（平面） 集合： A = \\mathbb{R} ， B = \\mathbb{R} 。 笛卡尔积：\nA \\times B = \\mathbb{R}^2 几何解释：\n二直线的笛卡尔积是二维平面。每个直线可以看作一个一维空间（实数集合 \\mathbb{R} ），而笛卡尔积将其结合形成了一个二维平面 \\mathbb{R}^2 。\n直线和圆周（圆柱面） 集合： A = \\mathbb{R} ， B = S^1 （单位圆周）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times S^1 几何解释：\n直线和圆周的笛卡尔积在三维空间中形成了一个圆柱面。圆周 S^1 提供了一个循环的二维几何结构，直线 \\mathbb{R} 沿该圆周的每个点延伸，因此形成了一个圆柱面。圆柱面每一“层”都是一个圆周。\n当我们将圆周 S^1 中的点用极坐标表示时，通常会使用坐标对 (r,\\theta) ，由于 S^1 形成的圆周是一个单位圆，因此 r=1 。\nA=\\mathbb{R} 表示一条直线（即 x 轴）。 B=S^1 表示单位圆周，圆周上的任意一个点的极坐标表示为 (r,\\theta)=(1,\\theta) 基于以上条件，笛卡尔积 A \\times B = \\mathbb{R} \\times S^1 中的每一个元素就都是形如 (x,(1,\\theta)) 的元素。\n更进一步，如果我们考虑的是三维空间中的直线和圆周的笛卡尔积，则我们需要用笛卡尔坐标系来表示这些点。\n圆周上的点 (r,\\theta)=(1,\\theta) 通过极坐标转换到笛卡尔坐标时，可以得到圆周上一个点的笛卡尔坐标表示：\n(x,y)=(\\cos(\\theta),\\sin(\\theta))\r因此，笛卡尔积中元素点所对应的三维坐标形式即为：\n(x,y,z)=(\\cos(\\theta),\\sin(\\theta),a)\r其中 a\\in A 。\n这个结果表明了情况三的笛卡尔积的几何结构：\n直线（z 轴）上的每一个点 a 都对应圆周上的一个点 (\\cos(\\theta),\\sin(\\theta),a) (\\cos(\\theta),\\sin(\\theta),a) 最终构成的集合的几何形式即为 x-y 平面上的单位圆（简单起见，我们可以把圆心与坐标原点重合）。 (x,y,z)=(\\cos(\\theta),\\sin(\\theta),a) 所构成的几何形状自然就是，以 x-y 平面上的单位圆为底，整个 z 轴为高的一个圆柱面。（圆柱面是一个曲面，它由一族平行的直线构成，每条直线都通过一个固定的曲线（通常是圆形）。圆柱面是二维的，没有“内部”部分，它只包含外部的“面”。） 直线和圆面（圆柱体） 集合： A = \\mathbb{R} ， B = \\mathbb{R}^2 （二维圆面，如 x^2 + y^2 = r^2 ）。 笛卡尔积：\nA \\times B = \\mathbb{R} \\times \\mathbb{R}^2 几何解释：\n直线和圆面的笛卡尔积生成一个圆柱体。直线 \\mathbb{R} 是圆柱体的轴，而二维圆面 \\mathbb{R}^2 在每个点沿轴方向扩展，形成圆柱体的横截面。\n实际上，基于上一情况的描述，我们容易知道，这个圆周体上的元素的形式为：\n(x,y,z)=(r\\cos(\\theta),r\\sin(\\theta),a)\r二圆周（圆环面） 集合： A = S^1 ， B = S^1 。 笛卡尔积：\nA \\times B = S^1 \\times S^1 几何解释：\n两个圆周的笛卡尔积描述了一个圆环面。每个点在这个圆环面上都可以由两个角度来标定，分别属于两个独立的圆周。形象地说，圆环面是两个圆周的组合，类似于圆环的表面。\n在这个情况下，由于笛卡尔积的两个坐标都可以使用极坐标来表示，因此我们可以完全使用极坐标系来描述这个笛卡尔积，那么，该笛卡尔积上的每一个元素的形式即为：\n(r\\theta_1,r\\theta_2)=(\\theta_1,\\theta_2)\r让我们来看一些更有趣的事实：\n1. S^1 \\times S^1 的拓扑维度：\nS^1 是一个一维流形，它在拓扑意义上需要一个参数（ |\\theta ）即可描述。因此\nS^1 的维度是 1 维。 S^1 \\times S^1 的维度是 2 维。 从流形的角度，它本质上是一个二维流形（常称为环面或圆环面，torus）。这个二维性与所使用的坐标系无关——它是一个固有性质。无论你用哪种坐标（极坐标、角度坐标或其他），该流形本身的拓扑维度始终是 2。\n2.极坐标描述 vs. 笛卡尔坐标描述：\n在描述 S^1 \\times S^1 时，我们只需要用两组角度来参数化描述：\n(\\theta_1,\\theta_2)\r这里用两个角度参数就能完全描述这个流形上的任意一点，因此体现了它的二维本质。\n如果你尝试用“笛卡尔坐标”来描述每个 S^1 ，你可能会写出\nS^1=\\{(x,y)|x^2+y^2=1^2\\}\r这里的每一个 S^1 都嵌入到 \\mathbb{R}^2 中，因此 S^1 \\times S^1 被嵌入到 \\mathbb{R}^2 \\times \\mathbb{R}^2=\\mathbb{R}^4 中，在这种表示下，笛卡尔积元素中的一个点 (\\theta_1,\\theta_2) 被映射为：\n(\\cos(\\theta_1),\\sin(\\theta_1),\\cos(\\theta_2),\\sin(\\theta_2))\\in\\mathbb{R}^4\r虽然这里用了四个坐标数值来描述这个环面上的一个点，但这并不意味着该流形是四维的。它只意味着当你以这种方式嵌入到 \\mathbb{R}^4 时，这个二维流形占据了一个四维空间中的二维子集。换句话说，它是一个嵌入在四维空间中的二维曲面，就像一条线（1维）可以嵌入到平面（2维）中，而不会改变线本身是一维的事实。坐标系的选择不会改变流形的维数。\n因此，我们在情况3、4中说讨论的笛卡尔积，实际上都是二维流形嵌入三维空间的实例，它们本身仍然是二维的。\n圆周和圆面（圆环体） 集合： A = S^1 ， B = \\mathbb{R}^2 （二维圆面）。 笛卡尔积：\nA \\times B = S^1 \\times \\mathbb{R}^2 几何解释：\n圆周和圆面的笛卡尔积描述了一个圆环体。圆周 S^1 确定了该体的一个边界，而二维圆面 \\mathbb{R}^2 表示内部的自由度。圆环体可以想象为一个在三维空间中的“管状”体，外部表面是由圆周和圆面笛卡尔积形成的。\n有了情况5的讨论，我们很容易就可以看出此笛卡尔积的几何意义，本质上，它是一个三维流形，\n将 S^1 理解为一个“环”（圆周），将 \\mathbb{R}^2 理解为一个无限扩展的平面。那么 S^1 \\times \\mathbb{R}^2 可以看作是在圆周的每一点上，都“附着”了一个与之关联的二维平面。\n换句话说，如果你固定一个 \\theta \\in S^1 ，那么对应的 {\\theta} \\times \\mathbb{R}^2 就是一个平面。随着 \\theta 沿着圆周变化，这些平面在空间中“环绕”一圈，形成了一个三维的几何结构。\n若仅有 S^1 \\times \\mathbb{R} ，我们会得到一个圆柱面（2维流形：圆周 × 直线）。 而当直线 \\mathbb{R} 替换为平面 \\mathbb{R}^2 ，每个圆周点对应的不是一条线，而是一个无限扩展的平面。将这些无数平面按照圆周参数拼接起来，就会得到一个比圆柱面更高维的结构——一个 3维流形，可以形象地称其为“环状分布的无限平面叠加”。\n虽然这个形状很难在我们的三维直观中完全可视化，但从拓扑维度与参数化的角度，它是一个3维的流形，其内部结构由一个环状方向（ S^1 ）和两个线性无界方向（ \\mathbb{R}^2 ）组成。\n1. 什么是流形？\n首先，**流形（manifold）**是一个具有局部欧几里得空间结构的几何对象。对于 二维流形 来说，它在局部看起来就像一个二维平面，即在每个点附近都有一个局部坐标系统（通常是二维坐标）。但全局结构可能更复杂，具有弯曲或扭曲的特性。\n例如，地球表面是一个二维流形，它局部看上去是平面的（如地图上的小区域），但全局却是球形的。\n2. 二维流形嵌入到三维空间\n当我们说一个 二维流形 嵌入到 三维空间 中时，实际上是指流形的每个点都通过一个嵌入函数与三维空间中的一个点一一对应。这个嵌入的意义是，流形可以通过一些连续函数与三维空间的点相对应，使得流形在局部看起来和欧几里得平面一致，但可能具有全局的弯曲或曲率。 常见的二维流形嵌入三维空间的例子：\n圆环（圆周）：圆周是一个二维流形，局部上看起来像平面，但在三维空间中，它形成了一个二维曲面。 球面（如地球表面）：球面是一个二维流形，在三维空间中它表现为一个弯曲的表面。尽管它是二维流形，但它的形状在三维空间中是显而易见的。 环面（如甜甜圈形状）：环面是两个圆周的笛卡尔积( S^1 \\times S^1 )，它是一个二维流形，嵌入三维空间时，表现为一个环状的表面。 3. 流形看上去是否是三维的？\n当二维流形嵌入三维空间时，它 在整体上 不会显现出三维的结构，因为它只有 二维。然而，二维流形的形状和性质可能会因为其弯曲、扭曲等特性而使得它的几何体积在视觉上更为复杂，从而给人一种“近似三维”的感觉。 例如：\n一个 圆柱面 是一个二维流形，在三维空间中表现为一个有曲率的表面，尽管它是二维的，但由于其延伸在三维空间中，它看上去很像三维物体。(实际上，它的对应物体就是一张无限薄的，位于三维空间的，弯曲的矩形纸张。) 球面 是二维流形，但它在三维空间中的嵌入是弯曲的，从几何学上看，它显然是一个弯曲的三维物体，尽管它本质上是二维流形。 因此，二维流形在三维空间中的“外观”并不意味着它变成了三维物体，而是它依然是二维的，但是由于其在空间中是弯曲的，或者有拓扑结构，它会在视觉上显得有一定的复杂性。我们可以通过其 局部坐标系 和 全局形状 来区分它是二维的。\n3. 局部坐标系与全局形态\n我们之前讨论过，局部坐标系 能够描述流形在某一点附近的几何性质，但它无法揭示流形的 全局形态。对于 球面（S²） 或 球体（B³） 这样的物体，局部坐标系只能提供该物体某个小区域的欧几里得性质。\n在球面上的某个小区域，局部坐标系看起来像平面，但这不能描述球面的弯曲结构，尤其是球面的 全局曲率。局部坐标系无法直接揭示球面如何从局部变到整体的弯曲形状。球体的局部坐标系也只能描述球体某一点附近的结构，不能通过局部坐标系统来理解球体的 整体体积 和 三维结构。\n4.三维物体与二维物体的本质区别\n三维物体和二维物体的本质区别，不仅在于维度上的差异，还在于它们的 几何性质 和 拓扑结构。\n4.1 维度差异\n二维物体的每个点都可以用两个参数来描述，例如在平面上的 (x,y) 。在球面上，你可以使用极坐标 (r,\\theta) 来描述每个点。 三维物体每个点需要三个参数来描述，例如在三维空间中的 (x,y,z) 坐标。对于球体，球体的内部点和球面上的点都属于同一个物体，但它们在 维度 上有根本的区别，球体的内部有额外的体积和空间扩展。 4.2 几何性质\n二维物体：只有 两维几何属性（如弯曲度、曲率等）。二维物体通常不能再扩展成其他维度的结构，它只能弯曲或扭曲。\n三维物体：三维物体有 体积、厚度 和 空间，可以有不同的结构和属性，比如 体积的分布、内外结构、容积 等。这些特性使得三维物体与二维物体本质上有很大区别。 4.3 拓扑结构\n二维物体的拓扑：二维物体的拓扑结构决定了它的边界、孔洞等性质。一个球面是 无边界 的，且在全局上是 闭合 的。三维物体的拓扑：三维物体的拓扑结构决定了它的体积、边界和孔洞。一个球体是一个 三维 闭合体，具有 体积 和 内部结构。\n5.球面被嵌入三维空间时，其表面上的点将使用三个坐标参数来描述，为什么这不代表它具有第三个维度属性？\n这个问题实际上与经典力学的约束与自由度的解释是一致的。在数学中，球面 S^2 被视为一个二维流形。这意味着，尽管球面嵌入三维空间，我们仍然认为球面只有二维，因为我们用 两个参数 就能描述球面上的任何一点。\n球面是通过两个参数（比如极坐标系中的 \\theta 和 \\phi 来描述的\nS^2=\\{(x,y,z)\\in\\mathbb{R}^3|x^2+y^2+z^2=r^2\\} 虽然在三维空间中，球面上的每个点都需要三个坐标来表示，但这三个坐标是由 两个自由参数( \\theta 和 \\phi )和一个约束条件( x^2+y^2+z^2=r^2 ) 共同决定的。这些坐标并不增加球面作为流形的维度，而是描述了它的嵌入。\n","cover":null,"tags":["数学分析"],"title":"1.2 集合及其基本运算习题选做","url":"/notes/math/%E5%88%86%E6%9E%90%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/%E5%8D%93%E9%87%8C%E5%A5%87%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/1.1/"},{"content":"1.关于这个网站的用途： 本网站为个人博客网站。主要的用途有三个部分：\n读书笔记的记录。 学习过程中的思考记录 资源的合法分享 由于本人能力不足，无法做到在教材的基础之上进行创新的讲述，因此，读书笔记的内容可能会与原文存在很大重合。 但为了保证对原教材的权益保护。本网站绝不会进行任何的盈利活动，读书笔记的分享也仅出于个人的记录需要和学习的分享需要。 如果您发现网站有任何事实不正确、侵犯版权或任何其他问题，请联系我，我会按照您的要求进行删改。对于任何此类错误，我提前表示歉意。\n2.关于这个网站的目的： 由于一些特殊的原因，我没有在学校进行学习。我所有的学习资源和途径均来自于互联网上秉持着开源精神的伟大的人们。\n为此，我也希望对互联网进行力所能及的微小回馈。我将在这个网站分享我所有的读书笔记，希望我的资料可以帮助到对相关领域同样感兴趣的朋友们。另外，欢迎您通过网站内所提供的任何途径联系我，希望我们之间可能存在的沟通能够为您带来一些帮助。\n3.关于本人的联系方式 您可以通过邮箱和知乎联系我：\nQQ mail: chiaralee953@foxmail.com Zhihu：Chiara Lee 最后，希望您在我的网站玩的愉快。请尽情的享受探索知识的乐趣吧。\nChiara Lee\rChiara Lee\n以理性审视世界，凭理想创造世界。\n社交网络\nTwitter ZhiHu @Chiara-Lee Github @Chiara-Lee\r","cover":null,"tags":null,"title":"关于","url":"/about/"},{"content":"","cover":null,"tags":null,"title":"友人帐","url":"/friends/"},{"content":"网站建设部分 本网站借助了以下平台的服务，感谢这些平台慷慨的免费计划：\n1.网站框架及部署\nHugo 构建框架 Tailwind CSS 构建网站样式 Netlify 网站部署平台 ChatGPT 修复帮助、问题纠正以及资料查询(哦，等等，这个是付费的) 特别致谢：\nHugo in Action\u0026ndash;by Atishay Jain 该书为本网站建设的参考教材，网站前期的主体架构均来源于书中。在此感谢作者 Atishay Jain 的开源精神。 Atishay Jain 书作者 Github 账号 2.网站图片及文本\n圆角方 网站壁纸 Fontawesome 网站图标 重返未来1999 友人帐背景 Georgia 网站字体 [LaTeX] 网站上的 LaTeX 渲染来自\u0026quot;Hugo in Action\u0026quot;中的 api 文件，读者可以在我的 GitHub Calenton 库找到它 以上即为本网站目前引用的所有资料，关于本网站引用的教材资料，将会在 笔记 页进行特殊声明。最后，再次感谢以上资源提供者。\n","cover":null,"tags":null,"title":"引用资料致谢","url":"/reference/"}]